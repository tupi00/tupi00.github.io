

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>

<meta name="referrer" content="no-referrer" />


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#1f3144">
  <meta name="author" content="tupi">
  <meta name="keywords" content="unity">
  
    <meta name="description" content="行路难·其一[李白]金樽清酒斗十千，玉盘珍羞直万钱。停杯投箸不能食，拔剑四顾心茫然。欲渡黄河冰塞川，将登太行雪满山。闲来垂钓碧溪上，忽复乘舟梦日边。行路难，行路难，多歧路，今安在？长风破浪会有时，直挂云帆济沧海  基本语法简单使用移动设备、游戏主机、Web应用、物联网、微服务以及桌面应用. Hello,WorldC#从C和C++继承了基本的语法文件名不用匹配类名vscode,linqpad,vs2">
<meta property="og:type" content="article">
<meta property="og:title" content="c#学习笔记">
<meta property="og:url" content="http://tupi00.github.io/2022/12/01/skill/csharp/csharp/index.html">
<meta property="og:site_name" content="tupi的博客">
<meta property="og:description" content="行路难·其一[李白]金樽清酒斗十千，玉盘珍羞直万钱。停杯投箸不能食，拔剑四顾心茫然。欲渡黄河冰塞川，将登太行雪满山。闲来垂钓碧溪上，忽复乘舟梦日边。行路难，行路难，多歧路，今安在？长风破浪会有时，直挂云帆济沧海  基本语法简单使用移动设备、游戏主机、Web应用、物联网、微服务以及桌面应用. Hello,WorldC#从C和C++继承了基本的语法文件名不用匹配类名vscode,linqpad,vs2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/8f43d3cb984565983b69724a9a4f1917.jpg">
<meta property="article:published_time" content="2022-12-01T04:10:23.399Z">
<meta property="article:modified_time" content="2022-12-01T04:21:20.289Z">
<meta property="article:author" content="tupi">
<meta property="article:tag" content="unity">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/8f43d3cb984565983b69724a9a4f1917.jpg">
  
  
  
  <title>c#学习笔记 - tupi的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tupi00.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>归来</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="c#学习笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        tupi
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-12-01 12:10" pubdate>
          2022年12月1日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          102k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          854 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="学习"
        id="heading-4ef520d6cd20ba4a727af08e17e4939e" role="tab" data-toggle="collapse" href="#collapse-4ef520d6cd20ba4a727af08e17e4939e"
        aria-expanded="true"
      >
        学习
        <span class="list-group-count">(4)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-4ef520d6cd20ba4a727af08e17e4939e"
           role="tabpanel" aria-labelledby="heading-4ef520d6cd20ba4a727af08e17e4939e">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2022/12/01/skill/csharp/csharp/" title="c#学习笔记"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">c#学习笔记</span>
        </a>
      
    
      
      
        <a href="/2022/11/04/git/" title="git"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">git</span>
        </a>
      
    
      
      
        <a href="/2022/11/04/win/" title="windows shell"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">windows shell</span>
        </a>
      
    
      
      
        <a href="/2022/11/07/skill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式笔记"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">设计模式笔记</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="c#"
        id="heading-240aa2cec4b29c56f3bee520a8dcee7e" role="tab" data-toggle="collapse" href="#collapse-240aa2cec4b29c56f3bee520a8dcee7e"
        aria-expanded="true"
      >
        c#
        <span class="list-group-count">(2)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-240aa2cec4b29c56f3bee520a8dcee7e"
           role="tabpanel" aria-labelledby="heading-240aa2cec4b29c56f3bee520a8dcee7e">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2022/12/01/skill/csharp/csharp/" title="c#学习笔记"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">c#学习笔记</span>
        </a>
      
    
      
      
        <a href="/2022/11/09/skill/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" title="学习路线"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">学习路线</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">c#学习笔记</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：11 天前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/8f43d3cb984565983b69724a9a4f1917.jpg" srcset="/img/loading.gif" lazyload><br>行路难·其一<br>[李白]<br>金樽清酒斗十千，玉盘珍羞直万钱。<br>停杯投箸不能食，拔剑四顾心茫然。<br>欲渡黄河冰塞川，将登太行雪满山。<br>闲来垂钓碧溪上，忽复乘舟梦日边。<br>行路难，行路难，多歧路，今安在？<br>长风破浪会有时，直挂云帆济沧海</p>
<hr>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>移动设备、游戏主机、Web应用、物联网、微服务以及桌面应用.</p>
<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello,World"></a>Hello,World</h3><p>C#从C和C++继承了基本的语法<br>文件名不用匹配类名<br>vscode,linqpad,vs2022</p>
<h3 id="dotnet-CLI"><a href="#dotnet-CLI" class="headerlink" title="dotnet CLI"></a>dotnet CLI</h3><p>dotnet.exe是dotnet命令行接口（或称dotnet CLI)</p>
<ul>
<li>使用</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir ./HelloWorld<br>cd ./HelloWorld<br>dotnet new console<br></code></pre></td></tr></table></figure>

<p>会创建默认Programs.cs</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dotnet run<br></code></pre></td></tr></table></figure>

<p>生成dll文件在.&#x2F;bing&#x2F;Debug&#x2F;xxx&#x2F;里</p>
<ul>
<li>编译</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">donet build <br></code></pre></td></tr></table></figure>

<ul>
<li>发布可执行文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dotnet public -runtime<br></code></pre></td></tr></table></figure>

<h2 id="简单解析"><a href="#简单解析" class="headerlink" title="简单解析"></a>简单解析</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>  编译器根据关键字的固有语法来解释程序员写的表达式.<br>  在HelloWorld程序中，class、static和void均是关键字。<br>  <img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668641936821.png" srcset="/img/loading.gif" lazyload><br>  *这些是上下文关键字，括号中的数字（n）代表加入该上下文关键字的C#版本。</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>  标识程序员编码的构造。<br>  HelloWorld和Main均为标识符。<br>  <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/standard/design-guidelines/">标识符设计框架准则</a></p>
<ul>
<li><p>可以<code>@</code>前缀关键字为标识符</p>
<h3 id="定义类型"><a href="#定义类型" class="headerlink" title="定义类型"></a>定义类型</h3></li>
<li><p>类定义 class 标识符{…}</p>
<ul>
<li><p>要用名词或名词短语命名类。</p>
</li>
<li><p>要为所有类名使用PascalCase大小写风格</p>
<h3 id="Main方法"><a href="#Main方法" class="headerlink" title="Main方法"></a>Main方法</h3><p>C#方法是已命名代码块.提供了结构化和组织代码的一种方式，使之更易读。更重要的是，方法可以重用.</p>
</li>
</ul>
</li>
</ul>
<p>C#程序从Main方法开始执行。该方法以static void Main()开头。</p>
<p>Main返回的int是状态码.非0意味着错误.</p>
<p>Main方法支持<code>async/await</code></p>
<h3 id="语句和分隔符"><a href="#语句和分隔符" class="headerlink" title="语句和分隔符"></a>语句和分隔符</h3><p>代码块本身就被视为语句.</p>
<p>允许一条语句跨越多行，根据<code>;</code>判断结束位置</p>
<h3 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h3><p>分号使C#编译器能忽略代码中的空白</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>单行注释<code>//</code></li>
<li>多行注释<code>/**/</code><ul>
<li>还能插入语句中</li>
</ul>
</li>
<li>XML注释</li>
</ul>
<blockquote>
<p>写注释来重复代码本来就讲得清的事情，只会使代码变得臃肿并降低可读性，还容易过时，因为将来代码可能更改了但注释却没有来得及更新。</p>
<p>没有注释但可读性好的代码，比需要注释才能说清楚的代码更有价值</p>
<p>不要使用注释，除非代码本身“一言难尽”。要尽量写清楚的代码而不是通过注释澄清复杂的算法。</p>
</blockquote>
<h3 id="控制台输入和输出"><a href="#控制台输入和输出" class="headerlink" title="控制台输入和输出"></a>控制台输入和输出</h3><ul>
<li><code>System.Console.ReadLine()</code><ul>
<li><code>System.Console.Read()</code>返回的是整数</li>
<li><code>System.Console.ReadKey()</code>单次输入</li>
</ul>
</li>
<li><code>System.Console.WriteLine()</code><ul>
<li><code>System.Console.Write()</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>字符串插值功能<code>$&quot;xxx&#123;Name&#125;xxx&quot;</code> 字符串复合格式化<code>&quot;xxx&#123;0&#125;xx&#123;1&#125;,Name,Age&quot;</code></p>
</blockquote>
<h3 id="托管执行和CLI"><a href="#托管执行和CLI" class="headerlink" title="托管执行和CLI"></a>托管执行和CLI</h3><p>处理器不能直接解释程序集。程序集用的是另一种语言，即公共中间语言IL&#x2F;CIL</p>
<p>C#编译器将C#源代码文件转换成中间语言。为了将CIL代码转换成处理器能理解的机器码，还要完成一个额外的步骤（通常在运行时进行）。</p>
<p>该步骤涉及C#程序执行的一个重要元素：VES(虚拟执行系统)运行时.它根据需要编译CIL代码，这个过程称为即时编译或JIT编译.这种代理方式就是托管代码</p>
<p>运行时管理着诸如内存分配、安全性和JIT编译等方面，从而控制了主要的程序行为。</p>
<blockquote>
<p>执行时”表示“程序执行的时候”<br>用“运行时”表示负责管理C#程序执行的代理</p>
</blockquote>
<h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p>Common Language Infrastructure，公共语言基础结构.</p>
<p>是一个规范:</p>
<ul>
<li>运行时</li>
<li>CIL</li>
<li>支持语言互操作性的类型系统，称为CTS</li>
<li>编写通过CLI兼容语言访问的库的指导原则</li>
<li>使各种服务能被CLI识别的元数据（包括程序集的布局或文件格式规范）</li>
</ul>
<p>通过复合规范就可以使用服务:语言互操作，类型安全，代码访问安全性，垃圾回收，平台可移植，BCL(基类库)</p>
<blockquote>
<p>ILDASM反汇编</p>
</blockquote>
<h3 id="多个-NET框架"><a href="#多个-NET框架" class="headerlink" title="多个.NET框架"></a>多个.NET框架</h3><ul>
<li><p>.NET Core</p>
</li>
<li><p>Xamarin</p>
</li>
<li><p>Unity</p>
</li>
</ul>
<p>API:应用编程接口，定义软件和其他组件交互方式.</p>
<p>.NET框架”一词指代.NET Core或Microsoft .NET Framework的所有程序集公开的API。API通常包含一组接口和协议（或指令），帮助你使用一系列组件进行编程。</p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><blockquote>
<p>除非是最简单的单行if语句，否则避免省略大括号</p>
</blockquote>
<h3 id="命名空间。"><a href="#命名空间。" class="headerlink" title="命名空间。"></a>命名空间。</h3><p>命名空间是一种分类机制，用于分组功能相关的所有类型。</p>
<p>命名空间主要用于按功能领域组织类型，以便查找和理解这些类型。此外，命名空间还有助于防范类型名称冲突</p>
<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>声明局部变量。变量声明后可以赋值，可将值替换成新值，并可在计算和输出等操作中使用。但变量一经声明，数据类型就不能改变。</p>
<blockquote>
<p>声明局部变量。变量声明后可以赋值，可将值替换成新值，并可在计算和输出等操作中使用。但变量一经声明，数据类型就不能改变。</p>
</blockquote>
<h3 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h3><p>表示源代码中的固定值。如<code>12,12.5,&#39;x&#39;,&quot;abc&quot;&#39;</code></p>
<blockquote>
<p>直接将值放到源代码中称为硬编码.难维护</p>
<p>可以考虑从一个外部来源获取值，比如从一个配置文件中。这样以后需要修改值的时候，就不需要重新编译代码了。</p>
</blockquote>
<p>可以使用<code>F</code>和<code>D</code>作为后缀，将字面值分别显式声明为float或者double.<code>U</code>-&gt;uint,ulong.<code>L</code>-&gt;long,ulong</p>
<ul>
<li>数字分隔符<code>_</code></li>
<li>指数计数法<code>E</code>中缀</li>
<li>十六进制<code>0x</code>前缀</li>
<li>二进制<code>0b</code>前缀</li>
</ul>
<blockquote>
<p>数字格式化16进制:<code>$&quot;0x&#123;42:X&#125;&quot;</code></p>
</blockquote>
<blockquote>
<p>round-trip格式来防止丢弃最后文本<code>string.Format(&quot;&#123;0:R&#125;</code></p>
</blockquote>
<h4 id="null和void"><a href="#null和void" class="headerlink" title="null和void"></a>null和void</h4><p>null值表明变量不引用任何有效的对象</p>
<ul>
<li>可做文本表示未知。<ul>
<li><code>&quot;&quot;</code>表示空白内容</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>可空修饰符<code>?</code>，声明变量名称后，使值类型也可以为空.<ul>
<li>可空引用类型:当这一概念被启用时，将没有可空修饰符的变量设置为null将会产生警告信息。启用“可空引用类型”的概念<code>#nullable enable</code><ul>
<li><code>string?homeNumber=null;</code>方可使用</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>检查null:</p>
<ul>
<li><p><code>==</code></p>
</li>
<li><p><code>ReferenceEquals()</code></p>
</li>
<li><p><code>is null</code> 比较好用</p>
</li>
</ul>
<p>void表示无类型，或者没有任何值。</p>
<h4 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h4><p>常量表达式是C#编译器能在编译时求值的表达式（而不是在运行时才能求值）因为其完全由常量操作数构成</p>
<blockquote>
<p>不要用常量表示将来可能改变的任何值。π和金原子的质子数是常量。金价、公司名和程序版本号则应该是变量</p>
</blockquote>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型（或对象类型）是具有相似特征和行为的个体的分类。</p>
<p>一个类型要么是值类型，要么是引用类型。区别在于拷贝方式：值类型的数据总是拷贝值；而引用类型的数据总是拷贝引用</p>
<ul>
<li>值类型</li>
</ul>
<p>值类型直接包含值，变量引用的位置就是内存中实际存储值的位置</p>
<p>除了string,所有的预定义类型都是值类型.</p>
<p>复制时，修改其中任何一个值都不会影响另一个值.</p>
<blockquote>
<p>由于值类型需要创建内存拷贝，因此定义时不要让它们占用太多内存（通常应该小于16字节）</p>
</blockquote>
<ul>
<li>引用类型</li>
</ul>
<p>变量存储对数据存储位置的引用，而不是直接存储数据.</p>
<p>运行时”要先从变量中读取内存位置，再“跳转”到包含数据的内存位置。(解引用)</p>
<p>为引用类型的变量分配实际数据的内存区域称为堆</p>
<p>拷贝的是对数据的引用.</p>
<p>常见类型:</p>
<ul>
<li><code>string</code>引用类型</li>
<li><code>int</code>32位整型值类型</li>
<li><code>char</code>字符值类型</li>
</ul>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>局部变量使用驼峰法命名.</p>
<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>C#要求局部变量在读取前“明确赋值”。</p>
<p>此外，赋值作为一种操作会返回一个值。</p>
<blockquote>
<p>所有string类型的数据，不管是不是字符串字面值,都是不可变的.只能重新赋值</p>
</blockquote>
<h3 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h3><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>具名事物的作用域是源代码的一个区域。可在该区域使用非限定名称（前面不加限定前缀的名称）引用该事物。局部变量的作用域就是封闭它的代码块</p>
<h3 id="可空变量"><a href="#可空变量" class="headerlink" title="可空变量"></a>可空变量</h3><ul>
<li><p>对于值类型:int? number&#x3D;null将声明一个可空的int型变量，并将其值初始化为null</p>
<ul>
<li><p>在实际中，当我们调用一个值类型变量的方法或者访问其属性时，仍然认为是在对该值类型变量进行解引用</p>
<blockquote>
<p>对可空值类型的操作实际是对<code>Nullable&lt;T&gt;</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>对于引用类型则会出现空引用异常</p>
<ul>
<li><p>启用引用类型的可空性特性:<code>#nullable enable</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta">#nullable enable</span><br><span class="hljs-built_in">string</span>? str=<span class="hljs-literal">null</span>;<br>Console.WriteLine(str?.Length);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p>空检查:.<br>方式1:is判断<br>方式2:<strong>null值条件操作符</strong><code>?.</code></p>
</blockquote>
<h3 id="隐式类型的局部变量"><a href="#隐式类型的局部变量" class="headerlink" title="隐式类型的局部变量"></a>隐式类型的局部变量</h3><p><code>var</code>无需显式声明变量的数据类型，由编译器推断</p>
<blockquote>
<p>匿名类型:在方法内部动态声明的数据类型，而不是通过显式的类定义来声明</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">var <span class="hljs-attribute">v</span>=new&#123;<span class="hljs-attribute">Age</span>=3&#125;;<br></code></pre></td></tr></table></figure>

<p>但自从C# 7.0引入元组语法后，匿名类型几乎就用不着了。</p>
</blockquote>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>合并数据元素。<br>允许在一条语句中完成对所有变量的赋值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">(<span class="hljs-built_in">string</span> country,<span class="hljs-built_in">double</span> gdp) t=(<span class="hljs-string">&quot;China&quot;</span>,<span class="hljs-number">249310E8</span>);<br></code></pre></td></tr></table></figure>

<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668677224639.png" srcset="/img/loading.gif" lazyload alt="元组语法"> 左侧仍然是单独的变量，只是用元组语法一起赋值.虽然右侧的值合并成元组，但在向左侧赋值的过程中，元组已被解构为它的组成部分.使用的是元祖语法，而不是元祖。</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668677243397.png" srcset="/img/loading.gif" lazyload alt="元组"> 左侧声明一个元组，将右侧的元组赋给它。注意元组含具名项，随后可引用这些名称来获取右侧元组中的值。这正是能在System.Console.WriteLine语句中使用countryInfo.Name、countryInfo.Capital和countryInfo.GdpPerCapita语法的原因。在左侧声明元组造成多个变量组合到单个元组变量（countryInfo）中</p>
<blockquote>
<p>要为元组语法的变量声明使用camelCase大小写规范。<br>考虑为所有元组项名称使用PascalCase大小写风格。</p>
</blockquote>
<p>元组是在对象中封装数据的轻量级方案</p>
<p>元组项数量也是在编译时硬编码好的。最后，不能为元组添加自定义行为（扩展方法不在此列）<br>如果需要和封装数据关联的行为，则应使用面向对象编程并定义一个类</p>
<blockquote>
<p>底层实现:<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668677798083.png" srcset="/img/loading.gif" lazyload><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668677818702.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>可在单个变量中存储同一种类型的多个数据项。使用从零开始的索引进行单独访问数据。固定长度，在声明时确定(可在运行时)。</p>
<p>index from end:<code>^1</code>将访问数组中最后一个元素<br>range between and:<code>..</code></p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668678006063.png" srcset="/img/loading.gif" lazyload> <img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668678026733.png" srcset="/img/loading.gif" lazyload></p>
<p>分配数组但不指定初始值，“运行时”会将每个数组元素初始化为它们的默认值</p>
<p><code>^</code>操作符后面不局限于使用字面量数字，也可以使用任何返回正整数的表达式</p>
<ul>
<li><code>Length</code>属性</li>
</ul>
<blockquote>
<p>访问数组之前应当检查数组变量是否为null，而不应该假设数组变量总是指向一个有效的数组。<br>访问数组时，应当从Length属性获得数组长度，而不应该使用假设的长度。<br>应当用^1来访问末尾元素，而不必再使用Length-1</p>
</blockquote>
<p><code>System.Index</code>和<code>System.Range</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">System.Index index=^<span class="hljs-number">42</span>;<span class="hljs-comment">//Value和IsFromEnd属性</span><br>System.Range range=..^<span class="hljs-number">0</span>;<span class="hljs-comment">//index类型的Start和End属性</span><br>range=..;<br></code></pre></td></tr></table></figure>

<p>常用静态方法<code>Array</code>:<code>Sort() BinarySearch()/*先排序在查找*/ Reverse() Clear()/*不是删除元素或Length设为0，而是把元素设为默认值*/</code></p>
<p>实例方法:<code>GetLength() Rank/*维数*/ Clone()/*浅克隆*/</code></p>
<blockquote>
<p>大多数程序现在都用泛型集合类型而非数组来存储数据集合</p>
</blockquote>
<h4 id="字符串作为数组"><a href="#字符串作为数组" class="headerlink" title="字符串作为数组"></a>字符串作为数组</h4><p>访问string类型的变量类似于访问字符数组</p>
<p>由于字符串不可变，所以不能向字符串中的特定位置赋值</p>
<ul>
<li><code>ToCharArray()</code></li>
</ul>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>预定义类型(基元类型),几种类型非常简单，是其他所有类型的基础.</p>
<ul>
<li>八种整数</li>
<li>两种浮点数</li>
<li>一种十进制浮点数</li>
<li>一种布尔</li>
<li>一种字符类型</li>
</ul>
<p>基元数据类型的完整名称提供了短名称,建议使用短名称</p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668675357118.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>将浮点变量设为0.1，很容易表示成0.099999 999 999 999 999或者0.100 000 000 000000 000 1</p>
<p>浮点数精度由有效数位的个数决定.double型浮点数可以表示的有效数字最多为17位，float型为最多9位</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668675382293.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>采用二进制浮点数来存储数值.用十进制和二进制所表示的实数都存在舍入误差问题.</p>
<blockquote>
<p>99.9的二进制表示：1100011.111001100110011001100110011001100110011001101。现在我们需要将小数点左移6位，对应的指数值为+6。此时小数点右侧的位数为51位，这些将会被存放在尾数部分，如果使用double类型可以将数据全部记录，但是如果使用float类型，由于尾数部分只有23位，所有只能记录部分的数据，误差也就产生了！整理一下，符号位为0，指数部分为6+127&#x3D;133，尾数部分直接丢进去，能装多少装多少，以float为例。最终表示为：0 10000101 10001111100110011001100  </p>
</blockquote>
</blockquote>
<h3 id="decimal"><a href="#decimal" class="headerlink" title="decimal"></a>decimal</h3><p>128位精度的十进制浮点类型</p>
<p>decimal类型保证范围内的所有十进制数都是精确的。而不是近似值.</p>
<p>范围小，速度慢，但是精确.</p>
<blockquote>
<p>内部是使用科学计数法来存储</p>
</blockquote>
<h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><p>条件语句和表达式中表示真或假,值为<code>true/false</code></p>
<p>bool实际大小是一个字节</p>
<h3 id="char"><a href="#char" class="headerlink" title="char"></a>char</h3><p>字符类型char表示16位字符,表示Unicode字符集，注意取值范围不是0~65535</p>
<p>转义序列:</p>
<ul>
<li><code>\n</code></li>
<li><code>\\</code></li>
<li><code>\t</code></li>
<li><code>\b</code></li>
<li><code>\&#39;</code> <code>\&quot;</code></li>
<li><code>\0</code>null</li>
</ul>
<p>使用<code>\uxxx</code>表示16位Unicode字符</p>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>零或多个字符的<strong>不可变</strong>有限序列</p>
<p><code>@</code>前缀取消转义(“”除外)</p>
<p><code>$</code>插值是<code>string.Format()</code>的语法糖</p>
<p><code>&#123;&#125;</code>复合格式</p>
<p>常见方法:</p>
<ul>
<li>静态方法<ul>
<li>Format()</li>
<li>Concat()</li>
<li>Compare()默认区分大小写，第三个参数<code>true</code>不区分</li>
</ul>
</li>
<li>实例方法<ul>
<li>StatWith(),EndWith()</li>
<li>ToLower(),ToUpper()</li>
<li>Trim()</li>
<li>Replace()</li>
</ul>
</li>
</ul>
<blockquote>
<p>using static指令避免使用类名,可以直接使用静态方法</p>
</blockquote>
<p>格式化:组合格式化</p>
<p>长度:Length</p>
<blockquote>
<p>可变字符串:<code>System.Text.StringBuilder</code></p>
</blockquote>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><ul>
<li><code>()</code></li>
</ul>
<blockquote>
<p>checked:将数据溢出引发异常，而不是二进制+1</p>
<p>unchecked阻止异常</p>
</blockquote>
<p>不能数值型到bool的转换</p>
<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>int-&gt;long不会丢失数据，而且不会抛出异常都可以隐式转换</p>
<h3 id="Parse和Convert"><a href="#Parse和Convert" class="headerlink" title="Parse和Convert"></a>Parse和Convert</h3><p>每个数值数据类型都包含一个Parse()方法，允许将字符串转换成对应的数值类型</p>
<p>System.Convert只支持少量类型，且不可扩展</p>
<blockquote>
<p>TryParse()返回false代替抛出异常.</p>
</blockquote>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="一元正负操作符"><a href="#一元正负操作符" class="headerlink" title="一元正负操作符"></a>一元正负操作符</h3><h3 id="二元算数操作符"><a href="#二元算数操作符" class="headerlink" title="二元算数操作符"></a>二元算数操作符</h3><ul>
<li><p>&#96;+-*&#x2F; %</p>
</li>
<li><p><code>()</code></p>
</li>
</ul>
<blockquote>
<p>避免将二进制浮点类型用于相等性条件式。要么判断两个值之差是否在容差范围之内，要么使用decimal类型</p>
</blockquote>
<h3 id="递增递减操作符"><a href="#递增递减操作符" class="headerlink" title="递增递减操作符"></a>递增递减操作符</h3><ul>
<li><code>++ --</code> 在前先运算，在后先赋值</li>
</ul>
<h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><ul>
<li><code>+= -=</code></li>
</ul>
<h3 id="关系操作符和相等操作符"><a href="#关系操作符和相等操作符" class="headerlink" title="关系操作符和相等操作符"></a>关系操作符和相等操作符</h3><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668839059108.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p><code>&amp;&amp; || !</code>短路效应</p>
<h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p><code>?:</code></p>
<blockquote>
<p>考虑使用if&#x2F;else语句而不是过于复杂的条件表达式</p>
</blockquote>
<h3 id="空合并操作符"><a href="#空合并操作符" class="headerlink" title="空合并操作符"></a>空合并操作符</h3><ul>
<li><code>??</code>空则使用另一个值。支持短路。</li>
</ul>
<h3 id="空条件操作符"><a href="#空条件操作符" class="headerlink" title="空条件操作符"></a>空条件操作符</h3><ul>
<li><p><code>?</code>不空才访问</p>
<ul>
<li><p><code>?.</code></p>
</li>
<li><p><code>?[]</code></p>
<blockquote>
<p>用于委托更优雅</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="空包容操作符"><a href="#空包容操作符" class="headerlink" title="空包容操作符"></a>空包容操作符</h3><p><code>!</code>该操作符告诉编译器程序员可以保证某个变量一定不为null值，从而在编译时，编译器会相信程序员的保证而不再产生警告信息。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">uri=<span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&#x27;/&#x27;</span>,segments!);<br></code></pre></td></tr></table></figure>

<p>由于Join()方法要求第二个参数不为空，因此如果直接将未赋值的可空型变量segments作为参数，则会产生编译器警告。在C# 8.0中可以使用空包容操作符(!)来避免该警告。</p>
<h3 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符"></a>按位操作符</h3><ul>
<li><code>&gt;&gt; &lt;&lt;</code>位移</li>
<li>&#96;&amp; | ^逻辑</li>
<li><code>~</code>求反</li>
</ul>
<blockquote>
<p>虽然传说x &lt;&lt; 2比x*4快，但不要将移位操作符用于乘除法,现代微处理器都对算术运算进行了完美的优化</p>
</blockquote>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p>控制流程语句在运行时求值条件表达式</p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><h3 id="while和do-while"><a href="#while和do-while" class="headerlink" title="while和do-while"></a>while和do-while</h3><p>常见于死循环</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>有一套内建的语法规定了如何初始化、递增以及测试一个计数器的值。该计数器称为循环变量。由于循环语法中专门有一个位置是为递增&#x2F;递减操作保留的，所以递增&#x2F;递减操作符经常作为for循环的一部分使用。</p>
<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>foreach循环的特点是每一项只迭代一次：不会像其他循环那样出现计数错误，也不可能越过集合边界</p>
<p>foreach循环期间禁止修改循环变量</p>
<blockquote>
<p>foreach循环结构被编译器扩展成while循环结构，它以从IEnumerable<T>接口获取的IEnumerator<T>接口为基础</p>
</blockquote>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>将一个值和多个常量值比较时，switch比if语句更易理解</p>
<blockquote>
<p>不要使用continue作为跳转语句退出switch小节。尽管switch在循环中时这样写合法，但很容易对之后的switch小节中出现的break产生困惑</p>
</blockquote>
<ul>
<li><p>任何小节的switch语句会产生编译器警告，但语句仍能通过编译</p>
</li>
<li><p>各小节可为任意顺序，default小节不一定要出现在switch语句最后，甚至可以省略</p>
</li>
<li><p>要求每个switch小节（包括最后一个小节）的结束点“不可到达”。这意味着switch小节通常以break、return、throw或goto结尾</p>
</li>
</ul>
<h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><ul>
<li><p>break</p>
</li>
<li><p>continue</p>
</li>
<li><p>goto</p>
<blockquote>
<p>避免使用goto</p>
</blockquote>
</li>
</ul>
<h2 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h2><p>处理器在编译时调用。预处理器指令告诉C#编译器要编译哪些代码，并指出如何处理代码中的特定错误和警告。C#预处理器指令还可告诉C#编译器有关代码组织的信<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668840622931.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>编译器选项生成define<code>dotnet.exe -definr:CSHA Test.cs</code></p>
</blockquote>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEST</span><br><span class="hljs-meta"># <span class="hljs-keyword">if</span> TEST</span><br>...<br><span class="hljs-meta"># <span class="hljs-keyword">elif</span> NOT TEST</span><br>...<br><span class="hljs-meta"># <span class="hljs-keyword">else</span></span><br>...<br><span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<h3 id="启用可空"><a href="#启用可空" class="headerlink" title="启用可空"></a>启用可空</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta">#nullable enable</span><br><span class="hljs-meta">#nullable disable//关闭</span><br><span class="hljs-meta">#nullable restore//将可空引用类型的可用状态恢复为整个工程的全局设置状态</span><br></code></pre></td></tr></table></figure>

<h3 id="折叠代码段"><a href="#折叠代码段" class="headerlink" title="折叠代码段"></a>折叠代码段</h3><p><code>#region[]...#endregion</code></p>
<h2 id="方法和参数"><a href="#方法和参数" class="headerlink" title="方法和参数"></a>方法和参数</h2><p>随着程序变得越来越复杂，需要新的思维模式来管理这种复杂性。“过程式”或“结构化”编程的基本思路就是提供对语句分组来构成单元的构造。此外，可通过结构化编程将数据传给一个语句分组，在这些语句执行完毕后返回结果<br>方法组合一系列语句以执行特定操作或计算特定结果。它能为构成程序的语句提供更好的结构和组织。</p>
<blockquote>
<p>要为方法名使用动词或动词短语</p>
</blockquote>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>一个类中的所有方法都必须有唯一签名，C#依据方法名、参数数据类型或参数数量的差异来定义唯一性。</p>
<h4 id="类型名称"><a href="#类型名称" class="headerlink" title="类型名称"></a>类型名称</h4><p>调用静态方法时，不需要类型名称，是因为编译器能够根据调用位置推断类型。显然，如果编译器无法进行这样的推断，就必须将类型名称作为方法调用的一部分</p>
<p>类型本质上是对方法及其相关数据进行分组的一种方式</p>
<h4 id="方法名称"><a href="#方法名称" class="headerlink" title="方法名称"></a>方法名称</h4><p>每个方法调用都要指定一个方法名称。如前所述，它可能用也可能不用命名空间和类型名称加以限定。方法名称之后是圆括号中的实参列表，每个实参以逗号分隔，对应于声明方法时指定的形参。</p>
<h4 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h4><p>方法可获取任意数量的形参，每个形参都具有特定的数据类型。调用者为形参提供的值称为实参，每个实参都要和一个形参对应。</p>
<h4 id="方法返回值"><a href="#方法返回值" class="headerlink" title="方法返回值"></a>方法返回值</h4><p>void或者数据类型</p>
<h3 id="方法的声明"><a href="#方法的声明" class="headerlink" title="方法的声明"></a>方法的声明</h3><blockquote>
<p>将一组语句转移到一个方法中，而不是把它们留在一个较大的方法中，这是一种重构形式</p>
</blockquote>
<h4 id="参数声明"><a href="#参数声明" class="headerlink" title="参数声明"></a>参数声明</h4><p>可在方法声明的圆括号中添加参数列表</p>
<p>列表中的每个参数都包含参数类型和参数名称，每个参数以逗号分隔</p>
<h4 id="方法返回类型声明"><a href="#方法返回类型声明" class="headerlink" title="方法返回类型声明"></a>方法返回类型声明</h4><ul>
<li>return<ul>
<li>返回元组类型.多个值可通过C#元组语法打包成元组返回</li>
</ul>
</li>
</ul>
<blockquote>
<p>虽然C#允许提前返回，但为了增强代码的可读性，并使代码更易维护，应尽量确定单一的退出位置，而不是在方法的多个代码路径中散布多个return语句。</p>
</blockquote>
<ul>
<li>指定void作为返回类型表示该方法没有返回值。所以，这种方法不支持向变量赋值，也无法在调用位置作为参数传递。void调用只能作为语句使用.可选的return</li>
</ul>
<h4 id="表达式主体方法"><a href="#表达式主体方法" class="headerlink" title="表达式主体方法"></a>表达式主体方法</h4><p>用表达式代替完整方法主体</p>
<p>表达式主体方法不是用大括号定义方法主体，而是用&#x3D;&gt;操作符</p>
<p>虽然没有显式的return语句，但表达式本身的返回类型必须与方法声明的返回类型匹配</p>
<h3 id="using指令"><a href="#using指令" class="headerlink" title="using指令"></a>using指令</h3><ul>
<li><p>显示导入命名空间</p>
</li>
<li><p><code>using static</code>，使用静态方法</p>
</li>
<li><p>嵌套:在命名空间内部使用</p>
</li>
<li><p>别名:<code>using T=Test</code></p>
</li>
</ul>
<h3 id="Main-的返回值和参数"><a href="#Main-的返回值和参数" class="headerlink" title="Main()的返回值和参数"></a>Main()的返回值和参数</h3><p>假如一个程序的两个类都有Main()方法，可以选取其中一个类作为程序的入口点。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dotnet build /p:StartupObject=Test.Program<br></code></pre></td></tr></table></figure>
<h3 id="值参数"><a href="#值参数" class="headerlink" title="值参数"></a>值参数</h3><p>参数默认采用传值方式。换言之，参数值会拷贝到目标参数中。</p>
<p>调用栈在一次调用的末尾“展开”的时候，拷贝的数据会被丢弃。</p>
<blockquote>
<p>如<strong>引用类型的变量</strong>以传值方式传给方法，拷贝的就是引用（地址）本身。这样虽然在被调用的方法中还是更改不了引用（地址）本身，但可以更改地址处的数据。相反，对于<strong>值类型的参数</strong>，参数获得的是值的拷贝，所以被调用的方法怎么都改变不了调用者的变量。</p>
</blockquote>
<h3 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h3><p><code>ref</code>，这使参数以传引用的方式传递，被调用的方法可用新值更新调用者的变量</p>
<p>如果被调用的方法将参数指定为ref，调用者调用该方法时提供的实参应该是附加了ref前缀的变量</p>
<p>事实上，ref参数只是传递的变量的别名。换言之，引用参数的作用只是为现有变量分配参数名，而非创建新变量并将实参的值拷贝给它。</p>
<h3 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h3><p>方法经常要获取一个变量引用，并向变量写入而不读取。这时更安全的做法是以传引用的方式传入一个未初始化的局部变量</p>
<ul>
<li><p><code>out</code>参数功能上与ref参数完全一致.唯一区别是C#语言对别名变量的读写有不同的规定。如参数被标记为out，编译器会核实在方法所有正常返回的代码路径中，是否都对该参数进行了赋值</p>
<ul>
<li><p>调用时<code>_</code>放弃</p>
</li>
<li><p>返回两个或更多值应首选元组语法</p>
</li>
</ul>
</li>
</ul>
<h3 id="只读传引用"><a href="#只读传引用" class="headerlink" title="只读传引用"></a>只读传引用</h3><p><code>in</code>以传引用的方式传入只读值类型。该特性以传引用的方式传入值类型参数，并且让该参数不能被方法修改。这样不仅避免了每次调用方法都创建值类型的拷贝，而且不用担心值类型参数被修改</p>
<p>换言之，其作用是在传值时减少拷贝量，同时把它标识为只读，从而增强性能。该语法要为参数添加in修饰符</p>
<h3 id="返回引用"><a href="#返回引用" class="headerlink" title="返回引用"></a>返回引用</h3><p>将变量的引用传递给调用方.</p>
<ul>
<li><code>return ref xxx</code><ul>
<li>返回类型前加ref</li>
<li>变量引用返回值值时,双方前加ref</li>
</ul>
</li>
</ul>
<p>返回引用有两个重要的限制，两者都和对象生存期有关：</p>
<ol>
<li>对象仍被引用时不应被垃圾回收；</li>
<li>对象的所有引用都消失之后，不应再占用内存。</li>
</ol>
<p>为符合这些限制，从方法返回引用时只能返回：</p>
<ul>
<li>对字段或数组元素的引用</li>
<li>其他返回引用的属性或方法</li>
<li>作为参数传给“返回引用的方法”的引用</li>
</ul>
<p>ref局部变量被初始化为引用一个特定变量，以后不能修改为引用其他变量</p>
<ul>
<li>声明引用局部变量的同时必须初始化它。为此需要将方法返回的引用赋给它，或将一个变量引用赋给它</li>
<li>允许声明ref局部变量，但不允许声明ref字段</li>
<li>自动实现的属性不能声明为引用类型</li>
<li>允许返回引用的属性</li>
<li>引用局部变量不能用值（比如null或常量）来初始化.必须将返回引用的成员赋给它，或者将局部变量、字段或数组赋给它</li>
</ul>
<h3 id="参数数组"><a href="#参数数组" class="headerlink" title="参数数组"></a>参数数组</h3><p><code>params 数组参数</code>放在最后.</p>
<ul>
<li><p>参数数组是类型安全的——实参类型必须兼容参数数组的类型</p>
</li>
<li><p>调用者可传递一个实际的数组，而不是传递以逗号分隔的实参列表</p>
</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>事实上，递归通常都是最简单的编码模式，尤其是在和文件系统这样的层次化数据打交道的时候。不过，虽然可读性不错，但一般不是最快的实现。如果必须关注性能，开发者应该为递归实现寻求一种替代方案。至于具体如何选择，通常取决于如何在可读性与性能之间取得平衡。</p>
<blockquote>
<p>栈溢出</p>
</blockquote>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法的唯一性取决于方法名、参数数据类型或参数数量的差异。</p>
<p>方法重载是一种操作性多态</p>
<p>重载就是同名不同参数数据类型或参数数量</p>
<p>假定有两个适用的方法，每个都要求将实参隐式转换成形参的类型，最终选择的是形参类型更具体（派生程度更大）的方法.如果有多个适用的方法，但无法从中挑选出最具唯一性的，编译器就会报错，指明调用存在歧义</p>
<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>方法声明时，在参数列表给参数赋默认值</p>
<blockquote>
<p>要尽量为所有参数提供好的默认值<br>要提供简单的方法重载，必需参数的数量要少<br>考虑从最简单到最复杂的组织重载</p>
</blockquote>
<h3 id="具名参数"><a href="#具名参数" class="headerlink" title="具名参数"></a>具名参数</h3><p>在方法调用时，指定参数赋值<code>age:18</code></p>
<h2 id="基本异常处理"><a href="#基本异常处理" class="headerlink" title="基本异常处理"></a>基本异常处理</h2><ul>
<li><code>try-catch-finally</code></li>
<li><code>throw</code></li>
</ul>
<blockquote>
<p>避免从finally块显式抛出异常（因方法调用而隐式抛出的异常可以接受）<br>要在抛出的异常中描述异常为什么发生。如果可能，顺带说明如何防范更佳<br>要在捕捉并重新抛出异常时使用空的throw语句，以便保留调用栈<br>不要让公共成员将异常作为返回值或者out参数。抛出异常来指明错误，不要把它们作为返回值来指明错误。</p>
</blockquote>
<p>避免使用异常处理来处理预料之中的情况<br><code>TryParse()</code></p>
<blockquote>
<p>不要用异常处理正常的、预期的情况，用它们处理异常的、非预期的情况</p>
</blockquote>
<h3 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h3><p>所有的异常都派生自此类.</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向对象编程中，之前学过的所有结构化的、基于控制流的编程构造仍然适用。但将那些构造封装在类中，可以创建更大、更有条理以及更容易维护的程序。从结构化的、基于控制流程的程序转向面向对象的程序，是因为面向对象编程提供了一个额外的组织层次。结果是较小的程序在某种程度上得到了简化。但更重要的是，现在更容易创建较大的程序，因为程序中的代码得到了更好的组织。</p>
<p>面向对象编程的一个关键优势是不必从头创建新程序，而是可以将现有的一系列对象组装到一起，用新功能扩展类，或添加更多的类</p>
<p>类是面向对象编程的三个主要特征——封装、继承和多态性——的基础。</p>
<ul>
<li><p>封装:1.将方法和数据装入对象 2.在隐藏细节。</p>
<ul>
<li>所有类成员（类的数据和方法）的一个分组，使它们不再需要单独处理</li>
<li>方法封装语句</li>
</ul>
</li>
<li><p>继承:允许在这些相似但又不同的物件之间建立“属于”（is a）关系。类层次结构</p>
<ul>
<li>更具体的类型称为派生类型或子类型。更常规的类型称为基类型或者超类型.子”毕竟不是一种“父”</li>
<li>继承最关键的一点是所有派生类型都继承了基类型的成员</li>
</ul>
</li>
<li><p>多态:一个方法或类型可具有多种形式的实现</p>
<ul>
<li>使不同类型能自己处理一个方法的实现细节，因为多个派生类型都包含了该方法，每个派生类型都共享同一个基类型（或接口），后者也包含了相同的方法签名。</li>
</ul>
</li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>   实现信息封装的基础。类是一种用户定义的引用数据类型，也称类类型。每个类包含数据说明和一组操作数据或传递消息的函数。类的实例称为对象。<br>    ### 类的声明和实例化</p>
<ul>
<li>声明类首先指定关键字class，后跟一个标识符</li>
</ul>
<p>该类的所有代码放到类声明之后的大括号中。虽然并非必须，但一般应该将每个类都放到它自己的文件中，用类名对文件进行命名。这样可以更容易地寻找定义了一个特定类的代码。</p>
<blockquote>
<p>不要在一个源代码文件中放多个类<br>要用所含公共类型的名称命名源代码文件</p>
</blockquote>
<ul>
<li><p>类和对象</p>
<ul>
<li>类是模板，定义了对象在实例化时看起来像什么样子</li>
<li>对象是类的实例</li>
<li>从类创建对象的过程称为实例化</li>
</ul>
</li>
<li><p>实例化:new关键字实例化对象<br>  -要用new操作符指示“运行时”为对象分配内存、初始化对象，并返回对实例的引用</p>
<ul>
<li>对象回收由GC自动完成</li>
</ul>
</li>
</ul>
<h3 id="实例字段"><a href="#实例字段" class="headerlink" title="实例字段"></a>实例字段</h3><p>在类中存储数据的变量称为成员变量,更成为字段，是与包容类型关联的具名存储单元.</p>
<p>实例字段是在类的级别上声明的变量，用于存储与对象（实例）关联的数据。</p>
<h4 id="声明实例字段"><a href="#声明实例字段" class="headerlink" title="声明实例字段"></a>声明实例字段</h4><p>和局部变量声明一样，字段声明包含字段所引用的数据类型。此外，还可在声明的.指示访问等级(默认私有)</p>
<h4 id="访问实例字段"><a href="#访问实例字段" class="headerlink" title="访问实例字段"></a>访问实例字段</h4><p>可设置和获取字段中的数据。注意字段不包含static修饰符，这意味着它是实例字段。</p>
<p>只能从其包容类的实例（对象）中访问实例字段，无法直接从类中访问（换言之，不创建实例就不能访问）。</p>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>必须先获得类的实例才能调用实例成员——无论该实例成员是方法还是字段。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>此关键字可在类的实例成员内部获取对该类的引用</p>
<p>关键字this显式指出当前访问的字段或方法是包容类的实例成员。调用任何实例成员时this都是隐含的，它返回</p>
<blockquote>
<p>this关键字只在必要时才应使用</p>
</blockquote>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>控制封装的访问级别</p>
<ul>
<li><p>public访问不受限制。接口方法默认</p>
</li>
<li><p>private访问限于包含类。类成员默认私有.</p>
</li>
<li><p>protected访问限于包含类或派生自包含类的类型</p>
</li>
<li><p>internal访问限于当前程序集。类默认</p>
</li>
<li><p>protected internal访问限于当前程序集或派生自包含类的类型。</p>
</li>
<li><p>private protected访问限于包含类或当前程序集中派生自包含类的类型</p>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>私有字段,公开属性</li>
</ul>
<p>属性的关键在于，它提供了从编程角度看类似于字段的API。但事实上并不存在这样的字段。</p>
<p>属性声明看起来和字段声明一样，但跟随在属性名之后的是一对大括号，要在其中添加属性的实现。</p>
<p>get和set</p>
<blockquote>
<p>一般原则是方法代表行动，而属性代表数据。属性旨在简化对简单数据的访问(只进行简单计算)。调用属性的成本不应比访问字段高出太多。</p>
</blockquote>
<blockquote>
<p>避免从属性取值方法抛出异常<br>要在属性抛出异常时保留原始属性值<br>如果不需要额外逻辑，要优先使用自动实现的属性，而不是属性加简单支持字段<br>无论私有字段使用哪一种命名方案，属性都要使用PascalCase大小写规范<br>为支持字段附加“_”前缀<br>要使用名词、名词短语或形容词命名属性<br>考虑让某个属性和它的类型同名<br>如果有意义的话，要为Boolean属性附加“Is”“Can”或“Has”前缀<br>要优先使用自动实现的属性而不是字段</p>
</blockquote>
<p>拦截赋值，并通过字段风格的API对参数进行验证，这是属性的优点之一。</p>
<p>一个好的实践是只从属性的实现中访问属性的支持字段。换言之，要一直使用属性，不要直接调用字段</p>
<h4 id="nameof"><a href="#nameof" class="headerlink" title="nameof"></a>nameof</h4><p>属性验证时如判断新赋值无效，就需要抛出ArgumentException()或Argument-NullException()类型的异常。两个异常都获取string类型的实参paramName来标识无效参数的名称</p>
<p>可用nameof操作符来改进。该操作符获取一个标识符（比如value变量）作为参数，返回该名称的字符串形式<code>nameof(value)</code></p>
<p>nameof操作符的优点在于，以后若标识符名称发生改变，重构工具能自动修改nameof的实参</p>
<h4 id="只读和只写属性"><a href="#只读和只写属性" class="headerlink" title="只读和只写属性"></a>只读和只写属性</h4><p>通过移除属性的取值方法或赋值方法，可以改变属性的可访问性。只有赋值方法的属性是只写属性，这种情况较罕见。类似地，只提供取值方法会得到只读属性，任何赋值企图都会造成编译错误。</p>
<h4 id="自动实现的属性"><a href="#自动实现的属性" class="headerlink" title="自动实现的属性"></a>自动实现的属性</h4><p>属性默认值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>[,,] Cells&#123;<span class="hljs-keyword">get</span>;&#125;=<span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如属性值不变，要创建只读自动实现</p>
</blockquote>
<h4 id="属性作为虚字段"><a href="#属性作为虚字段" class="headerlink" title="属性作为虚字段"></a>属性作为虚字段</h4><p>可以看出属性的行为与虚字段相似。有时甚至根本不需要支持字段.相反，可让属性的取值方法返回计算好的值，而让赋值方法解析值，并将值持久存储到其他成员字段中。</p>
<h4 id="属性和方法调用不允许作为ref或out参数值"><a href="#属性和方法调用不允许作为ref或out参数值" class="headerlink" title="属性和方法调用不允许作为ref或out参数值"></a>属性和方法调用不允许作为ref或out参数值</h4><p>C#允许属性像字段那样使用，只是不允许作为ref或out参数值传递。ref和out参数内部要将内存地址传给目标方法。但由于属性可能是无支持字段的虚字段，也有可能只读或只写，所以不可能传递存储地址。同样的道理也适用于方法调用。如需将属性或方法调用作为ref或out参数值传递，首先必须将值拷贝到变量再传递该变量。方法调用结束后，再将变量的值赋回属性。</p>
<h4 id="属性的内部工作原理"><a href="#属性的内部工作原理" class="headerlink" title="属性的内部工作原理"></a>属性的内部工作原理</h4><p>除了外观与普通方法无异，注意属性在CIL中也是一种显式的构造.因此，语言和编译器并非总是依据一个惯例来解释属性。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>数据的有效性,即使忘了初始化，有构造函数来警告</p>
<h4 id="声明构造函数"><a href="#声明构造函数" class="headerlink" title="声明构造函数"></a>声明构造函数</h4><p>声明构造函数需创建一个无返回类型的方法，方法名必须和类名完全一样。构造函数是“运行时”用来初始化对象实例的方法。</p>
<p>构造函数会覆盖声明字段&#x2F;属性的初始值</p>
<blockquote>
<p>new操作符的实现细节<br>new操作符内部和构造函数是像下面这样交互的。new操作符从内存管理器获取“空白”内存，调用指定构造函数，将对“空白”内存的引用作为隐式的this参数传给构造函数。构造函数链剩余的部分开始执行，在构造函数之间传递引用。这些构造函数都没有返回类型（行为都像是返回void）。构造函数链上的执行结束后，new操作符返回内存引用。现在，该引用指向的内存处于完成初始化的形式。</p>
</blockquote>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>如果类没有显式定义的构造函数，C#编译器会在编译时自动添加一个。该构造函数不获取参数，称为默认构造函数<br>一旦为类显式添加了构造函数，C#编译器就不再自动提供默认构造函数。</p>
<blockquote>
<p>没必要依赖编译器提供的默认构造函数。程序员任何时候都可显式定义默认构造函</p>
</blockquote>
<h4 id="对象初始化器"><a href="#对象初始化器" class="headerlink" title="对象初始化器"></a>对象初始化器</h4><p><code>&#123;&#125;</code>可访问字段和属性进行赋值</p>
<p>这实际只是一种语法糖，最终生成的CIL代码和创建对象实例后单独用语句对字段及属性进行赋值无异.<br>代码中的成员初始化顺序决定了在CIL中调用构造函数后的属性和字段赋值顺序</p>
<blockquote>
<p>要为所有属性提供有意义的默认值，确保默认值不会造成安全漏洞或造成代码执行效率大幅下降<br>要允许属性以任意顺序设置，即使这会造成对象暂时处于无效状态</p>
</blockquote>
<ul>
<li><p>集合初始化器<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668847210926.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>终结器:终结器是在对象被判定“不可到达”之后的不确定时间内执行</p>
</li>
</ul>
<h4 id="重载构造函数"><a href="#重载构造函数" class="headerlink" title="重载构造函数"></a>重载构造函数</h4><blockquote>
<p>如果构造函数的参数只是用于设置属性，那么构造函数参数（camelCase）要使用和属性（PascalCase）相同的名称，区别仅仅是首字母的大小写<br>要为构造函数提供可选参数，并且提供便利的重载构造函数，用好的默认值初始化属性<br>要允许以任何顺序设置属性，即使这会导致暂时无效的对象状态</p>
</blockquote>
<h4 id="构造函数链"><a href="#构造函数链" class="headerlink" title="构造函数链"></a>构造函数链</h4><p>使用this调用另一个构造函数</p>
<blockquote>
<p>可设计个<code>Initialize()</code>集中初始化.获取全部的属性并赋值</p>
</blockquote>
<h3 id="不可空引用类型属性与构造函数"><a href="#不可空引用类型属性与构造函数" class="headerlink" title="不可空引用类型属性与构造函数"></a>不可空引用类型属性与构造函数</h3><p>在一个类中，如果定义了不可空引用类型的字段或者默认实现的属性，则在其宿主类完成实例化之前，这些字段和属性的值需要先被初始化，否则，它们只能拥有默认的null值，而这显然与“不可空”相悖。<br>有时候这类字段和属性可能已经被间接地初始化了，超出了构造函数的直接作用域，因此超出了编译器代码分析的作用域，即便通过构造函数调用的方法或属性能够初始化也是如此</p>
<p>在大部分情况下，不可空引用型字段和自动实现的不可空属性的初始化，都通过构造函数调用属性或方法间接完成。遗憾的是，C#编译器无法识别对不可空引用型字段或属性的间接赋值，即便该间接赋值发生在构造函数里</p>
<h4 id="可读写的引用型不可空属性"><a href="#可读写的引用型不可空属性" class="headerlink" title="可读写的引用型不可空属性"></a>可读写的引用型不可空属性</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>	<span class="hljs-built_in">string</span>? _name;<br>	<span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>	&#123;<br>		<span class="hljs-keyword">get</span> =&gt; _name!;<br>		<span class="hljs-keyword">set</span> =&gt; _name =<br>			<span class="hljs-keyword">value</span> ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(<span class="hljs-keyword">value</span>));<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>	&#123;<br>Name=name;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>既使用可读写的引用型不可空属性，又避免产生不可空属性未初始化的编译器警告。这样做的最终效果是在编译器看来该属性&#x2F;字段为可空（因此不会产生警告），而在调用者看来该属性&#x2F;字段不允许被设置为空。</p>
<p>虽然将不应该为空的字段声明为可空看起来不太正确，但是由于编译器无法识别对不可空字段的间接赋值，因此有时确实需要这样做。好在程序员可以通过字段的私有性，以及精细设</p>
<h4 id="自动实现的只读引用型属性"><a href="#自动实现的只读引用型属性" class="headerlink" title="自动实现的只读引用型属性"></a>自动实现的只读引用型属性</h4><p>如果一个不可空的引用型字段有自动实现的属性，则该属性应该为只读，从而避免该字段被意外设置为null值。但是即便做到了这一点，在构造函数里为该字段进行赋值时，仍然需要检查null值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;	<br>	<span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>	&#123;<br>		<span class="hljs-keyword">get</span>;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>	&#123;<br>		Name =name?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(<span class="hljs-keyword">value</span>));<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>当类的不可空引用型字段需要对应的属性时，要将该字段声明为可空，并且要编写完整实现的属性方法，而不要采用自动实现的方式。在赋值方法中要做好null值检查，在取值方法中要使用空包容操作符。<br>不可空的引用型字段要在构造函数内完成赋值<br>如果一定要为不可空的引用型字段使用自动实现的属性，要将属性声明为只读<br>在操作任何引用型字段或属性时，都要检查null值</p>
</blockquote>
<h3 id="可空特性"><a href="#可空特性" class="headerlink" title="可空特性"></a>可空特性</h3><p>明确告诉编译器你需要处理空值，并需要为此添加一些防护措施，比笼统地关闭空值功能或者关闭空值警告更有意义<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668861767573.png" srcset="/img/loading.gif" lazyload><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668861810817.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>可空泛型<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668861898144.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h3 id="解构函数"><a href="#解构函数" class="headerlink" title="解构函数"></a>解构函数</h3><p>把一个对象封装好的项拆分为它的各个组成部分。</p>
<ul>
<li>方法名必须是Deconstruct，其签名是返回void并接收两个或更多out参数</li>
</ul>
<p>和元组配合更优雅<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668862193683.png" srcset="/img/loading.gif" lazyload><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668862160314.png" srcset="/img/loading.gif" lazyload><br>也可将对象实例赋给元祖，隐式调用Deconstruct()，和out参数匹配</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">(_,firstName,lastName,salary)=employee;<br></code></pre></td></tr></table></figure>

<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p><code>static</code></p>
<h4 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h4><p>使用static关键字定义能由多个实例共享的数据</p>
<p>和实例字段（非静态字段）一样，静态字段也可在声明时初始化<br>和实例字段不同，未初始化的静态字段将获得默认值</p>
<p>每创建一个对象实例，非静态字段（实例字段）都要占用一个新的存储位置。静态字段从属于类而非实例。因此，我们使用类名从类外部访问静态字段。</p>
<blockquote>
<p>设计对象时，程序员要考虑字段和方法应声明为静态还是基于实例。一般应将不需要访问任何实例数据的方法声明为静态方法，将需要访问实例数据的方法（实例不作为参数传递）声明为实例方法。静态字段主要存储对应于类的数据，比如新实例的默认值或者已创建实例的个数。而实例字段主要存储和对象关联的数据。</p>
</blockquote>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>和静态字段一样，直接在类名后访问静态方法</p>
<h4 id="静态构造方法"><a href="#静态构造方法" class="headerlink" title="静态构造方法"></a>静态构造方法</h4><p>“运行时”在首次访问类时自动调用静态构造函数。“首次访问类”可能发生在调用普通构造函数时，也可能发生在访问类的静态方法或字段时。由于静态构造函数不能显式调用，所以不允许任何参数。</p>
<p>静态构造函数的作用是将类中的静态数据初始化成特定值，尤其是在无法通过声明时的一次简单赋值来获得初始值的时候</p>
<blockquote>
<p>最好在声明时进行静态初始化（而不要使用静态构造函数）</p>
</blockquote>
<h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><p>使用静态属性几乎肯定比使用公共静态字段好，因为公共静态字段在任何地方都能调用，而静态属性至少提供了一定程度的封装。</p>
<h4 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h4><p>该类不包含任何实例字段（或方法），创建能实例化的类没有意义</p>
<ol>
<li>它防止程序员写代码来实例化SimpleMath类。</li>
<li>防止在类的内部声明任何实例字段或方法</li>
<li>不可扩展</li>
</ol>
<h4 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h4><p>能模拟为其他类创建实例方法。</p>
<p>只需更改静态方法的签名，使第一个参数成为要扩展的类型，并在类型名称前附加this关键字</p>
<p>查看CIL代码，会发现扩展方法是作为普通静态方法调用的。</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668863172652.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>避免随便定义扩展方法，尤其是不要为自己无所有权的类型定义。</p>
</blockquote>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>const字段（称为常量字段）包含在编译时确定的值，运行时不可修改。</p>
<ul>
<li><p>自动成为静态字段.</p>
<ul>
<li><p>但将常量字段显式声明为static会造成编译错误</p>
</li>
<li><p>常量字段通常只声明为有字面值的类型</p>
<blockquote>
<p>要为永远不变的值使用常量字段<br>避免为将来会发生变化的值使用常量字段</p>
</blockquote>
</li>
</ul>
</li>
<li><p>public常量应该是恒定值.将来可能更改的值应该指定为readonly</p>
</li>
</ul>
<h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>readonly修饰符只能用于字段（不能用于局部变量），它指出字段值只能从构造函数中更改，或在声明时通过初始化器指定。</p>
<p>由于readonly字段必须通过构造函数或初始化器来设置，所以编译器要求这种字段能从其属性外部访问。但除此之外，不要从属性外部访问属性的支持字段</p>
<blockquote>
<p>一般都是不用readonly字段，而是设为只读(无set)属性.<br>要优先选择只读自动实现的属性而不是只读字段</p>
</blockquote>
<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>假如一个类在它的包容类外部没有多大意义，就适合设计成嵌套类。</p>
<p>嵌套类的独特之处是可以为类自身指定private访问修饰符。.使用private访问修饰符可限定类的作用域，防止从类的外部访问。只有嵌套类才能这样做。</p>
<p>嵌套类另一个有趣的地方在于它能访问包容类的任何成员，其中包括私有成员。反之则不然，包容类不能访问嵌套类的私有成员。</p>
<blockquote>
<p>避免声明公共嵌套类型。少数高级自定义场景才需考虑</p>
</blockquote>
<h3 id="分部类"><a href="#分部类" class="headerlink" title="分部类"></a>分部类</h3><p>分部类是一个类的多个部分，编译器可把它们合并成一个完整的类。</p>
<ul>
<li><code>partial</code><br>除了用于代码生成器，分部类另一个常见的应用是将每个嵌套类都放到它们自己的文件中。</li>
</ul>
<h3 id="分部方法"><a href="#分部方法" class="headerlink" title="分部方法"></a>分部方法</h3><p>分部方法只能存在于分部类中，而且和分部类相似，主要作用是为代码生成提供方便。</p>
<p>分部方法允许声明方法而不需要实现。但如果包含了可选的实现，该实现就可放到某个姊妹分部类定义中，该定义可能在单独的文件中。</p>
<p>分部方法必须返回void。</p>
<p>分部方法使生成的代码能调用并非一定要实现的方法。此外，如果没有为分部方法提供实现，CIL中不会出现分部方法的任何踪迹。这样在保持代码规模尽量小的同时，还保证了高的灵活性。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>利用类的继承关系建立类层次结构。</p>
<p>单继承</p>
<h3 id="派生"><a href="#派生" class="headerlink" title="派生"></a>派生</h3><p>经常需要扩展现有类型来添加功能（行为和数据）。继承正是为了该目的而设计的。</p>
<p>所有类都隐式派生自object。</p>
<h4 id="转型"><a href="#转型" class="headerlink" title="转型"></a>转型</h4><ul>
<li><p>可以将派生类型的值直接赋给基类型的变量。隐式转型</p>
</li>
<li><p>类型转换为派生类型要求执行显式转型，而显式转型在运行时可能失败。</p>
</li>
<li><p>自定义转换: <code>public态 implicit operator 目标类(本类)&#123;&#125;</code></p>
<ul>
<li>将implicit替换成explicit就是显式转换</li>
</ul>
</li>
</ul>
<h4 id="private访问修饰符"><a href="#private访问修饰符" class="headerlink" title="private访问修饰符"></a>private访问修饰符</h4><p>派生类继承除构造函数和析构器之外的所有基类成员。但继承并不意味着一定能访问。</p>
<p>根据封装原则，派生类不能访问基类的private成员</p>
<h4 id="protected访问修饰符"><a href="#protected访问修饰符" class="headerlink" title="protected访问修饰符"></a>protected访问修饰符</h4><p>可在基类中定义只有派生类才能访问的成员</p>
<p>基类的受保护成员只能从基类及其派生链的其他类中访问。</p>
<h4 id="扩展方法-1"><a href="#扩展方法-1" class="headerlink" title="扩展方法"></a>扩展方法</h4><p>扩展方法从技术上说不是类型的成员，所以不可继承。但因为每个派生类都可作为它的任何基类的实例使用，所以对一个类型进行扩展的方法也可扩展它的任何派生类型。</p>
<p>但和所有扩展方法一样，实例方法有更高的优先级。如果继承链中出现一个兼容的签名，那么它将优先于扩展方法。</p>
<h3 id="重写基类"><a href="#重写基类" class="headerlink" title="重写基类"></a>重写基类</h3><p>基类除构造函数和析构器之外的所有成员都会在派生类中继承。但某些情况下，一个成员可能在基类中没有得到最佳的实现。<br>因此，需要一种机制在派生类中使用自定义的实现来重写（override，覆盖或覆写）基类中的实现</p>
<h4 id="virtaul修饰符"><a href="#virtaul修饰符" class="headerlink" title="virtaul修饰符"></a>virtaul修饰符</h4><p>支持重写实例方法和属性，但不支持字段和任何静态成员的重写。</p>
<ul>
<li><p><code>override</code>进行重写。</p>
</li>
<li><p>基类调用时调用实例的方法.</p>
</li>
</ul>
<blockquote>
<p>用override修饰的任何方法自动为虚。只有基类的虚方法才能重写，所以重写后的方法还是虚方法。</p>
</blockquote>
<h4 id="new修饰符"><a href="#new修饰符" class="headerlink" title="new修饰符"></a>new修饰符</h4><p>如果重写方法没有使用override关键字，编译器会生成警告消息，可使用new修饰符.</p>
<p>它在基类面前隐藏了派生类重新声明的成员。搜索继承链，找到使用new修饰符的那个成员之前的、派生得最远的成员，然后调用该成员。如继承链仅包含两个类，就使用基类的成员，就像是派生类没有声明那个成员（如派生的实现重写了基类成员）。</p>
<h3 id="sealed修饰符"><a href="#sealed修饰符" class="headerlink" title="sealed修饰符"></a>sealed修饰符</h3><p>禁止子类重写基类的虚成员</p>
<blockquote>
<p>除非有很好的理由，一般很少将整个类标记为密封。事实上，人们越来越倾向于将类设置成非密封类，因为单元测试需要创建仿制对象来代替真正的实现。有时对单独虚成员进行密封的代价过高，还不如将整个类密封。但一般都倾向于对单独成员进行有针对性的密封（例如，可能需要依赖基类的实现来获得正确的行为）。<br>string类型就是用sealed修饰符禁止派生的例子。</p>
</blockquote>
<h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><p>调用其基类版本的成员(包括构造方法)</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><code>abstract</code><br>抽象类是仅供派生的类，无法实例化抽象类，只能实例化从它派生的类。不抽象、可直接实例化的类称为具体类。</p>
<blockquote>
<p>接口（interface）已经实现了抽象类所拥有的全部功能，甚至还有更多新特性。</p>
</blockquote>
<p>抽象类代表抽象实体。其抽象成员定义了从抽象实体派生的对象应包含什么，但这种成员不包含实现。抽象类的大多数功能通常都没有实现。一个类要从抽象类成功地派生，必须为抽象基类中的抽象方法提供具体的实现。</p>
<p>抽象类的主要特点在于它包含抽象成员。抽象成员是没有实现的方法或属性，作用是强制所有派生类提供实现。</p>
<p>抽象成员不能声明为私有，否则派生类看不见它们。</p>
<ul>
<li>抽象成员必须被重写，所以自动为虚，但不能用virtual关键字显式声明。</li>
</ul>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><ul>
<li>同一个签名可以有多个实现。<ul>
<li>一个签名不能在一个类中多次使用，所以该签名的每个实现必然包含在不同类中。</li>
<li>只有对象自己才知道如何最好地执行特定操作，通过规定调用这些操作的通用方式，多态性还促进了代码重用，因为通用的东西不必重复编码。</li>
</ul>
</li>
</ul>
<h3 id="所有类都从System-Object派生"><a href="#所有类都从System-Object派生" class="headerlink" title="所有类都从System.Object派生"></a>所有类都从System.Object派生</h3><p>所有类都直接或间接从object派生。</p>
<p>即使字面值也支持object的方法</p>
<h3 id="使用is进行模式匹配"><a href="#使用is进行模式匹配" class="headerlink" title="使用is进行模式匹配"></a>使用is进行模式匹配</h3><p>C#用is操作符判断基础类型</p>
<p>is操作符除了用于类型检查，也可以用于声明变量并且赋值。</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668868466779.png" srcset="/img/loading.gif" lazyload><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668868502811.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="元组模式匹配"><a href="#元组模式匹配" class="headerlink" title="元组模式匹配"></a>元组模式匹配</h4><p>可以将一批常量放在一个元组中，并使用is操作符进行元组模式匹配，并且也可以对元组中的变量进行类型模式匹配和赋值。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668868608466.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="顺序模式匹配"><a href="#顺序模式匹配" class="headerlink" title="顺序模式匹配"></a>顺序模式匹配</h4><p>由于解构函数可以隐含的构造一个元组实例，因此一个具有解构函数的类可以完美匹配元组模式匹配的语法。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668868691124.png" srcset="/img/loading.gif" lazyload><br>在顺序模式匹配中，也可以匹配常量</p>
<h4 id="属性模式匹配"><a href="#属性模式匹配" class="headerlink" title="属性模式匹配"></a>属性模式匹配</h4><p>允许在对一个对象进行模式匹配时，不仅指定属性值，而且指定属性名称。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668868739604.png" srcset="/img/loading.gif" lazyload><br>顺序不重要</p>
<h4 id="递归模式匹配"><a href="#递归模式匹配" class="headerlink" title="递归模式匹配"></a>递归模式匹配</h4><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668869367636.png" srcset="/img/loading.gif" lazyload><br>is操作符的属性模式匹配的优势在于其可以用属性名来直接选取希望匹配的元素或字段</p>
<p>is操作符的属性模式匹配不支持判定性表达式</p>
<blockquote>
<p>读性也差</p>
</blockquote>
<h4 id="switch中的匹配模式"><a href="#switch中的匹配模式" class="headerlink" title="switch中的匹配模式"></a>switch中的匹配模式</h4><p>可读性更高的if<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668926790555.png" srcset="/img/loading.gif" lazyload><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668926805959.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="when"><a href="#when" class="headerlink" title="when"></a>when</h5><p>将时间进一步限定为将来某时刻。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668926871291.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>避免对多态类对象使用模式匹配</p>
</blockquote>
<ul>
<li>使用as操作符进行转换，避免了可能因为转型而造成的异常</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口实现关系是一种“能做”（can do）关系的引用类型：类型“能做”接口所规定的事情。</p>
<p>遵循的条款</p>
<p>能完全隔离实现细节和提供的服务.</p>
<p>接口声明的成员描述了在实现该接口的类型中必须能访问的成员。而所有非公共成员的目的都是阻止其他代码访问成员。所以，C#不允许为接口成员使用访问修饰符。所有成员都自动公共。</p>
<p>接口为多态性而生</p>
<h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><p>类可实现多个接口，但只能从一个基类直接派生</p>
<p>实现接口时，接口的所有抽象成员都必须实现。</p>
<p>在抽象类中可将接口方法映射成自己的抽象方法，将真正的实现留给子类去完成。也可拿掉abstract关键字并添加方法主体。</p>
<p>接口的重点在于永远不能实例化，即不能用new创建接口。因此接口没有构造函数或终结器。只有实例化实现了接口的类型，才能使用接口实例。</p>
<h3 id="显式成员实现"><a href="#显式成员实现" class="headerlink" title="显式成员实现"></a>显式成员实现</h3><p>显式实现的方法只能通过接口本身调用，最典型的做法是将对象转型为接口</p>
<p>在接口成员名称前附加接口名称前缀来显式实现接口成员<code>接口名.</code>。</p>
<p>由于显式接口实现直接和接口关联，所以没必要使用virtual、override或者public来修饰它们。事实上，这些修饰符是不被允许的。这些成员不被视为类的公共成员，标注public有误导之嫌。</p>
<blockquote>
<p>注意，在派生类中实现接口方法时，不允许使用override（重写）关键字。不过，在派生类中实现接口方法时，我们仍然会称之为“重写”。</p>
</blockquote>
<h3 id="隐式成员实现"><a href="#隐式成员实现" class="headerlink" title="隐式成员实现"></a>隐式成员实现</h3><p>要隐式实现成员，只要求成员是公共的，且签名与接口成员签名相符。</p>
<p>显式实现不允许的许多修饰符对于隐式实现都是必须或可选的</p>
<blockquote>
<p>类层次结构是建立在属于(is a)关系上，这些是“语义”（semantic）关系。<br>接口与语义无关，只在实现”机制”关系的细节。不属于”可比较”的机制,但仍可实现IComparable接口<br>显式接口实现的目的就是将机制问题和模型问题分开.要求调用者先将对象转换为接口（比如IComparable），然后才能认为对象“可比较”，从而显式区分你想在什么时候和模型沟通，以及在什么时候处理实现机制。</p>
</blockquote>
<blockquote>
<p>可通过回答以下问题来决定显式还是隐式实现：</p>
</blockquote>
<ol>
<li>成员是不是核心的类功能？</li>
<li>接口成员名称作为类成员名称是否恰当？避免歧义，方法名的功能不能显而易见</li>
<li>是否已经有相同签名的类成员？<br>因此较稳妥的做法是全部显式实现接口成员，使它们以后能安全地变成隐式。</li>
</ol>
<h3 id="接口和实现类的转换"><a href="#接口和实现类的转换" class="headerlink" title="接口和实现类的转换"></a>接口和实现类的转换</h3><p>实现类向接口隐式；<br>接口向实现类显式。</p>
<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>一个接口可以从另一个接口派生，派生的接口将继承“基接口”的所有成员。</p>
<p>显式实现接口成员时，必须在完全限定的接口成员名称中引用最初声明它的接口的名称。</p>
<p>最后要说的是，虽然“继承”这个词用得没错，但更准确的说法是接口代表契约，一份契约可指定另一份契约也必须”遵守”的条款。</p>
<h3 id="接口上的扩展方法"><a href="#接口上的扩展方法" class="headerlink" title="接口上的扩展方法"></a>接口上的扩展方法</h3><p>扩展方法的一个重要特点是除了能作用于类，还能作用于接口。所使用的语法和用于类时的语法一样。</p>
<h3 id="版本升级"><a href="#版本升级" class="headerlink" title="版本升级"></a>版本升级</h3><p>和类不同，在接口中添加成员也可能造成代码无法编译——除非进行额外的修改。问题在于，实现接口的任何类都必须完整地实现，必须提供针对所有成员的实现。添加新接口成员后，编译器会要求开发者在实现接口的类中添加新的接口成员。</p>
<p>C# 8.0允许在接口中为方法提供默认实现。这样一来，虽然仍然不可以在已经发布的接口中修改或删除现有的方法，但是可以添加新方法，并通过提供默认实现，来避免破坏基于该接口开发的现有程序。</p>
<blockquote>
<p>不要为已发布的接口添加成员，除非提供默认实现。</p>
</blockquote>
<h4 id="默认接口方法"><a href="#默认接口方法" class="headerlink" title="默认接口方法"></a>默认接口方法</h4><p>许为现有接口增加新方法时，同时提供默认实现代码</p>
<p>没有影响之前的多态性</p>
<h4 id="接口其他新特性"><a href="#接口其他新特性" class="headerlink" title="接口其他新特性"></a>接口其他新特性</h4><p>可声明</p>
<ul>
<li>静态成员:字段，构造函数，方法，甚至包括Main方法</li>
<li>实例属性和方法:不支持实例字段所以没有自动实现<ul>
<li>访问默认接口属性或方法，必须将变量转换为接口</li>
</ul>
</li>
<li>public修饰符，更清晰</li>
<li>protected修饰符</li>
<li>private修饰符。接口成员为私有时(如果是方法需要有默认实现)只能从默认方法访问</li>
<li>internal</li>
<li>protected internal</li>
<li>private protected</li>
<li>virtual修饰符，更清晰</li>
<li>sealed修饰符,方法不可被重写</li>
<li>abstract修饰符，只能用于没有默认实现的接口方法，能用但是没啥用</li>
<li>partial接口和方法。方法均自动私有访问</li>
</ul>
<ol>
<li>如果希望提供属性存取方法的默认接口实现，则不可以使用编译器自动实现。这是因为接口中不允许声明实例字段（非静态字段），因此编译器无法找到对应的字段来自动实现属性存取方法。</li>
<li>请注意静态成员和实例成员（非静态成员）的默认访问权限不同。静态成员默认为私有访问，而实例成员则默认为公共访问，这是因为接口中的静态方法必须有默认实现，而静态字段也有相应的实体，这样它们就与普通类中的静态方法和字段非常接近。而类中的静态成员就默认为私有访问，因此接口中的静态成员在访问权限上也与类保持一致。与之对应，接口实例成员（方法和属性）的主要用途是为了实现多态，因此其默认访问权限也要尽量接近C# 8.0之前的一贯风格。</li>
</ol>
<h3 id="扩展方法与默认接口成员"><a href="#扩展方法与默认接口成员" class="headerlink" title="扩展方法与默认接口成员"></a>扩展方法与默认接口成员</h3><ul>
<li>这些方法都可以实现基于相同方法签名的重写</li>
<li>扩展方法可以在任何程序集里面实现，并不局限于接口所在的程序集。</li>
<li>虽然允许为属性的存取添加默认接口方法，但由于接口中不允许添加实例字段，因此如果属性的存取方法需要实现复杂一些的计算，则无法在默认接口方法中实现</li>
<li>也可以利用扩展方法为字段实现类似于属性的“存取方法”（如GetData()），以便在其中实现复杂一些的计算。这样就不必局限于C# 8.0和.NET Core 3.0框架了。</li>
<li>从旧接口派生出新接口，便可以在其中自由地添加新功能。这样既不用担心向上兼容问题，也不用局限于新版本的C#和.NET框架。</li>
<li>派生出新接口的方法需要通过修改实现类来实现新接口。</li>
<li>默认接口方法需要通过该接口来调用，而不能通过接口的实现类的实例来调用。即便在接口的实现类中，若要调用默认接口方法，也必须通过接口来调用。</li>
<li>接口中的protected成员只能被当前接口及其派生接口访问，实现类并不能访问这种成员。</li>
<li>默认接口方法可以被实现类重写，这使得不同的实现类可以为特定方法提供不同的实现。然而扩展方法不能够被类重写，对它的调用在编译时就已经确定了。</li>
</ul>
<p>总之，当要添加新的属性方法时，如果需要支持比C# 8.0和.NET Core 3.0更早期的框架，则派生新接口是唯一选择，否则可以考虑利用默认接口方法来添加新属性。而如果只是要添加新方法而不是属性，则也可以考虑扩展方法。</p>
<blockquote>
<p>若需对已经发布的接口添加新方法，优先考虑扩展方法或者派生新接口<br>如果无法控制接口所允许的多态性，则采用扩展方法更加稳妥<br>如果要添加新的属性方法，而且既要支持多态性，又要支持早期C#和.NET，则只能派生新接口。</p>
</blockquote>
<h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>接口引入了另一个类别的数据类型（是少数不扩展System.Object的类型之一）<br>    - 此外还有指针类型和类型参数类型。但每个接口类型都可转换为System.Object，并允许在接口的任何实例上调用System.Object的方法，所以这个区别或许有点儿吹毛求疵。</p>
<p>C# 8.0的接口几乎成为抽象类的功能超集。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668931300122.png" srcset="/img/loading.gif" lazyload></p>
<p>接口更多的是在系统架构设计方面发挥作用，主要用于定义模块之间的通信契约。<br>抽象类在代码实现方面发挥作用，可以实现代码的重用.如权限判断、访问日志</p>
<blockquote>
<p>如果一个类已经有父类，若要再为它添加父类，考虑定义接口</p>
</blockquote>
<h3 id="接口和特性"><a href="#接口和特性" class="headerlink" title="接口和特性"></a>接口和特性</h3><p>有时用无任何成员的接口（不管是不是继承的）来描述关于类型的信息。例如，有人会创建名为IObsolete的标记接口（marker interface）指出某类型已被另一类型取代。</p>
<p>一般认为这是对接口机制的“滥用”：接口应表示类型能执行的功能，而非陈述关于类型的事实。所以这时不要使用标记接口，改为使用特性</p>
<blockquote>
<p>避免使用无成员的标记接口，改为使用特性</p>
</blockquote>
<h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><blockquote>
<p>避免创建消耗内存大于16字节的值类型</p>
</blockquote>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><code>struct</code><br>除string和object是引用类型，其他所有C#内建类型（比如bool和int）都是值类型。</p>
<p>可<code>readonly</code>本身和成员</p>
<blockquote>
<p>要创建不可变的值类型（元组例外）</p>
</blockquote>
<h4 id="初始化结构"><a href="#初始化结构" class="headerlink" title="初始化结构"></a>初始化结构</h4><p>除了属性和字段，结构还可包含方法和构造函数，但不可包含用户自定义的默认（无参）构造函数。<br>相反，C#编译器自动生成默认构造函数将所有字段初始化为默认值。</p>
<p>结构中的每个构造函数都必须初始化结构的所有字段（和只读自动实现属性）</p>
<p>如果不用new操作符来调用构造函数从而显式实例化结构，结构中的所有数据都隐式初始化为对应数据类型的默认值。<br>为满足结构初始化要求，所有显式声明的字段都必须初始化。这种初始化必须直接进行。</p>
<ul>
<li>在结构声明中初始化字段会报错，需要在构造函数中初始化</li>
</ul>
<blockquote>
<p>要确保结构的默认值有效。封装并不能阻止访问默认的“全零”值。</p>
</blockquote>
<ul>
<li>为引用类型使用new操作符，“运行时”会在托管堆上创建对象的新实例，将所有字段初始化为默认值，再调用构造函数，将对实例的引用以this的形式传递。new操作符最后返回对实例的引用，该引用被拷贝到和变量关联的内存位置。</li>
<li>为值类型使用new操作符，“运行时”会在临时存储池中创建对象的新实例，将所有字段初始化为默认值，调用构造函数，将临时存储位置作为ref变量以this的形式传递。结果是值被存储到临时存储位置，然后可将该值拷贝到和变量关联的内存位置。</li>
</ul>
<h4 id="继承和接口"><a href="#继承和接口" class="headerlink" title="继承和接口"></a>继承和接口</h4><p>所有值类型都隐式密封。派生自System.ValueType</p>
<p>值类型也能实现接口。</p>
<blockquote>
<p>如需比较相等性，要在值类型上重写相等性操作符（Equals()，&#x3D;&#x3D;和!&#x3D;）并考虑实现IEquatable<T>接口。</p>
</blockquote>
<h3 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h3><p>值类型的变量（直接引用其数据）转换为引用类型（引用堆上的一个位置）</p>
<p>对一个存储位置的引用。该位置表面上包含引用类型的实例，但实际包含值类型的值。这种转换称为装箱</p>
<ol>
<li>堆上分配内存.它将用于存放值类型的数据以及少许额外开销（SyncBlockIndex和方法表指针）</li>
<li>拷贝内存数据</li>
<li>转换结果是对堆上的新存储位置的引用</li>
</ol>
<p>相反的过程称为拆箱（unboxing）。具体是核实已装箱值的类型兼容于要拆箱成的值的类型，再拷贝堆中存储的值，结果是堆上存储的值的拷贝。</p>
<blockquote>
<p>装箱和拆箱都影响性能和行为,频繁需避免</p>
</blockquote>
<ul>
<li>lock语句中的值类型<br>值类型的问题在于装箱，所以每次调用Enter()或Exit()都会在堆上创建新值。将一个拷贝的引用同另一个拷贝的引用比较总是返回false。所以，无法将Enter()与对应的Exit()钩到一起。因此，不允许在lock()语句中使用值类型。</li>
</ul>
<blockquote>
<p>避免可变值类型.因为往往修改的是值的拷贝，而不是真正想要修改的存储位置。</p>
</blockquote>
<ul>
<li>方法调用上避免装箱:<br>任何时候在值类型上调用方法，接收调用的值类型（在方法主体中用this表示）必须是变量而不是值，因为方法可能尝试修改接收者。显然，它必须修改接收者的存储位置，而不是修改接收者的值的拷贝再丢弃该拷贝。</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><code>enum</code><br>关键特征是在编译时声明了一组具名常量值，这使代码更易读。</p>
<p>枚举值实际作为整数常量实现。默认第一个枚举值是0，后续每一项都递增1。但可以显式地为枚举赋值</p>
<p>枚举总是具有一个基础类型，可以是除char之外的任意整型。</p>
<p>枚举不过是基础类型上的一组名称，对于枚举类型的变量，它的值并不限于声明中命名的值。优点在于可在未来的API版本中为枚举添加新值，同时不会破坏早期版本。</p>
<blockquote>
<p>考虑在现有枚举中添加新成员，但要注意兼容性风险。<br>避免创建代表“不完整”值（如版本号）集合的枚举。<br>避免在枚举中创建“保留给将来使用”的值。<br>避免包含单个值的枚举。<br>要为简单枚举提供值0来代表无。注意若不显式初始化，0就是默认值。</p>
</blockquote>
<h4 id="枚举之间的类型兼容性"><a href="#枚举之间的类型兼容性" class="headerlink" title="枚举之间的类型兼容性"></a>枚举之间的类型兼容性</h4><p>C#不支持不同枚举数组之间的直接转型。但CLR允许，前提是两个枚举具有相同的基础类型。为避开C#的限制，技巧是先转型为System.Array</p>
<p>慎用</p>
<h4 id="在枚举和字符串之间转换"><a href="#在枚举和字符串之间转换" class="headerlink" title="在枚举和字符串之间转换"></a>在枚举和字符串之间转换</h4><p>枚举的一个好处是ToString()方法（通过System.Console.WriteLine()这样的方法来调用）会输出枚举值标识符</p>
<p>使用<code>Enum.TryParse&lt;T&gt;()</code>将字符串转换成枚举</p>
<h4 id="枚举作为标志使用"><a href="#枚举作为标志使用" class="headerlink" title="枚举作为标志使用"></a>枚举作为标志使用</h4><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668940984249.png" srcset="/img/loading.gif" lazyload><br>然后使用<code>&amp; | ! ^</code>等位操作</p>
<blockquote>
<p>要用FlagsAttribute标记包含标志的枚举<br>要为所有标志枚举提供等于0的None值<br>避免将标志枚举中的零值设定为“所有标志都未设置”之外的其他意思。<br>考虑为常用标志组合提供特殊值<br>不要包含“哨兵”值（如Maximum），这种值会使用户困惑<br>要用2的乘方确保所有标志组合都不重复。</p>
</blockquote>
<ul>
<li>FlagsAttribute<br>如决定使用位标志枚举，枚举的声明应该用FlagsAttribute来标记。该特性应包含在一对方括号中，并放在枚举声明之前<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668941268855.png" srcset="/img/loading.gif" lazyload>该特性指出枚举值可以组合。</li>
</ul>
<h2 id="合式类型"><a href="#合式类型" class="headerlink" title="合式类型"></a>合式类型</h2><p>本章将讨论如何完善类型定义</p>
<h3 id="重写object的成员"><a href="#重写object的成员" class="headerlink" title="重写object的成员"></a>重写object的成员</h3><h4 id="ToString"><a href="#ToString" class="headerlink" title="ToString()"></a>ToString()</h4><p>在对象上调用ToString()默认返回类的完全限定名称</p>
<blockquote>
<p>如需返回有用的、面向开发者的诊断字符串，就要重写ToString()。<br>考虑尽量使ToString()返回的字符串简短。<br>不要从ToString()返回空字符串来代表“空”（null）。<br>不要从ToString()抛出异常或造成可观察到的副作用（改变对象状态）。<br>如果返回值与语言文化相关或要求格式化（例如DateTime），就要重载ToString (string format)或实现IFormattable。<br>考虑从ToString()返回独一无二的字符串以标识对象实例</p>
</blockquote>
<h4 id="GetHashCode"><a href="#GetHashCode" class="headerlink" title="GetHashCode()"></a>GetHashCode()</h4><p>底线是重写Equals()就要重写GetHashCode()，否则编译器会显示警告</p>
<p>哈希码（hash code）作用是生成和对象值对应的数字，从而高效地平衡哈希表</p>
<p>·必须：相等的对象必然有相等的哈希码（若a.Equals(b)，则a.GetHashCode()&#x3D;&#x3D;b.GetHashCode()）<br>必须：在特定对象的生存期内，即使对象的数据发生了改变，GetHashCode()也应始终返回相同的值。通常可以将对象的哈希码保存在某个恰当的位置（后文将简称为“缓存”），并让GetHashCode()返回缓存值，从而确保其返回值不变。但是，不要通过对比哈希码来判断两个对象是否相等，因为数据相等的两个对象可能有不相等的哈希码，反之，数据不相等的两个对象，也可能有相等的哈希码。<br>必须：GetHashCode()不应引发任何异常；GetHashCode()总是成功返回一个值。<br>性能：哈希码应尽可能唯一。但由于哈希码只是返回一个int，所以只要一种对象包含的值比一个int能够容纳得多（这就几乎涵盖所有类型了），那么哈希码肯定存在重复。一个很容易想到的例子是long，因为long的取值范围大于int，所以假如规定每个int值都只能标识一个不同的long值，那么肯定剩下大量long值没法标识。<br>性能：可能的哈希码值应当在int的范围内平均分布。例如，创建哈希码时如果没有考虑到字符串在拉丁语言中的分布主要集中在初始的128个ASCII字符上，就会造成字符串值的分布非常不平均，所以不能算是好的GetHashCode()算法。<br>性能：GetHashCode()的性能应该优化。GetHashCode()通常在Equals()实现中用于“短路”一次完整的相等性比较（哈希码都不同，自然没必要进行完整的相等性比较了）。所以，当类型作为字典集合中的键类型使用时，会频繁调用该方法<br>性能：两个对象的细微差异应造成哈希值的极大差异。理想情况下，1位的差异应造成哈希码平均16位的差异。这有助于确保不管哈希表如何对哈希值进行“装桶”（bucketing），也能保持良好的平衡性<br>安全性：攻击者应难以伪造具有特定哈希码的对象。攻击手法是向哈希表中填写大量哈希为同一个值的数据。然后，哈希表的实现会变得效率低下，导致DOS（拒绝服务）攻击。</p>
<p>当然，许多原则是相互对立的。很难有一种哈希算法既快又满足所有这些要求。和任何设计问题一样，好的解决方案必然是综合考虑的结果。</p>
<ul>
<li>System.HashCode的Combine()方法获得对象哈希码</li>
</ul>
<h4 id="Equals"><a href="#Equals" class="headerlink" title="Equals()"></a>Equals()</h4><ol>
<li><p>对象同一性和相等的对象值<br> 针对引用来说.</p>
<blockquote>
<p>为值类型调用ReferenceEquals()总是返回false</p>
</blockquote>
</li>
<li><p>实现Equals()<br> 两个对象要相等，其标识数据（identifying data）必须相等</p>
<blockquote>
<p>object.Equals()的实现只是简单调用了一下ReferenceEquals()</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>要一起实现GetHashCode()、Equals()、&#x3D;&#x3D;操作符和!&#x3D;操作符，缺一不可<br>要用相同算法实现Equals()、&#x3D;&#x3D;和!&#x3D;。<br>避免在可变引用类型上重载相等性操作符（如重载的实现速度过慢，也不要重载）。<br>要在实现IEquitable时实现与相等性相关的所有方法</p>
</blockquote>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951426905.png" srcset="/img/loading.gif" lazyload><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951469783.png" srcset="/img/loading.gif" lazyload><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951481621.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="用元组重写GetHashCode-和Equals"><a href="#用元组重写GetHashCode-和Equals" class="headerlink" title="用元组重写GetHashCode()和Equals()"></a>用元组重写GetHashCode()和Equals()</h4><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951532360.png" srcset="/img/loading.gif" lazyload><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951558334.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>除x.y、f(x)、new、typeof、default、checked、unchecked、delegate、is、as、&#x3D;和&#x3D;&gt;之外，其他所有操作符都支持</p>
<p>operator</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951727721.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>避免在&#x3D;&#x3D;操作符的重载实现中使用该操作符</p>
</blockquote>
<blockquote>
<p>从技术上说，实现显式和隐式转换操作符并不是重载转型操作符（()）。但由于效果一样，所以一般都将“实现显式或隐式转换”说成“定义转型操作符”。<br>定义转换操作符在形式上类似于定义其他操作符，只是“operator”成了转换的结果类型。另外，operator要放在表示隐式或显式转换的implicit或explicit关键字后面<br>不要为有损转换提供隐式转换操作符<br>不要从隐式转换中抛出异常</p>
</blockquote>
<h2 id="引用其他程序集"><a href="#引用其他程序集" class="headerlink" title="引用其他程序集"></a>引用其他程序集</h2><p>不需要将所有代码都放到单独一个二进制文件中，C#和底层CLI框架允许将代码分散到多个程序集中。这样就可在多个可执行文件中重用程序集</p>
<ul>
<li>类库dll  开发者可将程序的不同部分转移到单独的编译单元中，这些单元称为类库(classlib)</li>
</ul>
<h3 id="引用类库"><a href="#引用类库" class="headerlink" title="引用类库"></a>引用类库</h3><ul>
<li><p>引用库项目文件（*.csproj），指出库的源代码在哪个项目中，并在两个项目之间建立依赖关系</p>
</li>
<li><p>引用程序集文件本身。换言之，引用编译好的库（*.dll）而不是项目。如果库和程序分开编译，比如由企业内的另一个团队编译，这种方式就非常合理。</p>
</li>
<li><p>引用NuGet包</p>
</li>
</ul>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951980039.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="NuGet打包"><a href="#NuGet打包" class="headerlink" title="NuGet打包"></a>NuGet打包</h3><p>NuGet不仅包含一个清单来标识作者、公司、依赖项等，还在NuGet.org提供了一个默认包提供者以便上传、更新、索引和下载包</p>
<p>可在项目中引用一个NuGet包（*.nupkg），从你事先配置好的NuGet提供者URL处自动安装。NuGet包提供了一个清单文件（*.nuspec），其中列出了包中所含的所有附加元数据。还提供了你可能想要的所有附加资源，包括本地化文件、配置文件、内容文件等等。最后，NuGet包将所有单独的资源合并成单个ZIP文件（虽然使用.nupkg扩展名）。所以，用*.zip扩展名重命名文件，就可用任何常规压缩工具打开并检查文件内容。</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668952069186.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="类型封装"><a href="#类型封装" class="headerlink" title="类型封装"></a>类型封装</h2><p>类封装行为和数据，而程序集封装一组类型。开发者可将一个系统分解成多个程序集，在多个应用程序之间共享，或将它们与第三方提供的程序集集成。</p>
<p>不添加任何访问修饰符的类或结构体会被默认声明为内部访问（等同于使用关键字internal来声明），而嵌套类型（即声明在类中的类）则默认被声明为私有访问。</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668952176122.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h2><p>namespace<br>组织所有类型，用命名空间对它们进行逻辑分组</p>
<blockquote>
<p>不要使用容易变化的名称（组织层次结构、短期品牌等）<br>要为命名空间附加公司名前缀，防止不同公司使用同一个名称<br>要为命名空间二级名称使用稳定的、不随版本升级而变化的产品名称<br>不要定义没有明确放到一个命名空间中的类型<br>考虑创建和命名空间层次结构匹配的文件夹结构</p>
</blockquote>
<blockquote>
<p>CLR中没有“命名空间”这种东西。类型名称必然完全限定</p>
</blockquote>
<h2 id="XML注释"><a href="#XML注释" class="headerlink" title="XML注释"></a>XML注释</h2><p>这种提示能为大型应用程序的开发提供重要帮助，尤其是多个开发者需要共享代码的时候</p>
<p>由于XML注释旨在提供API文档，所以一般只和C#声明配合使用</p>
<blockquote>
<p>如果签名不能完全说明问题，要为公共API提供XML文档，其中包括成员说明、参数说明和API调用示例。</p>
</blockquote>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收是“运行时”的核心功能，旨在回收不再被引用的对象所占用的内存<br>    垃圾回收器只回收内存，不处理其他资源，比如数据库连接、句柄（文件、窗口等）、网络端口以及硬件设备（比如串口</p>
<h3 id="NET中的垃圾回收"><a href="#NET中的垃圾回收" class="headerlink" title=".NET中的垃圾回收"></a>.NET中的垃圾回收</h3><p>.NET的垃圾回收器采用mark-and-compact算法。一次垃圾回收周期开始时，它识别对象的所有根引用。根引用是来自静态变量、CPU寄存器以及局部变量或参数实例（以及本节稍后会讲到的f-reachable对象）的任何引用。基于该列表，垃圾回收器可遍历每个根引用所标识的树形结构，并递归确定所有根引用指向的对象。这样，垃圾回收器就可识别出所有可达对象。<br>执行垃圾回收时，垃圾回收器不是枚举所有访问不到的对象；相反，它将所有可达对象紧挨着放到一起，从而覆盖不可访问的对象（也就是垃圾，或者不可达对象）<br>为定位和移动所有可达对象，系统要在垃圾回收器运行期间维持状态的一致性。为此，进程中的所有托管线程都会在垃圾回收期间暂停。这显然会造成应用程序出现短暂的停顿。不过，除非某次垃圾回收耗时特别长或者垃圾回收过于频繁，否则这个停顿是不太引人注意的。为尽量避免在不恰当的时间执行垃圾回收，System.GC对象包含一个Collect()方法。可在执行关键代码之前调用它（执行这些代码时不希望GC运行）。这样做不会阻止垃圾回收器运行，但会显著减小它运行的可能性——前提是关键代码执行期间不会发生内存被大量消耗的情况。<br>.NET垃圾回收的特别之处在于，并非所有垃圾都一定会在一个垃圾回收周期中清除。研究对象的生存期会发现：相较于长期存在的对象，最近创建的对象更有可能需要垃圾回收。为此，.NET垃圾回收器支持“代”（generation）的概念，它会以更快的频率尝试清除生存时间较短的对象（新生对象）。而那些已在一次垃圾回收中“存活”下来的对象（老对象）会以较低的频率清除。具体地说，共有3代对象。一个对象每次在一个垃圾回收周期中存活下来，它都会移动到下一代，直至最终移动到第二代（从第零代开始）。相较于第二代对象，垃圾回收器会以更快的频率对第零代的对象执行垃圾回收。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>WeakReference<br>弱引用不阻止对对象进行垃圾回收，但会维持一个引用。这样，对象在被垃圾回收器清除之前可以重用。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953179806.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="资源清理"><a href="#资源清理" class="headerlink" title="资源清理"></a>资源清理</h2><p>垃圾回收是“运行时”的重要职责。但要注意，垃圾回收旨在提高内存利用率，而非清理文件句柄、数据库连接字符串、端口或其他有限的资源。</p>
<h3 id="终结器"><a href="#终结器" class="headerlink" title="终结器"></a>终结器</h3><p>类名之前<code>~</code><br>允许程序员写代码来清理类的资源，无法显式调用.负责释放像数据库连接和文件句柄这样的资源，这些资源需通过一次显式的行动来进行清理，而垃圾回收器不知道具体如何采取这些行动。</p>
<p>唯一确定的是终结器会在对象最后一次使用之后，并“通常”在应用程序正常关闭前的某个时间运行。这里“通常”一词是为了强调事实上终结器有可能不会被调用。尤其当程序被强行关闭时。例如，计算机关机，或者程序被调试器强行终止，终结器都很有可能不会被调用。</p>
<h3 id="使用using语句进行确定性终结"><a href="#使用using语句进行确定性终结" class="headerlink" title="使用using语句进行确定性终结"></a>使用using语句进行确定性终结</h3><ul>
<li><p>IDisposable接口用名为Dispose()<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953458810.png" srcset="/img/loading.gif" lazyload><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953473415.png" srcset="/img/loading.gif" lazyload><br>即使开发者忘记显式调用Close()，终结器也会调用它。虽然终结器运行得会晚一些（相较于显式调用Close()），但该方法肯定会得到调用。</p>
</li>
<li><p>实例化TemporaryFileStream后，调用Dispose()前，有可能发生一个异常。这造成Dispose()得不到调用，资源清理不得不依赖于终结器。为避免这个问题，调用者需要实现一个try&#x2F;finally块。但开发者不需要显式地写一个这样的块。因为C#为此提供了using语句。<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953552863.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>using语句只是提供了try&#x2F;finally块的语法快捷方式。</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收、终结和IDisposable"><a href="#垃圾回收、终结和IDisposable" class="headerlink" title="垃圾回收、终结和IDisposable"></a>垃圾回收、终结和IDisposable</h3><ol>
<li>IDisposable.Dispose()方法包含对System.GC.SuppressFinalize()的调用，作用是从终结（f-reachable）队列中移除TemporaryFileStream类实例。这是因为所有清理都在Dispose()方法中完成了，而不是等着终结器执行。<ul>
<li>该队列中的对象已差不多准备好了进行垃圾回收，只是它们还有终结方法没有运行。这种对象只有在其终结方法被调用之后，才能由“运行时”进行垃圾回收。但垃圾回收器本身不调用终结方法。相反，对这种对象的引用会添加到f-reachable队列中，并由一个额外的线程根据执行上下文，挑选合适的时间进行处理。讽刺的是，这造成了托管资源的垃圾回收时间的推迟——而许多这样的资源本应更早一些被清理。推迟是因为f-reachable队列是“引用”列表。所以，对象只有在它的终结方法得到调用，而且对象引用从f-reachable队列中删除之后，才会真正变成“垃圾”.正是由于这个原因，Dispose()才调用System.GC.SuppressFinalize，告诉“运行时”不要将该对象添加到f-reachable队列，而是允许垃圾回收器在对象没有任何引用（包括任何f-reachable引用）时清除对象。</li>
</ul>
</li>
<li>Dispose()调用了Dispose(bool disposing)方法，并传递实参true。结果是为Stream调用Dispose()方法（清理它的资源并阻止终结）。接着，临时文件在调用Dispose()后立即删除。这个重要的调用避免了一定要等待终结队列处理完毕才能清理资源的限制</li>
<li>终结器现在不是调用Close()，而是调用Dispose(bool disposing)，并传递实参false。结果是即使文件被删除，Stream也不会关闭（disposed）。原因是从终结器中调用Dispose(bool disposing)时，Stream实例本身还在等待终结（或者已经终结，系统会以任意顺序终结对象）。所以，在执行终结器时，拥有托管资源的对象不应清理，那应该是终结队列的职责。</li>
<li>同时创建Close()和Dispose()方法需谨慎。只看API并不知道Close()会调用Dispose()。所以开发者搞不清楚是否需要显式调用Close()和Dispose()。</li>
<li>若要提高终结器在程序结束之前被调用的可能性，可以将终结器中的代码实现并注册到AppDomain.CurrentDomain.ProcessExit事件处理器中。这个方法即便在.NET Core中也有效。只要程序没有异常终止，可以保证代码被执行。（下一节将具体介绍）</li>
</ol>
<blockquote>
<p>避免为自己拥有的、带终结器的对象调用Dispose()。相反，依赖终结队列清理实例。·避免在终结方法中引用未被终结的其他对象。·要在重写Dispose()时调用基类的实现。·考虑在调用Dispose()后将对象状态设为不可用。对象被dispose之后，调用除Dispose()之外的方法应引发ObjectDisposedException异常。（Dispose()应该能多次调用。）·要为含有可dispose字段（或属性）的类型实现IDisposable接口，并dispose这些字段引用的对象。·要在派生类的Dispose()中调用基类的Dispose()。·要重构终结器方法来调用与IDisposable相同的代码，可能就是调用一下Dispose()方法。·不要在终结器方法中抛出异常。·若要提高终结器在程序结束之前被调用的可能性，考虑将终结器中的代码实现在事件处理器里并注册到AppDomain.CurrentDomain.ProcessExitevent中。·如果一个类同时注册了AppDomain.CurrentDomain.ProcessExitevent事件，又实现了Dispose()，一定要在Dispose()方法中解除注册的事件。·要从Dispose()中调用System.GC.SuppressFinalize()，以使垃圾回收更快地发生，并避免重复性的资源清理。·要保证Dispose()可以重入（可被多次调用）。·要保持Dispose()的简单性，把重点放在终结所要求的资源清理上。·要只为使用了稀缺或昂贵资源的对象实现终结器方法，即使终结会推迟垃圾回收。·要为有终结器的类实现IDisposable接口以支持确定性终结。·只有当类包含必须释放的资源，而该资源自己又没有终结器的时候，才要在类中实现终结器。</p>
</blockquote>
<blockquote>
<p>从.NET Core开始，程序结束时终结器不一定会被调用。若要提高终结器被调用的可能性，需要为相应的代码进行注册程序退出事件处理器</p>
</blockquote>
<blockquote>
<p>即使有异常从构造函数传播出来，对象仍会实例化，只是没有新实例从new操作符返回。如类型定义了终结器，对象一旦准备好进行垃圾回收，就会运行该方法（即使只构造了一部分的对象，终结方法也会运行）。另外要注意，如构造函数过早共享它的this引用，即使构造函数抛出异常，也能访问该引用。不要让这种情况发生。</p>
</blockquote>
<blockquote>
<p>调用对象的终结方法时，对该对象的引用都已消失。垃圾回收前唯一剩下的步骤就是运行终结代码。但完全可能无意中重新引用一个待终结的对象。这样，被重新引用的对象就不再是不可访问的，所以不能当作垃圾被回收掉。但假如对象的终结方法已经运行，那么除非显式标记为要进行终结（使用GC.ReRegisterFinalize()方法），否则终结方法不一定会再次运行。显然，像这样的对象复活是非常罕见的，而且通常应该避免发生。终结代码应该简单，只清理它引用的资源。</p>
</blockquote>
<h2 id="推迟初始化"><a href="#推迟初始化" class="headerlink" title="推迟初始化"></a>推迟初始化</h2><p>使用推迟初始化，可在需要时才创建（或获取）对象，而不是提前创建好——尤其是它们永远都不使用的前提下。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953911587.png" srcset="/img/loading.gif" lazyload alt="推迟加载属性"></p>
<h3 id="为泛型和Lambda表达式使用推迟加载"><a href="#为泛型和Lambda表达式使用推迟加载" class="headerlink" title="为泛型和Lambda表达式使用推迟加载"></a>为泛型和Lambda表达式使用推迟加载</h3><p>从C# 4.0和Microsoft .NET Framework 4.0开始，CLR添加了一个新类来帮助进行推迟初始化，这个类就是System.Lazy<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953951386.png" srcset="/img/loading.gif" lazyload><br>这样只有当调用FileStream属性的get访问器方法时才实例化属性要求的TemporaryFileStream对象。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="多异常类型"><a href="#多异常类型" class="headerlink" title="多异常类型"></a>多异常类型</h3><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668996874010.png" srcset="/img/loading.gif" lazyload><br>ArgumentNullException和NullReferenceException这两个异常很相似。前者应在错误传递了空值时抛出。空值是无效参数的特例。</p>
<blockquote>
<p>·要在向成员传递了错误参数时抛出ArgumentException或者它的某个子类型。抛出尽可能具体的异常（例如ArgumentNullException）。<br>·不要抛出System.SystemException或者它的派生类型。<br>·不要抛出System.Exception、System.NullReferenceException或者System.Application-Exception。<br>·考虑在程序继续执行会变得不安全时调用System.Environment.FailFast()来终止进程。<br>·要为传给参数异常类型的paramName实参使用nameof操作符。接收这种实参的异常类型包括ArgumentException、ArgumentOutOfRangeException和ArgumentNullException。</p>
</blockquote>
<h3 id="捕捉异常"><a href="#捕捉异常" class="headerlink" title="捕捉异常"></a>捕捉异常</h3><p>允许使用多个catch块，每个块都面向一个具体的异常类型<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668996990141.png" srcset="/img/loading.gif" lazyload><br>catch块支持一个额外的条件表达式。不是只根据异常类型来匹配，现在可以添加when子句来提供一个Boolean表达式</p>
<p>在catch中使用if需要谨慎</p>
<p>catch块必须按从最具体到最常规的顺序排列以避免编译错误</p>
<p>catch块并非一定需要具名参数，例如catch (SystemException){…}</p>
<h3 id="重新抛出"><a href="#重新抛出" class="headerlink" title="重新抛出"></a>重新抛出</h3><p>C#支持不指定具体异常、但只能在catch块中使用的throw语句。<br>-抛出现有异常而不替换栈信息<br>包装或保存异常，直到程序执行离开catch块<br>例如，多线程代码可能用AggregateException包装异常。System.Runtime.ExceptionServices.ExceptionDispatchInfo类专门用来处理这种情况。你需要使用它的静态方法Capture()和实例方法Throw()。</p>
<h3 id="常规catch块"><a href="#常规catch块" class="headerlink" title="常规catch块"></a>常规catch块</h3><p>catch{}<br>其行为和catch(System.Exception exception)块完全一致，只是没有类型名或变量名。此外，常规catch块必须是所有catch块的最后一个。</p>
<blockquote>
<p>与常规catch块对应的CIL代码是一个catch(object)块</p>
</blockquote>
<h3 id="异常处理范式"><a href="#异常处理范式" class="headerlink" title="异常处理范式"></a>异常处理范式</h3><ul>
<li><p>只捕捉能处理的异常</p>
</li>
<li><p>不要隐藏（bury）不能完全处理的异常</p>
</li>
<li><p>尽量少用System.Exception和常规catch块。</p>
</li>
<li><p>避免在调用栈较低的位置报告或记录异常。</p>
</li>
<li><p>在catch块中使用<code>throw;</code>而不是<code>throw &lt;异常对象&gt;</code>语句</p>
</li>
<li><p>想好异常条件来避免在catch块中重新抛出异常</p>
</li>
<li><p>避免在异常条件表达式中抛出异常</p>
</li>
<li><p>避免以后可能变化的异常条件表达式</p>
</li>
<li><p>重新抛出不同异常时要小心。要保留原始异常，需设置新异常的InnerException属性</p>
<ul>
<li><p>更改异常类型可更好地澄清问题</p>
</li>
<li><p>私有数据是原始异常的一部分</p>
</li>
<li><p>异常类型过于具体，以至于调用者不能恰当地处理</p>
</li>
</ul>
</li>
</ul>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>不建议使用<br>    <img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668997903393.png" srcset="/img/loading.gif" lazyload><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668997929371.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>所有异常都应该使用“Exception”后缀，彰显其用途<br>所有异常通常都应包含以下三个构造函数：无参构造函数、获取一个string参数的构造函数以及同时获取一个字符串和一个内部异常作为参数的构造函数。另外，由于异常通常在抛出它们的语句中构造，所以还应允许其他任何异常数据成为构造函数的一部分。（当然，假如特定数据是必需的，而某个构造函数无法满足要求，则不应创建该构造函数。）<br>避免使用深的继承层次结构（一般应小于5级）</p>
</blockquote>
<ul>
<li>可序列化异常<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668997993755.png" srcset="/img/loading.gif" lazyload></li>
</ul>
<h3 id="重新抛出包装的异常"><a href="#重新抛出包装的异常" class="headerlink" title="重新抛出包装的异常"></a>重新抛出包装的异常</h3><p>有时，栈中较低位置抛出的异常在高处捕捉到时已没有意义。例如，假定服务器上因磁盘空间耗尽而抛出System.IO.IOException。客户端捕捉到该异常，却理解不了为什么居然会有I&#x2F;O活动。</p>
<p>这种情况下一定要设置“包装异常”（wrapping exception）的InnerException属性（一般是通过构造函数调用，例如new InvalidOperationException(String, Exception)）。这样，就有一个额外的上下文供较接近所调用框架的人进行诊断。</p>
<p>最后，记住异常的目标接收者是写代码来调用（可能以不正确的方式调用）你的API的程序员。所以，要提供尽量多的信息来描述他哪里做错了以及如何修正（后者可能更重要）。异常类型是这个沟通机制的重要一环。所以，要精心选择类型。</p>
<ul>
<li>checked和unchecked转换</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>C#通过泛型来促进代码重用，尤其是算法重用。</p>
<p>参数化类型，本质是代码模块<br>可利用泛型创建一个数据结构，该数据结构能进行特殊化以处理特定类型。程序员定义这种参数化类型，使泛型类型的每个变量都具有相同的内部算法，但数据类型和方法签名可随为类型参数提供的类型实参而变。</p>
<h3 id="使用泛型类"><a href="#使用泛型类" class="headerlink" title="使用泛型类"></a>使用泛型类</h3><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668998969748.png" srcset="/img/loading.gif" lazyload><br>  相同泛型接口的不同构造被视为不同类型，所以类或结构能多次实现“同一个”泛型接口。与其实现接口的三个版本，不如实现三个属性：EmailAddresses、PhoneNumbers和MailingAddresses，每个属性都返回泛型接口的相应构造。</p>
<blockquote>
<p>避免在类型中实现同一泛型接口的多个构造</p>
</blockquote>
<h3 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><p>类型安全</p>
</li>
<li><p>编译时类型检查减小了在运行时发生InvalidCastException异常的概率</p>
</li>
<li><p>不会造成装箱</p>
</li>
<li><p>缓解代码膨胀</p>
</li>
<li><p>性能提升。无转化</p>
</li>
<li><p>可读性提高</p>
</li>
<li><p>支持智能感知</p>
</li>
<li><p>泛型允许写代码来实现模式，并在以后出现这种模式的时候重用该实现。</p>
</li>
</ol>
<h3 id="类型参数命名规范"><a href="#类型参数命名规范" class="headerlink" title="类型参数命名规范"></a>类型参数命名规范</h3><ul>
<li><p>类型参数的命名应尽量具有描述性。此外，为了强调它是类型参数，名称应包含T前缀，例如<code>EntityCollection&lt;TEntity&gt;</code></p>
</li>
<li><p>唯一不需要使用描述性类型参数名称的时候是描述不增加任何值的时候。例如，在<code>Stack&lt;T&gt;</code>中使用T就够了，因为T足以说明问题——栈适合任意类型</p>
</li>
<li><p>考虑在类型参数的名称中指明约束</p>
</li>
</ul>
<h3 id="泛型接口和结构"><a href="#泛型接口和结构" class="headerlink" title="泛型接口和结构"></a>泛型接口和结构</h3><h3 id="定义构造函数和终结器"><a href="#定义构造函数和终结器" class="headerlink" title="定义构造函数和终结器"></a>定义构造函数和终结器</h3><h3 id="使用default操作符指定默认值"><a href="#使用default操作符指定默认值" class="headerlink" title="使用default操作符指定默认值"></a>使用default操作符指定默认值</h3><p>从C# 7.1起，只要能推断出数据类型，使用default时就可不指定参数。例如，在变量初始化或赋值时，可用Pair<T> pair&#x3D;default代替Pair<T> pair&#x3D;default (Pair<T>)。<br>  另外，如方法返回int，直接写return default就可以了，编译器能从方法返回类型中推断出应返回一个default(int)。</p>
<h3 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h3><p>类型参数的数量（或者称为元数，即arity）区分了同名类。例如，由于类型参数的数量不同，所以可在同一命名空间中定义Pair<T>和Pair&lt;TFirst, TSecond&gt;。</p>
<blockquote>
<p>要将只是类型参数数量不同的多个逻辑相关的泛型类放到同一个文件中。<br>实现元组语法的底层类型实际是多个多个类型参数的泛型类，具体说就是System.ValueTuple。最多八个</p>
</blockquote>
<h3 id="嵌套泛型类型"><a href="#嵌套泛型类型" class="headerlink" title="嵌套泛型类型"></a>嵌套泛型类型</h3><p>嵌套类型自动获得包容类型的类型参数。例如，假如包容类型声明类型参数T，则所有嵌套类型都是泛型，也可使用类型参数T。</p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p><code>where</code><br>  泛型允许为类型参数定义约束，强迫在编译阶段作为类型实参提供的类型遵守各种规则。</p>
<h4 id="接口约束"><a href="#接口约束" class="headerlink" title="接口约束"></a>接口约束</h4><p>  <img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668999488711.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="类型参数约束"><a href="#类型参数约束" class="headerlink" title="类型参数约束"></a>类型参数约束</h4><p>  要求能将类型实参转换为特定的类型。<br>  <img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668999591289.png" srcset="/img/loading.gif" lazyload><br>  要求为类型参数TValue提供的所有类型实参都能隐式转换为EntityBase类。</p>
<ul>
<li><p>假如同时指定了多个约束，那么类类型约束必须第一个出现（就像在类声明中，基类必须先于所实现的接口出现）</p>
</li>
<li><p>类类型约束不能指定密封类或者不是类的类型</p>
</li>
<li><p>从C# 7.3开始，可以使用System.Enum作为约束来确保类型参数为一个枚举类型。但是不能用System.Array将类型参数约束为一个集合。然而我们依然可以用很多其他集合类或接口来替代</p>
</li>
<li><p>委托约束:System.Delegate和System.MulticastDelegate<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668999784032.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>有了它们便可以安全地将多个委托对象进行组合（使用静态的Combine()方法）和分离（使用静态的Remove()方法）</li>
<li>虽然泛型类型无法以强类型的方式调用委托，但是还是可以通过调用DynamicInvoke()方法来调用委托。该方法通过内部使用反射来实现其功能。</li>
<li>泛型类型除了通过DynamicInvoke()来调用委托之外，还可以在编译时通过T的直接引用来调用Combine()方法然后强制转换为所需的类型。</li>
</ul>
</li>
</ul>
<h4 id="非托管约束"><a href="#非托管约束" class="headerlink" title="非托管约束"></a>非托管约束</h4><p>在C# 7.3中可以将类型参数约束为非托管类型，包括：sbyte、byte、short、ushort、int、uint、long、ulong、char、float、double、decimal、bool、枚举、指针或者只包含非托管字段的结构。有了这个约束，你可以在代码中对T使用如sizeof操作符或者执行stackalloc操作</p>
<p>当使用结构作为类型参数约束时，结构不能为泛型。从C# 8.0开始，在这种情况下结构也可以是泛型的。例如，即便T被约束为非托管类型，也可以像这样使用：<code>Thing&lt;Thing&lt;int&gt;&gt;</code></p>
<h4 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h4><p><code>notnull</code><br>notnull约束不能与struct或class约束共同使用，因为struct和class默认不可空</p>
<h4 id="struct-x2F-class约束"><a href="#struct-x2F-class约束" class="headerlink" title="struct&#x2F;class约束"></a>struct&#x2F;class约束</h4><p>将类型参数限制为任何非可空值类型或任何引用类型。</p>
<ul>
<li><p>class约束不是将类型实参限制为类类型，而是限制为引用类型，所以类、接口、委托和数组类型都符合条件。</p>
</li>
<li><p>引用类型可以在声明约束时使用可空修饰符来改变约束<code>class?</code></p>
<ul>
<li>struct不允许使用可空修饰符，但可以在提供参数时使用可空修饰符来表明该参数的可空性。</li>
</ul>
</li>
<li><p>struct约束有一个很特别的地方：可空值类型不符合条件。</p>
<ul>
<li>可空值类型作为泛型类型<code>Nullable&lt;T&gt;</code>来实现，而后者本身向T应用了struct约束。如可空值类型符合条件，就可定义毫无意义的<code>Nullable&lt;Nullable&lt;int&gt;&gt;</code>类型。双重可空的整数当然没有意义。</li>
</ul>
</li>
</ul>
<h4 id="多个约束"><a href="#多个约束" class="headerlink" title="多个约束"></a>多个约束</h4><p>两个where子句之间并不存在逗号。</p>
<blockquote>
<p>不支持OR条件</p>
</blockquote>
<h4 id="构造函数约束"><a href="#构造函数约束" class="headerlink" title="构造函数约束"></a>构造函数约束</h4><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/433EA4DB-C776-42b8-B2DD-36C358AC7B5B.png" srcset="/img/loading.gif" lazyload><br>只能对默认构造函数进行约束。在指定了其他所有约束之后添加new()</p>
<p>如果被实例化的类的构造函数必须接收参数，可以将类型参数约束为一个工厂接口，然后由工厂接口的实现类来构造TValue实例而不是在EntityDictionary类中构造。</p>
<h4 id="约束继承"><a href="#约束继承" class="headerlink" title="约束继承"></a>约束继承</h4><p>无论泛型类型参数，还是它们的约束，都不会被派生类继承，因为泛型类型参数不是成员。</p>
<p>经常采取的做法是使新泛型类型从其他泛型类型派生.类型参数必须具有等同（或更强）于基类的约束。</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/AA224A77-F3C2-4f9b-9FB3-4D9A65B48720.png" srcset="/img/loading.gif" lazyload><br><code>EntityBase&lt;T&gt;</code>要求基类指示符<code>EntityBase&lt;U&gt;</code>为T提供的类型实参U实现<code>IComparable&lt;U&gt;</code>，所以子类<code>Entity&lt;U&gt;</code>要对U进行相同的约束，否则会造成编译时错误。这使程序员在使用派生类时能注意到基类的约束，避免在使用派生类的时候发现了一个约束，却不知道该约束来自哪里。</p>
<ul>
<li>虚方法重写时，约束自动隐式继承.</li>
</ul>
<blockquote>
<p>所有泛型都隐式允许&#x3D;&#x3D;和!&#x3D;比较，以及对对象的隐式转换，因为一切都是对象。</p>
</blockquote>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>为声明泛型方法，要按照与泛型类型一样的方式指定泛型类型参数，也就是在方法名之后添加类型参数声明</p>
<p>类型参数的数量（元数）可用于区分方法签名。</p>
<h4 id="泛型方法类型推断"><a href="#泛型方法类型推断" class="headerlink" title="泛型方法类型推断"></a>泛型方法类型推断</h4><p>实参类型必须与泛型方法的形参“匹配”以推断出正确的类型实参</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">Console.WriteLine(<br>    MathEx.Max&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">7</span>,<span class="hljs-number">490</span>)<span class="hljs-comment">//int多余了,多余的编码</span><br>);<br><span class="hljs-comment">//类型推断:</span><br>Console.WriteLine(<br>    MathEx.Max(<span class="hljs-number">7</span>,<span class="hljs-number">490</span>)<br>);<br></code></pre></td></tr></table></figure>

<p>推断时算法只考虑泛型方法的实参、实参类型以及形参类型。</p>
<h4 id="指定约束"><a href="#指定约束" class="headerlink" title="指定约束"></a>指定约束</h4><p>泛型方法的类型参数也允许使用与泛型类型的类型参数相同的方法指定约束。</p>
<h4 id="泛型方法中的转型"><a href="#泛型方法中的转型" class="headerlink" title="泛型方法中的转型"></a>泛型方法中的转型</h4><p>有时应避免使用泛型——例如在使用它会造成一次转型操作被“隐藏”的时候。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream,IFormatter formatter</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (T)formatter.Deserialize(stream);<br>&#125;<br><span class="hljs-comment">//formatter负责将数据从流中移除，把它转换成object。为formatter调用Deserialize()，会返回object类型的数据。如使用Deserialize()的泛型版本进行调用，那么会写出下面这样的代码：</span><br><span class="hljs-built_in">string</span> gretting=<br>        Deserializetion.Deserialize&lt;<span class="hljs-built_in">string</span>&gt;(stream,formatter);<br><span class="hljs-comment">//上述代码的问题在于，对于方法的调用者来说，Deserialize&lt;T&gt;()似乎类型安全。但仍然会为调用者隐式（而非显式）执行一次转型。下面是等价的非泛型调用：</span><br><span class="hljs-built_in">string</span> gretting=<br>        (<span class="hljs-built_in">string</span>)Deserializetion.Deserialize(stream,formatter); <br><span class="hljs-comment">//运行时转型可能失败，所以方法不像表面上那样类型安全。Deserialize&lt;T&gt;方法是纯泛型的，会向调用者隐藏转型动作，这存在一定风险。更好的做法是使方法成为非泛型的，返回object，使调用者注意到它不是类型安全的。开发者在泛型方法中执行转型时，假如没有约束来验证转型的有效性，那么一定要非常小心。</span><br></code></pre></td></tr></table></figure>

<h3 id="协变性和逆变性"><a href="#协变性和逆变性" class="headerlink" title="协变性和逆变性"></a>协变性和逆变性</h3><p>不能将<code>List&lt;string&gt;</code>类型的表达式赋给<code>List&lt;object&gt;</code>类型的变量。</p>
<p>用不同类型参数声明同一个泛型类的两个变量，这两个变量不是类型兼容的——即使是将一个较具体的类型赋给一个较泛化的类型。也就是说，它们不是协变量</p>
<ul>
<li>协变量，范畴论的术语假定两个类型X和Y具有特殊关系，即每个X类型的值都能转换成Y类型。如<code>I&lt;X&gt;</code>和<code>I&lt;Y</code>&gt;也总是具有同样的特殊关系，就说“<code>I&lt;T&gt;</code>对T协变”。使用仅一个类型参数的泛型类型时，可以简单地说“<code>I&lt;T&gt;</code>是协变的”。从<code>I&lt;X&gt;</code>向<code>I&lt;Y&gt;</code>的转换称为协变转换。<ul>
<li>一个<code>IPair&lt;PdaItem&gt;</code>中可包含地址，但<code>Pair&lt;Contact&gt;</code>对象只能包含联系人，不能包含地址。若允许不受限制的泛型协变性，类型安全将完全失去保障。</li>
<li>在字符串列表中不能插入整数，但在对象列表中可以，所以从字符串列表转换成对象列表一定要被视为非法，使编译器能预防错误。</li>
</ul>
</li>
</ul>
<h4 id="out允许协变"><a href="#out允许协变" class="headerlink" title="out允许协变"></a>out允许协变</h4><p>创建只读<code>IReadOnlyPair&lt;T&gt;</code>接口，只允许T从接口中“出来”（换言之，作为方法或只读属性的返回类型），永远不“进入”接口（换言之，不作为形参或可写属性的类型），就不会出问题了.<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/E4B89384-DF3F-4c26-B6BE-D4C1A3DA6B26.png" srcset="/img/loading.gif" lazyload alt="理论上"><br>通过限制泛型类型声明，让它只向接口的外部公开数据，编译器就没理由禁止协变性了。但是依然编译不了</p>
<ul>
<li>用out修饰<code>IReadOnlyPair&lt;out T&gt;</code>接口的类型参数，会导致编译器验证T是否真的只用作“输出”（方法的返回类型和只读属性的返回类型），且永远不用于形参或属性的赋值方法。验证通过，编译器就会放行对接口的任何协变转变。</li>
</ul>
<p>限制:</p>
<ul>
<li>只有泛型接口和泛型委托才可以协变。泛型类和结构永远不是协变的。</li>
<li>类型实参必须都是引用类型</li>
<li>接口或委托必须声明为支持协变，编译器必须验证协变所针对的类型参数确实只用在“输出”位置</li>
</ul>
<h4 id="in允许逆变性"><a href="#in允许逆变性" class="headerlink" title="in允许逆变性"></a>in允许逆变性</h4><p>协变性的反方向称为逆变性.</p>
<ul>
<li>假定X和Y类型彼此相关，每个X类型的值都能转换成Y类型。如果<code>I&lt;X&gt;</code>和<code>I&lt;Y&gt;</code>类型总是具有相反的特殊关系——也就是说，<code>I&lt;Y&gt;</code>类型的每个值都能转换成<code>I&lt;X&gt;</code>类型——就说“<code>I&lt;T&gt;</code>对T逆变”。</li>
</ul>
<p>典例:比较器。凡是需要一个<code>ICompareThings&lt;Apple&gt;</code>的地方，都可安全地使用<code>ICompareThings&lt;Fruit&gt;</code>类型的值。</p>
<ul>
<li><p>对某个类型参数逆变的接口只能在“输入”位置使用那个类型参数。主要位置就是形参。极少见的是只写属性的类型<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/BF4B6843-880F-424c-AB36-9032FDD5E865.png" srcset="/img/loading.gif" lazyload>in指示编译器核对T未在属性的取值方法（getter）中使用，也没有作为方法的返回类型使用。核对无误，就启用接口的逆变转换。</p>
</li>
<li><p>只有泛型接口和委托类型才能是逆变的，发生变化的类型实参只能是引用类型，而且编译器必须能验证接口的安全逆变。</p>
</li>
</ul>
<blockquote>
<p>接口可以一个类型参数协变，另一个逆变。但除了委托之外其实很少需要这样做。</p>
</blockquote>
<h4 id="数组对不安全协变性的支持"><a href="#数组对不安全协变性的支持" class="headerlink" title="数组对不安全协变性的支持"></a>数组对不安全协变性的支持</h4><p>在所有非泛型类型中，数组最像泛型。如同平时思考泛型“list of T”或泛型“pair of T”一样，也可以用相同的模式思考“array of T”。</p>
<p>C#确实支持数组协变，即使这样并不类型安全。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">Fruit[] fruits=<span class="hljs-keyword">new</span> Apple[<span class="hljs-number">10</span>]<span class="hljs-comment">//合法</span><br>fruits[<span class="hljs-number">0</span>]=<span class="hljs-keyword">new</span> Orange();<span class="hljs-comment">//异常.因为fruits实际可能是一个Apple数组</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>尽量避免使用不安全的数组协变。</p>
</blockquote>
<ul>
<li>每个数组都能转换成只读（进而安全协变）的<code>IEnumerable&lt;T&gt;</code>接口。<ul>
<li><code>IEnumerable&lt;Fruit&gt; fruits=new Apple[10]</code>既类型安全又合法，因为在只有只读接口的前提下，无法在数组中插入一个Orange。</li>
</ul>
</li>
</ul>
<blockquote>
<p>考虑将数组转换成只读接口<code>IEnumerable&lt;T&gt;</code>，以便通过协变转换来安全地转换。</p>
</blockquote>
<h3 id="泛型内部机制"><a href="#泛型内部机制" class="headerlink" title="泛型内部机制"></a>泛型内部机制</h3><p>泛型类的“类型参数”成了元数据，“运行时”在需要时会利用它们构造恰当的类。所以，泛型支持继承、多态性以及封装。可用泛型定义方法、属性、字段、类、接口和委托。</p>
<p>为此，泛型需要来自底层“运行时”的支持。将泛型引入C#语言，编译器和框架需共同发力。例如，为避免装箱，对于基于值的类型参数，其泛型实现和引用类型参数的泛型实现是不同的。</p>
<blockquote>
<p>泛型类编译后与普通类无太大差异。编译结果无非就是元数据和CIL。CIL是参数化的，接受在代码中别的地方由用户提供的类型。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/3EBCBEE7-A31F-419b-98B5-E3755BCB527D.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<blockquote>
<p>实例化基于值类型的泛型:<br>用值类型作为类型参数首次构造一个泛型类型时，“运行时”会将指定的类型参数放到CIL中合适的位置，从而创建一个具体化的泛型类型。总之，“运行时”会针对每个新的“参数值类型”创建一个新的具体化泛型类型。</p>
</blockquote>
<blockquote>
<p>实例化基于引用类型的泛型:<br>使用引用类型作为类型参数首次构造一个泛型类型时，“运行时”会在CIL代码中用object引用替换类型参数来创建一个具体化的泛型类型（而不是基于所提供的类型实参来创建一个具体化的泛型类型）。以后，每次用引用类型参数实例化一个构造好的类型，“运行时”都重用之前生成好的泛型类型的版本——即使提供的引用类型与第一次不同。</p>
</blockquote>
<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>随着创建的类越来越多，会发现它们的关系存在固定模式。一个常见模式是向方法传递对象，该方法再调用对象的一个方法。</p>
<p>例如，向方法传递一个<code>IComparer&lt;int&gt;</code>引用，该方法本身可在你提供的对象上调用<code>Compare()</code>方法。在这种情况下，接口的作用只不过是传递一个方法引用。</p>
<p>第二个例子是在调用新进程时，不是阻塞或反复检查（轮询）进程是否完成。理想情况是让方法异步运行并调用一个回调函数，当异步调用结束时通过该函数来通知调用者。</p>
<p>经验丰富的C和C++程序员长期以来利用“函数指针”将对方法的引用作为实参传给另一个方法。C#使用委托提供相似的功能。委托允许捕捉对方法的引用，并像传递其他对象那样传递该引用，像调用其他方法那样调用被捕捉的方法</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>声明委托类型要使用delegate关键字，后跟像是方法声明的内容。该方法的签名就是委托能引用的方法的签名。</p>
<p>名为Comparer的委托使人对其用途一目了然</p>
<p>像类能嵌套在其他类中一样，委托也能嵌套在类中。</p>
<h3 id="Func和Action"><a href="#Func和Action" class="headerlink" title="Func和Action"></a>Func和Action</h3><p>从C# 3.0起很少需要（甚至根本不必）自己声明委托。</p>
<ul>
<li>System.Func系列委托代表有返回值的方法，</li>
<li>System.Action系列代表返回void的方法。</li>
</ul>
<blockquote>
<p>考虑定义自己的委托类型带来的可读性，是否比使用预定义泛型委托类型所带来的便利性更重要。</p>
</blockquote>
<h3 id="实例化委托"><a href="#实例化委托" class="headerlink" title="实例化委托"></a>实例化委托</h3><p>实例化委托需要和委托类型自身签名对应的一个方法。方法名无关紧要，但签名剩余部分必须兼容委托签名。</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/897B08A2-DF3E-429d-A6CC-09D9829A6EF6.png" srcset="/img/loading.gif" lazyload></p>
<p>定义好方法后，可调用BubbleSort()并传递要由委托捕捉的方法名作为实参</p>
<p>注意委托是引用类型，但不需要用new实例化。</p>
<h3 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h3><p>委托实际是特殊的类。虽然C#标准没有明确说明类的层次结构，但.NET中委托总是派生自System.MulticastDelegate，后者又从System.Delegate派生.但C#编译器不允许声明直接或间接从System.Delegate或者System.MulticastDelegate派生的类。</p>
<p>第一个属性是System.Reflection.MethodInfo类型。MethodInfo描述方法签名，包括名称、参数和返回类型。<br>第二个属性Target的作用。一个对象实例来包含要调用的方法。在静态方法的情况下，Target为null。</p>
<ul>
<li>所有的委托都不可变.<ul>
<li>如果变量包含委托引用，并想引用不同的方法，则只能创建新委托再把它赋给变量。</li>
</ul>
</li>
</ul>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/B0C8186C-19DB-477d-A42C-5C49C13ED664.png" srcset="/img/loading.gif" lazyload alt="委托版冒泡实现"></p>
<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>前面的GreaterThan这么简单的方法居然需要如此复杂的准备，这实在说不过去，而这些“前戏”的目的只是使其能转换成委托类型。引入了非常精简的语法创建委托，C# 2.0的称为匿名方法，C# 3.0的称为Lambda表达式。这两种语法统称为匿名函数。</p>
<p>Lambda表达式分为语句Lambda和表达式Lambda<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/AFD8795E-4BA0-4f64-9E36-67CFF2D13798.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="语句Lambda"><a href="#语句Lambda" class="headerlink" title="语句Lambda"></a>语句Lambda</h3><p>Lambda表达式的目的是在需要基于很简单的方法生成委托时，避免声明全新成员的麻烦。</p>
<p>语句Lambda由形参列表、Lambda操作符&#x3D;&gt;和代码块构成。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1C37551A-8DD9-4042-A456-426495156A2D.png" srcset="/img/loading.gif" lazyload></p>
<p>当查看含有Lambda操作符的代码时，可自己在脑海中将该操作符替换成“用于”（go&#x2F;goes to）</p>
<ul>
<li>精简<ul>
<li>默认推断返回类型。</li>
<li>无方法名，无访问级别,即刻使用</li>
<li>参数推断。<ul>
<li>显式指定一个Lambda参数类型，所有参数类型都必须显式指定，而且必须和委托参数类型完全一致。</li>
</ul>
</li>
<li>如果单个参数，省略<code>()</code><ul>
<li>注意:空参数需要</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果类型对于读者显而易见，或者是无关紧要的细节，就考虑在Lambda形参列表中省略类型。</p>
</blockquote>
<h3 id="表达式Lambda"><a href="#表达式Lambda" class="headerlink" title="表达式Lambda"></a>表达式Lambda</h3><p>语句Lambda的语法比完整的方法声明简单得多，可以不指定方法名、可访问性和返回类型，有时甚至可以不指定参数类型。表达式Lambda则更进一步,唯一需要的就是要返回的表达式。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">BubbleSort(items,(first,second))=&gt;first&lt;second);<br></code></pre></td></tr></table></figure>

<p>通常，可像阅读语句Lambda那样将表达式Lambda中的&#x3D;&gt;理解成“用于”。但在委托作为“谓词”使用时（返回布尔值），将&#x3D;&gt;理解成“满足……条件”（such that或where）会更清楚一些。</p>
<ul>
<li><p>类似于null字面值，匿名函数不和任何类型关联。只是转换兼容委托。</p>
</li>
<li><p>无法在内部使用跳转</p>
</li>
<li><p>引入的参数和局部变量作用域仅限于表达式主体</p>
</li>
<li><p>表达式内确定性赋值检测不到外部局部变量进行初始化情况</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> number;<br>Func&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">bool</span>&gt; f=<br>        text=&gt;<span class="hljs-built_in">int</span>.TryParse(text,<span class="hljs-keyword">out</span> number);<br><span class="hljs-keyword">if</span>(f(<span class="hljs-string">&quot;1&quot;</span>))<br>        Console.Write(number);<span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>编译器生成的全都是“匿名函数”，这才是最开始的叫法。匿名方法是实现匿名函数的功能。所有这些语法糖都是为了更简单地生成匿名函数。</p>
</blockquote>
<h2 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h2><blockquote>
<p>避免在新代码中使用匿名方法语法，优先使用更简洁的Lambda表达式语法。</p>
</blockquote>
<p>匿名方法必须显式指定每个参数的类型，而且必须有代码块。参数列表和代码块之间不使用Lambda操作符&#x3D;&gt;。相反，是在参数列表前添加关键字delegate，强调匿名方法必须转换成委托类型。</p>
<h3 id="无参匿名方法"><a href="#无参匿名方法" class="headerlink" title="无参匿名方法"></a>无参匿名方法</h3><p>和Lambda表达式不同，匿名方法允许完全省略参数列表，前提是主体中不使用任何参数，而且委托类型只要求“值”参数。（也就是说，不要求将参数标记为out或ref。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">delegate</span>&#123;<span class="hljs-keyword">return</span> Console.ReadLine()!=<span class="hljs-string">&quot; &quot;</span>;&#125;<span class="hljs-comment">//它可转换成要求返回bool的任意委托类型，不管委托需要多少个参数。这个功能较少使用，但阅读遗留代码时可能用得着。</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>C#的Lambda表达式x&#x3D;&gt;y用邱奇的记号法应写成λx.y</p>
</blockquote>
<h2 id="委托没有结构相等性"><a href="#委托没有结构相等性" class="headerlink" title="委托没有结构相等性"></a>委托没有结构相等性</h2><p>NET委托类型不具备结构相等性（structural equality）。也就是说，不能将一个委托类型的对象引用转换成一个不相关的委托类型，即使两者的形参和返回类型完全一致。</p>
<p>如果需要结构一致但不相关的新委托类型，为了使用该类型的委托，唯一的办法就是创建新委托并让它引用旧委托的Invoke方法 f&#x3D;c.Invoke;。</p>
<p>但通过C# 4.0添加的对<strong>可变性</strong>的支持，现在可在某些委托类型之间进行引用转换。</p>
<ul>
<li>Action逆变:由于void <code>Action&lt;in T&gt;(T arg)</code>有in类型参数修饰符，所以可将<code>Action&lt;object&gt;</code>类型的委托引用赋给<code>Action&lt;string&gt;</code>类型的变量。适合任何object的Action必定适合任何string串。反之则不然，只适合字符串的行动不适合每个对象。</li>
<li>Func协变:Func系列委托类型对它的返回类型协变，这通过TResult的out类型参数修饰符来指示。所以，<code>Func&lt;string&gt;</code>类型的委托引用可以赋给<code>Func&lt;object&gt;</code>类型的变量。</li>
</ul>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/2EB9BF03-C7BF-4aa7-B550-776AE2A5D7CD.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="Lambda表达式和匿名方法的内部机制"><a href="#Lambda表达式和匿名方法的内部机制" class="headerlink" title="Lambda表达式和匿名方法的内部机制"></a>Lambda表达式和匿名方法的内部机制</h3><p>CLR不知道何谓Lambda表达式（和匿名方法）。相反，编译器遇到匿名方法时，会把它转换成特殊的隐藏类、字段和方法，从而实现你希望的语义。也就是说，C#编译器为这个模式生成实现代码，避免开发者自己去实现。</p>
<h2 id="外部变量捕捉"><a href="#外部变量捕捉" class="headerlink" title="外部变量捕捉"></a>外部变量捕捉</h2><p>在Lambda表达式外部声明的局部变量（包括包容方法的参数）称为该Lambda的外部变量。（this引用虽然技术上说不是变量，但也被视为外部变量。）如果Lambda表达式主体使用一个外部变量，那么就说该变量被该Lambda表达式捕捉。</p>
<p>变量的延长生命:局部变量的生存期一般和它的作用域绑定。一旦控制离开作用域，变量的存储位置就不再有效。但如果从Lambda表达式创建的委托捕捉了外部变量，该委托可能具有比局部变量一般情况下更长（或更短）的生存期。委托每次被调用时，都必须能安全地访问外部变量。在这种情况下，被捕捉的变量的生存期被延长了。这个生存期至少和存活时间最长的委托对象一样长。（也许更长：编译器如何生成代码来延长外部变量生存期是一种实现细节，可能会发生变化。）</p>
<p>c#5.0后，Lambda表达式捕捉变量并总是使用其最新的值——而不是捕捉并保留变量在委托创建时的值。(不适用于for循环,可以赋值给局部变量)</p>
<blockquote>
<p>避免在匿名函数中捕捉循环变量</p>
</blockquote>
<h3 id="CIL实现"><a href="#CIL实现" class="headerlink" title="CIL实现"></a>CIL实现</h3><p>被捕捉的局部变量（comparisonCount）作为实例字段（而非局部变量）实现，从而延长了其生存期。</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/B60724BB-D3D3-4843-8737-7388D9818D80.png" srcset="/img/loading.gif" lazyload><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/FB1C5CD2-9C91-4d1a-A043-C8FA2DBE4B44.png" srcset="/img/loading.gif" lazyload></p>
<p>生成的__LocalsDisplayClass类称为闭包（closure），它是一个数据结构（一个C#类），其中包含一个表达式以及对表达式进行求值所需的变量（C#中的公共字段）。</p>
<h2 id="表达式树"><a href="#表达式树" class="headerlink" title="表达式树"></a>表达式树</h2><p>表达式树是对象，允许传递编译器对Lambda表达式的分析。</p>
<p>转换成表达式树的Lambda表达式对象代表的是对Lambda表达式进行<strong>描述的数据</strong>，而不是编译好的、用于实现匿名函数的代码。由于表达式树代表数据而非编译好的代码，所以能在执行时分析Lambda，用分析得到的数据来构造一个针对数据库执行的查询。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span>构成部分:</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>Person对象的Name属性读取</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>string的ToUpper()调用</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>常量值&quot;OK&quot;</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>相等操作符==</span><br>persons.Where(<br>    person=&gt;person.Name.ToUpper()==<span class="hljs-string">&quot;OK&quot;</span>);<br><span class="hljs-comment">//Where()方法获取这些数据，并通过检查数据和构造SQL查询字符串将这些数据转换成SQL where子句。但表达式树并非只能转换成SQL语句。可构造表达式树计算程序（evaluator），将表达式转换成任意查询语言</span><br></code></pre></td></tr></table></figure>

<p>将<code>(x,y)=&gt;x&gt;y</code>转换成表达式树，只需把它转换成<code>Expression &lt;Func&lt;int, int,bool&gt;&gt;</code></p>
<p>表达式树将ToString()重写</p>
<ul>
<li>表达式树是数据集合，可通过遍历数据将其转换成另一种格式<ul>
<li>PrintNode()方法使用递归证明表达式树由零个或者多个其他表达式树构成。代表Lambda的“根”树通过其Body属性引用Lambda的主体。每个表达式树节点都包含枚举类型ExpressionType的一个NodeType属性，描述了它是哪一种表达式。有多种表达式类型，例如BinaryExpression、ConditionalExpression、LambdaExpression、MethodCall-Expression、ParameterExpression和ConstantExpression。每个类型都从Expression派生。</li>
</ul>
</li>
<li>只有表达式Lambda才能转换成表达式树。</li>
</ul>
<h3 id="作为对象图使用"><a href="#作为对象图使用" class="headerlink" title="作为对象图使用"></a>作为对象图使用</h3><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/74CB7147-EB3E-4df1-A70C-E1B38CEE1FF2.png" srcset="/img/loading.gif" lazyload><br>对象图包含编译器根据Lambda推断出来的所有信息。执行时可利用这些信息创建查询。</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/999DEAE5-51CB-4ec3-A213-BD3A65DDA5CD.png" srcset="/img/loading.gif" lazyload><br>UnaryExpression代表-count这样的表达式。它具有Expession类型的单个子操作数（Operand）。BinaryExpression有两个子表达式：Left和Right。两个类型都通过NodeType属性标识具体的操作符，而且两者都从基类Expression派生。还有其他30多个表达式类型，比如NewExpression、ParameterExpression、MethodCallExpression、LoopExpression等，能表示C#和Visual Basic中的几乎所有表达式。</p>
<h3 id="比较委托和表达式树"><a href="#比较委托和表达式树" class="headerlink" title="比较委托和表达式树"></a>比较委托和表达式树</h3><p>不管转换成委托还是表达式树的Lambda表达式都会在编译时进行全面的语义分析，从而验证其有效性。</p>
<p>编译器能根据查询的集合类型判断是从作为实参提供的Lambda创建委托还是表达式树。</p>
<h2 id="委托实现事件"><a href="#委托实现事件" class="headerlink" title="委托实现事件"></a>委托实现事件</h2><p>委托本身又是一个更大的模式（pattern）的基本单位，该模式称为Publish-Subscribe（发布—订阅）或者Observer（观察者）</p>
<ul>
<li>一个委托值是可以引用一系列方法的，这些方法将顺序调用。这样的委托称为多播委托。<ul>
<li>这样单一事件（比如对象状态的改变）的通知就可以发布给多个订阅者。</li>
</ul>
</li>
</ul>
<h3 id="多播委托实现观察者模式"><a href="#多播委托实现观察者模式" class="headerlink" title="多播委托实现观察者模式"></a>多播委托实现观察者模式</h3><p>一个加热器（Heater）和一个冷却器（Cooler）连接到同一个恒温器（Thermostat）。为控制设备开关需要通知它们温度变化。恒温器将温度变化发布给多个订阅者——也就是加热器和冷却器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//注册订阅</span><br>        Thermostat thermostat = <span class="hljs-keyword">new</span> Thermostat(); <br>        Heater heater = <span class="hljs-keyword">new</span> Heater(<span class="hljs-number">60</span>);<br>        Cooler cooler = <span class="hljs-keyword">new</span> Cooler(<span class="hljs-number">80</span>); <br><br>        <span class="hljs-built_in">string</span> temperature;<br><br>        thermostat.OnTemperatureChange += heater.OnTemperatureChanged; <br>        thermostat.OnTemperatureChange += cooler.OnTemperatureChanged; <br>        Console.Write(<span class="hljs-string">&quot;Enter temperature:&quot;</span>); <br>        temperature = Console.ReadLine();<br><br>        thermostat.CurrentTemperature = <span class="hljs-built_in">int</span>.Parse(temperature);<br>    &#125;<br><br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>发布者<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Thermostat</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _CurrentTemperature;<br>    <span class="hljs-comment">//OnTemperatureChange包含订阅列表</span><br>    <span class="hljs-keyword">public</span> Action&lt;<span class="hljs-built_in">float</span>&gt;? OnTemperatureChange &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> CurrentTemperature<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _CurrentTemperature; &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> != CurrentTemperature)<br>            &#123;<br>                _CurrentTemperature = <span class="hljs-keyword">value</span>;<br>                <span class="hljs-comment">//通知，调用委托。调用注册在内部的订阅方法</span><br>                OnTemperatureChange?.Invoke(<span class="hljs-keyword">value</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>订阅者1<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Cooler</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> Temperature &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cooler</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> temperature</span>)</span><br>    &#123;<br>        Temperature = temperature;<br>    &#125;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>订阅方法<span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTemperatureChanged</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> newTemperature</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (newTemperature &gt; Temperature) &#123; System.Console.WriteLine(<span class="hljs-string">&quot;Cooler: On&quot;</span>); &#125;<br>        <span class="hljs-keyword">else</span> &#123; System.Console.WriteLine(<span class="hljs-string">&quot;Cooler: Off&quot;</span>); &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>订阅者2<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Heater</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heater</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> temperature</span>)</span><br>    &#123;<br>        Temperature = temperature;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> Temperature &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;&#125;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>订阅方法<span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTemperatureChanged</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> newTemperature</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (newTemperature &lt; Temperature)<br>            System.Console.WriteLine(<span class="hljs-string">&quot;Heater: On&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            System.Console.WriteLine(<span class="hljs-string">&quot;Heater: Off&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>要在调用委托前检查它的值是不是空值。<br>要从C# 6.0起在调用Invoke()前使用空条件操作符。</p>
</blockquote>
<p>调用顺序:<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/B98C107D-E3C4-4f66-A7C5-05323788E88F.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="委托操作符"><a href="#委托操作符" class="headerlink" title="委托操作符"></a>委托操作符</h3><ul>
<li><code>+=</code>添加委托到委托链</li>
<li><code>-=</code>删除委托</li>
<li><code>+ -</code>合并委托</li>
<li><code>=</code>替换订阅</li>
</ul>
<p>内部都是<code>System.Delegate.Combine()</code>和<code>System.Delegate.Remove()</code>来分别实现.两个参数都可为<code>null</code></p>
<h3 id="多播委托的内部机制"><a href="#多播委托的内部机制" class="headerlink" title="多播委托的内部机制"></a>多播委托的内部机制</h3><p><code>delegate</code>关键字是派生自<code>System.MulticastDelegate</code>的一个类型的别名。</p>
<p>包含对象引用和方法引用，还包含<code>MulticastDelegate</code>的引用</p>
<p>调用多播委托时，链表中的委托实例被顺序调用。通常，委托按它们添加的顺序调用，但CLI规范并未对此做出规定，而且该顺序可能被覆盖，所以程序员不应依赖特定调用顺序。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>错误处理使对顺序通知的了解变得至关重要。一个订阅者抛出异常，链中的后续订阅者就收不到通知。</p>
<p>为避免该问题，使所有订阅者都能收到通知（不管之前的订阅者有过什么行为），必须手动遍历订阅者列表，并单独调用它们。</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/D77B4FB6-A4B8-44a4-8EC9-2F22CCF4B1E0.png" srcset="/img/loading.gif" lazyload></p>
<p>枚举列表中的每一项以返回单独的订阅者。随后将每个订阅者调用都放到一个try&#x2F;catch块中，就可以先处理好任何出错的情形，再继续循环迭代。AggregateException包装一个异常集合，集合中的异常可通过InnerExceptions属性访问。结果是所有异常都得到报告，同时所有订阅者都不会错过通知。</p>
<h3 id="方法返回值和传引用"><a href="#方法返回值和传引用" class="headerlink" title="方法返回值和传引用"></a>方法返回值和传引用</h3><p>还有一种情形需要遍历委托调用列表而非直接调用一个委托。这种情形涉及的委托要么不返回void，要么具有ref或out参数。在恒温器的例子中，OnTemperatureChange委托是Action<float>类型，它返回void，而且没有ref或out参数。结果是没有数据返回给发布者。这一点相当重要，因为调用委托可能将一个通知发送给多个订阅者。如每个订阅者都返回值，就无法确定应该使用哪个订阅者的返回值。</p>
<p>如修改OnTemperatureChange，让它不是返回void，而是返回枚举值，指出设备是否因温度的改变而启动，新的委托就应该是<code>Func&lt;float, Status&gt;</code>，其中Status是包含元素On和Off的枚举。因为所有订阅者方法都要使用和委托一样的方法签名，所以都必须返回状态值。由于OnTemperatureChange可能和一个委托链对应，所以需要遵循和错误处理一样的模式。也就是说，必须使用GetInvocationList()方法遍历每一个委托调用列表来获取每一个单独的返回值。类似地，使用ref和out参数的委托类型也需特别对待。虽然极少数情况下需采取这样的做法，但一般原则是通过只返回void来彻底避免该情形。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h3><p>委托结构中存在的缺陷可能造成程序员在不经意中引入bug。问题和封装有关，事件的订阅和发布都不能得到充分的控制。使用事件的好处是，只有直接持有一个事件对象的类可以调用这个事件对象，其他的类只能使用+&#x3D;或-&#x3D;向这个事件对象添加或删除对事件的订阅。</p>
<ol>
<li><p>对订阅的封装:</p>
<p>event关键字的作用就是提供额外的封装,取消为包容类外部的对象提供对赋值操作符的支持</p>
</li>
<li><p>对发布的封装</p>
<p>事件确保只有包容类才能触发时间通知</p>
</li>
</ol>
<p>虽然看起来像是一个字段修饰符，但event定义了新的成员类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Thermostat</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> _CurrentTemperature;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> CurrentTemperature<br>    &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TemperatureArgs</span> : <span class="hljs-title">System.EventArgs</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TemperatureArgs</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> newTemperature</span>)</span><br>        &#123;<br>            NewTemperature = newTemperature;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> NewTemperature<br>        &#123;<br>            <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//public因为需要增强封装，而不是让字段变成公共来削弱封装</span><br>    <span class="hljs-comment">//event提供了所需的全部封装</span><br>    <span class="hljs-comment">//Action&lt;float&gt;替换成新的委托类型EventHandler&lt;TemperatureArgs&gt;，这是一个CLR类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler&lt;TemperatureArgs&gt; OnTemperatureChange = <span class="hljs-built_in">delegate</span> &#123;<span class="hljs-comment">/*一个空白委托，代表包含零个订阅者的一个集合.通过赋值空白委托，就可引发事件而不必检查是否有任何订阅者。当然，如委托存在被重新赋值为null的任何可能，那么仍需进行null值检查。但因为event关键字限制赋值只能在类中发生，所以要重新对委托进行赋值，只能在类中进行。如果从未在类中赋过null值，则不必在每次调用委托时检查null*/</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>添加event关键字后，会禁止为公共委托字段使用赋值操作符（比如<code>thermostat.OnTemperatureChange=cooler.OnTemperatureChanged</code>）</li>
<li>只有包容类才能调用向所有订阅者发出通知的委托（例如，不允许在类的外部执行<code>thermostat.OnTemperature-Change (42)</code>）</li>
<li>event关键字限制赋值只能在类中发生</li>
</ul>
<h3 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h3><ul>
<li><p>事件的返回是CLR类型。声明准备作为事件使用的委托时，约定就是传递这些类型两个参数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EventHandler</span>&lt;<span class="hljs-title">TEventArgs</span>&gt;(<span class="hljs-params"><span class="hljs-built_in">object</span> sender,TEventArgs e</span>)</span>;<br></code></pre></td></tr></table></figure>

<ol>
<li>sender代表发送者.<br> object类型,静态事件则为null<br> 辨别是哪个发送者</li>
<li>e代表事件数据.<br> TemperatureArgs类型从EventArgs派生.<br> 唯一重要属性是Empty指出没有事件数据<br> 如因状态改变而引发事件，常见编程模式是连同新值传递旧值，这样可控制哪些状态变化是被允许的。</li>
</ol>
</li>
</ul>
<blockquote>
<p>调用委托前验证null<br>非静态事件要将发送事件的类本身作为sender的值传递<br>静态事件null<br>不要为eventArgs传递null值<br>要为TEventArgs使用System.EventArgs类型或者它的派生类型<br>考虑使用事件参数，除非确定事件永远不需要携带任何数据。</p>
</blockquote>
<h3 id="泛型和委托"><a href="#泛型和委托" class="headerlink" title="泛型和委托"></a>泛型和委托</h3><p>C# 2.0和之后使用事件的大多数情形中，都没必要声明自定义委托数据类型。</p>
<blockquote>
<p>考虑为事件处理程序使用<code>System.EventHandler&lt;T&gt;</code>而非手动创建新的委托类型，除非必须用自定义类型的参数名加以澄清。</p>
</blockquote>
<h3 id="事件的内部机制"><a href="#事件的内部机制" class="headerlink" title="事件的内部机制"></a>事件的内部机制</h3><p>事件限制外部类只能使用+&#x3D;或-&#x3D;向发布者添加或删除对事件的订阅。此外，还禁止除包容类之外的其他任何类调用事件。</p>
<p>编译器将event大致翻译为私有的委托和公开的add与remove方法和公开的event前缀的类似属性(add+remove)的成员</p>
<p>另外要注意，最终的CIL代码仍然保留了event关键字。换言之，事件是CIL代码能够显式识别的一样东西，并非只是一个C#构造。在CIL代码中保留等价的event关键字，所有语言和编辑器都能将事件识别为一个特殊的类成员并正确处理。</p>
<h3 id="实现自定义事件"><a href="#实现自定义事件" class="headerlink" title="实现自定义事件"></a>实现自定义事件</h3><p>可为事件添加类似属性的addheremove操作.<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669162021591.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>开发者不能依赖Combine()方法中参数的顺序来断定事件实际接收的顺序。</p>
</blockquote>
<h1 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h1><h2 id="支持标准查询操作符的集合接口"><a href="#支持标准查询操作符的集合接口" class="headerlink" title="支持标准查询操作符的集合接口"></a>支持标准查询操作符的集合接口</h2><p>使用例子1</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Patent</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Title &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> YearofPublication &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? ApplicationNumber &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span>[] InventorIds &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Patent</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">string</span> title, <span class="hljs-built_in">string</span> yearofPublication, <span class="hljs-built_in">long</span>[] inventorIds</span>)</span><br>    &#123;<br>        Title = title ??<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(title));<br>        YearofPublication = yearofPublication ??<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(yearofPublication));<br>        InventorIds = inventorIds ??<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(inventorIds));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Title&#125;</span> (<span class="hljs-subst">&#123;YearofPublication &#125;</span>)&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Inventor</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Id &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> City &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> State &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Country &#123; <span class="hljs-keyword">get</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Inventor</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">string</span> name, <span class="hljs-built_in">string</span> city, <span class="hljs-built_in">string</span> state, <span class="hljs-built_in">string</span> country, <span class="hljs-built_in">int</span> id</span>)</span><br>    &#123;<br>        Name = name ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(name));<br>        City = city ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(city));<br>        State = state ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(state));<br>        Country = country ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(country));<br>        Id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>        &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> (<span class="hljs-subst">&#123;City &#125;</span>,<span class="hljs-subst">&#123;State &#125;</span>)&quot;</span>;<br>        &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        IEnumerable&lt;Patent&gt; patents = PatentData.Patents;<br>        Print(patents);<br>        Console.WriteLine();<br>        IEnumerable&lt;Inventor&gt; inventors = PatentData.Inventors;<br>        Print(inventors);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">IEnumerable&lt;T&gt; items</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (T item <span class="hljs-keyword">in</span> items)<br>        &#123;<br>            Console.WriteLine(item);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PatentData</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> Inventor[] Inventors = <span class="hljs-keyword">new</span> Inventor[]<br>        &#123;<br>            <span class="hljs-keyword">new</span> Inventor(<br>                <span class="hljs-string">&quot;Benjamin Franklin&quot;</span>,<span class="hljs-string">&quot;Philadelphia&quot;</span>,<br>                <span class="hljs-string">&quot;PA&quot;</span>, <span class="hljs-string">&quot;USA&quot;</span>,<span class="hljs-number">1</span>),<br>            <span class="hljs-keyword">new</span> Inventor(<br>                <span class="hljs-string">&quot;Orville wright&quot;</span>,<span class="hljs-string">&quot;Kitty Hawk&quot;</span>,<br>                <span class="hljs-string">&quot;NC&quot;</span>, <span class="hljs-string">&quot;USA&quot;</span>,<span class="hljs-number">2</span>),<br>            <span class="hljs-keyword">new</span> Inventor(<br>                <span class="hljs-string">&quot;wilbur wright&quot;</span>,<span class="hljs-string">&quot;Kitty Hawk&quot;</span>,<br>                <span class="hljs-string">&quot;NC&quot;</span>,<span class="hljs-string">&quot;USA&quot;</span>,<span class="hljs-number">3</span>),<br>            <span class="hljs-keyword">new</span> Inventor(<br>                <span class="hljs-string">&quot;Samuel Morse&quot;</span>,<span class="hljs-string">&quot;New York&quot;</span>,<br>                <span class="hljs-string">&quot;NY&quot;</span>,<span class="hljs-string">&quot;USA&quot;</span>,<span class="hljs-number">4</span>),<br>            <span class="hljs-keyword">new</span> Inventor(<br>                <span class="hljs-string">&quot;George Stephenson&quot;</span>,<span class="hljs-string">&quot;Wylam&quot;</span>,<br>                <span class="hljs-string">&quot;Northumberland&quot;</span>,<span class="hljs-string">&quot;UK&quot;</span>,<span class="hljs-number">5</span>),<br>            <span class="hljs-keyword">new</span> Inventor(<br>                <span class="hljs-string">&quot;John Michaelis&quot;</span>,<span class="hljs-string">&quot;Chicago&quot;</span>,<br>                <span class="hljs-string">&quot;IL&quot;</span>,<span class="hljs-string">&quot;USA&quot;</span>,<span class="hljs-number">6</span>),<br>            <span class="hljs-keyword">new</span> Inventor(<br>                <span class="hljs-string">&quot;Mary Phelps Jacob&quot;</span>,<span class="hljs-string">&quot;New York&quot;</span>,<br>                <span class="hljs-string">&quot;NY&quot;</span>,<span class="hljs-string">&quot;USA&quot;</span>,<span class="hljs-number">7</span>)<br>        &#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> Patent[] Patents = <span class="hljs-keyword">new</span> Patent[]<br>        &#123;<br>            <span class="hljs-keyword">new</span> Patent(<span class="hljs-string">&quot;Bifocals&quot;</span>,<span class="hljs-string">&quot;1784&quot;</span>,<br>                inventorIds:<span class="hljs-keyword">new</span> <span class="hljs-built_in">long</span>[]&#123;<span class="hljs-number">1</span> &#125;),<br>            <span class="hljs-keyword">new</span> Patent(<span class="hljs-string">&quot;Phonograph&quot;</span>, <span class="hljs-string">&quot;1877&quot;</span>,<br>                inventorIds: <span class="hljs-keyword">new</span> <span class="hljs-built_in">long</span>[]&#123;<span class="hljs-number">1</span> &#125;),<br>            <span class="hljs-keyword">new</span> Patent(<span class="hljs-string">&quot;Kinetoscope&quot;</span>, <span class="hljs-string">&quot;1888&quot;</span>,<br>                inventorIds: <span class="hljs-keyword">new</span> <span class="hljs-built_in">long</span>[]&#123;<span class="hljs-number">1</span> &#125;),<br>            <span class="hljs-keyword">new</span> Patent(<span class="hljs-string">&quot;Electrical Telegraph&quot;</span>, <span class="hljs-string">&quot;1837&quot;</span>,<br>                inventorIds: <span class="hljs-keyword">new</span> <span class="hljs-built_in">long</span>[]&#123;<span class="hljs-number">4</span> &#125;),<br>            <span class="hljs-keyword">new</span> Patent(<span class="hljs-string">&quot;Flying Machine&quot;</span>, <span class="hljs-string">&quot;1903&quot;</span>,<br>                inventorIds: <span class="hljs-keyword">new</span> <span class="hljs-built_in">long</span>[]&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;),<br>            <span class="hljs-keyword">new</span> Patent(<span class="hljs-string">&quot;Steam Locomotive&quot;</span>, <span class="hljs-string">&quot;1815&quot;</span>,<br>                inventorIds: <span class="hljs-keyword">new</span> <span class="hljs-built_in">long</span>[]&#123;<span class="hljs-number">5</span> &#125;),<br>            <span class="hljs-keyword">new</span> Patent(<span class="hljs-string">&quot;Droplet Deposition Apparatus&quot;</span>, <span class="hljs-string">&quot;1989&quot;</span>,<br>                inventorIds: <span class="hljs-keyword">new</span> <span class="hljs-built_in">long</span>[]&#123;<span class="hljs-number">6</span> &#125;),<br>            <span class="hljs-keyword">new</span> Patent(<span class="hljs-string">&quot;Backless Brassiere&quot;</span>, <span class="hljs-string">&quot;1914&quot;</span>,<br>                inventorIds: <span class="hljs-keyword">new</span> <span class="hljs-built_in">long</span>[]&#123;<span class="hljs-number">7</span> &#125;)<br>        &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用案例2:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Department</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Id &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Department</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">long</span> id</span>)</span><br>    &#123;<br>        Id = id;<br>        Name = name ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(name));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span> =&gt; Name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Title &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> DepartmentId &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-built_in">string</span> name, <span class="hljs-built_in">string</span> title, <span class="hljs-built_in">int</span> departmentId</span>)</span><br>    &#123;<br>        Name = name ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(name));<br>        Title = title ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(title));<br>        DepartmentId = departmentId;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span> =&gt; <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span>(<span class="hljs-subst">&#123;Title&#125;</span>)&quot;</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CorporateData</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> Department[] Departments =<br>        <span class="hljs-keyword">new</span> Department[]<br>        &#123;<br>        <span class="hljs-keyword">new</span> Department(<span class="hljs-string">&quot;Corporate&quot;</span>, <span class="hljs-number">0</span>),<br>        <span class="hljs-keyword">new</span> Department(<span class="hljs-string">&quot;Human Resources&quot;</span>, <span class="hljs-number">1</span>),<br>        <span class="hljs-keyword">new</span> Department(<span class="hljs-string">&quot;Engineering&quot;</span>, <span class="hljs-number">2</span>),<br>        <span class="hljs-keyword">new</span> Department(<span class="hljs-string">&quot;Information Technology&quot;</span>, <span class="hljs-number">3</span>),<br>        <span class="hljs-keyword">new</span> Department(<span class="hljs-string">&quot;Philanthropy&quot;</span>, <span class="hljs-number">4</span>),<br>        <span class="hljs-keyword">new</span> Department(<span class="hljs-string">&quot;Marketing&quot;</span>, <span class="hljs-number">5</span>),<br>        &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> Employee[] Employees =<br>        <span class="hljs-keyword">new</span> Employee[]<br>        &#123;<br>            <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;Mark Michaelis&quot;</span>,<span class="hljs-string">&quot;Chief Computer Nerd&quot;</span>,<span class="hljs-number">0</span>),<br>            <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;Michael Stokesbary&quot;</span>,<span class="hljs-string">&quot;Senior Computer Wizard&quot;</span>,<span class="hljs-number">2</span>),<br>            <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;Brian Jones&quot;</span>,<span class="hljs-string">&quot;Enterprise Integration Guru&quot;</span>,<span class="hljs-number">2</span>),<br>            <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;Anne Beard&quot;</span>,<span class="hljs-string">&quot;HR Director&quot;</span>,<span class="hljs-number">1</span>),<br>            <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;Pat Dever&quot;</span>,<span class="hljs-string">&quot;Enterprise Architect&quot;</span>,<span class="hljs-number">3</span>),<br>            <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;Kevin Bost&quot;</span>,<span class="hljs-string">&quot;Programmer Extraordinaire&quot;</span>,<span class="hljs-number">2</span>),<br>            <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;Thomas Heavey&quot;</span>,<span class="hljs-string">&quot;Software Architect&quot;</span>,<span class="hljs-number">2</span>),<br>            <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;Eric Edmonds&quot;</span>,<span class="hljs-string">&quot;Philanthropy Coordinator&quot;</span>,<span class="hljs-number">4</span>)<br>        &#125;;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        IEnumerable&lt;Department&gt; departments = CorporateData.Departments;<br>        Print(departments);<br>        Console.WriteLine();<br>        IEnumerable&lt;Employee&gt; employees = CorporateData.Employees;<br>        Print(employees);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">IEnumerable&lt;T&gt; items</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (T item <span class="hljs-keyword">in</span> items)<br>            Console.WriteLine(item);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="集合初始化器"><a href="#集合初始化器" class="headerlink" title="集合初始化器"></a>集合初始化器</h3><p>和数组声明类似的方式，在实例化期间用一组初始成员构造集合.<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669162527817.png" srcset="/img/loading.gif" lazyload alt="集合"><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669162552171.png" srcset="/img/loading.gif" lazyload alt="字典"><br>需要<br>实现<code>ICollection&lt;T&gt;</code>接口确保有Add()</p>
<h3 id="IEnumerable使类成为集合"><a href="#IEnumerable使类成为集合" class="headerlink" title="IEnumerable使类成为集合"></a>IEnumerable使类成为集合</h3><p>集合本质是个类，实现IEnumerable接口，包含遍历集合的必须方法</p>
<h3 id="foreach-1"><a href="#foreach-1" class="headerlink" title="foreach"></a>foreach</h3><p>对于数组,编译器将foreach翻译为等价的for循环</p>
<p>但是对于集合,很多类型不支持按索引检索元素或者未知长度</p>
<ul>
<li>迭代器模式:仅需知道第一个和下一个</li>
</ul>
<p>IEnumerator接口 MoveNext()移动到下一个元素返回布尔 Currnet当前元素 Reset()不常用的抛出异常</p>
<ul>
<li><p>状态共享<br>多线程中两个循环交错遍历同一个集合.集合必须维持当前元素的一个状态指示器，确保调用MoveNext()时能正确定位下一个元素。<br>为解决该问题，集合类不直接支持<code>IEnumerator&lt;T&gt;</code>和<code>IEnumerator</code>接口，而是实现<code>IEnumerable&lt;T&gt;</code>的GetEnumerator()。此时不是集合来维持状态,而是通常是嵌套类的不同类来支持<code>IEnumerator&lt;T&gt;</code>负责维护循环遍历的枚举(相当于游标,游标间独立).<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669163632220.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>清理状态<br>退出循环后对状态进行清理。<code>IEnumerator&lt;T&gt;</code>接口从<code>IDisposable</code>派生.可使用using进行处理:<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669163801390.png" srcset="/img/loading.gif" lazyload>翻译为<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669163830538.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<blockquote>
<p>foreach不一定要实现IEnumerable。编译器采用称为“Duck typing”(只需实现Quack()方法，不需要实现IDuck接口)的概念，也就是查找会返回“包含Current属性和MoveNext()方法的一个类型”的GetEnumerator()方法。Duck typing按名称查找方法，而不依赖接口或显式方法调用。当Duck typing找不到可枚举模式的恰当实现时，编译器才会检查集合是否实现了接口</p>
</blockquote>
<h3 id="foreach循环内不要修改集合"><a href="#foreach循环内不要修改集合" class="headerlink" title="foreach循环内不要修改集合"></a>foreach循环内不要修改集合</h3><p>编译器禁止对foreach变量（number）赋值</p>
<p>在foreach循环执行期间，集合中的元素计数不能变，集合项本身也不能修改。</p>
<p>System.InvalidOperationException异常</p>
<h3 id="标准查询操作符"><a href="#标准查询操作符" class="headerlink" title="标准查询操作符"></a>标准查询操作符</h3><p>任何类型在实现<code>IEnumerable&lt;T&gt;</code>之后，都有超过50个方法可供使用，其中还不包括重载版本。而为了享受到所有这一切，除了GetEnumerator()之外，根本不需要显式实现其他任何方法。附加功能在System.Linq.Enumerable类中定义，称为标准查询操作符</p>
<h4 id="Where-筛选"><a href="#Where-筛选" class="headerlink" title="Where()筛选"></a>Where()筛选</h4><p>获取一个实参并返回Boolean值的委托表达式称为谓词</p>
<p>集合的Where()方法依据谓词来确定筛选条件。</p>
<p>垂直方向上筛选集合(减少集合项数量)</p>
<p>Where()方法的结果是一个<strong>新</strong>对象，它封装了根据一个给定谓词对一个给定序列进行筛选的操作。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">patents=patents.Where(<br>            patent=&gt;patent.YearofPublication.StartsWith(<span class="hljs-string">&quot;18&quot;</span>));<br></code></pre></td></tr></table></figure>

<ul>
<li>在Where情况下,表达式传给集合,在遍历时才执行</li>
</ul>
<h4 id="Select-投射"><a href="#Select-投射" class="headerlink" title="Select()投射"></a>Select()投射</h4><p>可以接着对这些数据进行转换</p>
<p>水平方向上减小集合规模(减少列的数量)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> items=patents.Select(<br>            pantent=&gt;pantent.ToString());<br></code></pre></td></tr></table></figure>

<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669166522835.png" srcset="/img/loading.gif" lazyload alt="和new来转换成对象"></p>
<p>和元组:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> fileList=Directory.GetFiles(<span class="hljs-string">@&quot;D:\_blog\blogs\hexoblog\source\_posts\skill&quot;</span>,<span class="hljs-string">&quot;*.*&quot;</span>);<br><span class="hljs-keyword">var</span> items = fileList.Select(<br>    file =&gt; &#123;<br>        <span class="hljs-keyword">var</span> fileInfo=<span class="hljs-keyword">new</span> FileInfo(file);<br>        <span class="hljs-keyword">return</span>(<br>            FileName:fileInfo.Name,<br>            Size:fileInfo.Length<br>        );<br>    &#125;);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> items)<br>&#123;<br>    Console.WriteLine(element);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="并行运行LINQ查询"><a href="#并行运行LINQ查询" class="headerlink" title="并行运行LINQ查询"></a>并行运行LINQ查询</h4><p><code>AsParallel()</code>支持多线程的多核处理器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> items = fileList.AsParallel().Select(<br>    file =&gt; &#123;<br>        <span class="hljs-keyword">var</span> fileInfo=<span class="hljs-keyword">new</span> FileInfo(file);<br>        <span class="hljs-keyword">return</span>(<br>            FileName:fileInfo.Name,<br>            Size:fileInfo.Length<br>        );<br>    &#125;);<br></code></pre></td></tr></table></figure>

<p>“运行时”一边遍历fileList中的数据项，一边返回结果对象。</p>
<blockquote>
<p>并行执行可能引入竞态条件：一个线程上的一个操作可能会与一个不同的线程上的一个操作混合，造成数据被破坏。为避免该问题，需要向多个线程共享访问的数据应用同步机制，在必要时强制保证操作的原子性。但同步本身可能引入死锁，造成执行被“冻结”，使并行编程变得更复杂。</p>
</blockquote>
<h4 id="Count-计数"><a href="#Count-计数" class="headerlink" title="Count()计数"></a>Count()计数</h4><p>统计所有元素的数量（无参）或者获取一个谓词作为参数，只对谓词表达式标识的数据项进行计数。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">Console.WriteLine(<span class="hljs-string">$&quot;Patent Count:<span class="hljs-subst">&#123;patents.Count()&#125;</span>&quot;</span>);<br>Console.WriteLine(<span class="hljs-string">$@&quot;Patent Count in 1800s:<span class="hljs-subst">&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">    patents.Count(patent=&gt;</span></span><br><span class="hljs-subst"><span class="hljs-string">        patent.YearofPublication.StartsWith(<span class="hljs-string">&quot;18&quot;</span>))</span></span><br><span class="hljs-subst"><span class="hljs-string">&#125;</span>&quot;</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>有Count属性的集合应首选属性，而不要用LINQ的Count()方法（这是一个容易忽视的差异）</p>
</blockquote>
<blockquote>
<p>计数的目的只是为了看这个计数是否大于0，使用Any()检查是否有项时</p>
</blockquote>
<h4 id="推迟执行"><a href="#推迟执行" class="headerlink" title="推迟执行"></a>推迟执行</h4><blockquote>
<p>任何谓词通常都只应做一件事情：对一个条件进行求值。它不应该有任何“副作用”(修改值之类)</p>
</blockquote>
<ul>
<li>Lambda表达式是可以四处传递的委托（方法引用）。在LINQ和标准查询操作符的背景下，每个Lambda表达式都构成了要执行的总体查询的一部分。</li>
</ul>
<p>Lambda表达式中的代码只有在Lambda表达式被调用时才开始执行。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669168963909.png" srcset="/img/loading.gif" lazyload><br>查询对象代表的是查询而非结果。向查询要结果时，整个查询都会执行（甚至可能是再次执行），因为查询对象不确定结果和上次执行的结果（如果存在的话）是否一样。</p>
<ol>
<li>foreach触发执行,每个MoveNext()都会为集合中的每一项指向Lambda</li>
<li>Enumerable的Count()再次为每一项触发Lambda(所以建议使用Count属性)</li>
<li>调用ToArray()等会为集合中的每个元素计算Lambda表达式的值,同时生成快照。</li>
</ol>
<blockquote>
<p>要避免反复执行，一个查询在执行之后，有必要把它获取的数据缓存起来。为此，可以使用一个“ToXXX”方法</p>
</blockquote>
<h4 id="Orderby-和ThenBy-排序"><a href="#Orderby-和ThenBy-排序" class="headerlink" title="Orderby()和ThenBy()排序"></a>Orderby()和ThenBy()排序</h4><p>OrderBy()只获取一个Lambda表达式，该表达式标识了要据此进行排序的键。<br>要依据第二个列来排序，需使用一个不同的方法ThenBy()。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">IEnumerable&lt;Patent&gt; items;<br>        Patent[] patents=PatentData.Patents;<br>        items=patents.OrderBy(<br>            patent=&gt;patent.YearofPublication).ThenBy(<br>            patent=&gt;patent.Title);<br>        Print(items);<br></code></pre></td></tr></table></figure>

<ul>
<li><p>如重复调用OrderBy()，会撤销上一个OrderBy()的工作，只有最后一个OrderBy()的keySelector才真正起作用。</p>
</li>
<li><p>要等到开始访问集合中的成员时，才会实际开始排序，那时整个查询都会被处理.因为无法确定是否已获得第一项</p>
</li>
<li><p>如果先调用OrderBy()，那么在遍历集合时，会调用对应的keySelector Lambda表达式。如果接着调用ThenBy()，会导致那个OrderBy()的keySelector被再次调用。</p>
</li>
</ul>
<p>OrderByDescending()升序和ThenByDescending()降序</p>
<h4 id="Join-内部联接"><a href="#Join-内部联接" class="headerlink" title="Join()内部联接"></a>Join()内部联接</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        IEnumerable&lt;Department&gt; departments = CorporateData.Departments;<br>        IEnumerable&lt;Employee&gt; employees = CorporateData.Employees;<br><br>        IEnumerable&lt;(<span class="hljs-built_in">int</span> Id,<span class="hljs-built_in">string</span> Name,<span class="hljs-built_in">string</span> Title,Department Department)&gt; items=employees.Join(<br>            departments,<br>            employee=&gt;employee.DepartmentId,<br>            department=&gt;department.Id,<br>            (employee,department)=&gt;(<br>                employee.Id,<br>                employee.Name,<br>                employee.Title,<br>                department<br>            ));<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> items)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;element.Name&#125;</span>(<span class="hljs-subst">&#123;element.Title&#125;</span>)&quot;</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;\t&quot;</span>+element.Department);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">IEnumerable&lt;T&gt; items</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (T item <span class="hljs-keyword">in</span> items)<br>            Console.WriteLine(item);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669171181935.png" srcset="/img/loading.gif" lazyload alt="运行结果"></p>
<ul>
<li>第一个参数inner指定要连接到的集合</li>
<li>第二个参数指定外键</li>
<li>第三个参数指定键</li>
<li>最后的参数指定最终要选择的结果项</li>
</ul>
<p>生成笛卡尔积</p>
<ul>
<li><p>GroupBy()分组<br>返回<code>IGrouping&lt;TKey, TElement&gt;</code><br>需要属性指定依据的键</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> <span class="hljs-keyword">group</span>=items.GroupBy((employee)=&gt;employee.Department.Id);<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="GroupJoin-一对多"><a href="#GroupJoin-一对多" class="headerlink" title="GroupJoin()一对多"></a>GroupJoin()一对多</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#">IEnumerable&lt;(<span class="hljs-built_in">long</span> Id,<span class="hljs-built_in">string</span> Name,IEnumerable&lt;Employee&gt; Employees)&gt; items=departments.GroupJoin(<br>          employees,<br>          department =&gt; department.Id,<br>          employee=&gt;employee.DepartmentId,<br>          (department,departmentEmployees)=&gt;(<br>              department.Id,<br>              department.Name,<br>              departmentEmployees<br>          ));<br>      <span class="hljs-keyword">foreach</span> ((_,<span class="hljs-built_in">string</span> name,IEnumerable&lt;Employee&gt; employeeCollection) <span class="hljs-keyword">in</span> items)<br>      &#123;<br>          Console.WriteLine(name);<br>          <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> employee <span class="hljs-keyword">in</span> employeeCollection)<br>          &#123;<br>              Console.WriteLine(<span class="hljs-string">&quot;\t&quot;</span> + employee);<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669172173843.png" srcset="/img/loading.gif" lazyload><br>显示一个部门的所有员工的集合，而不是为每个“部门–员工”关系都创建一个元组。</p>
<p>用第二个类型参数（<code>IEnumerable&lt;Employee&gt;</code>）将每个部门的员工集合投射到结果的部门元组中。<br>最后一个元组参数Lambda表达式的类型是<code>Func&lt;Department, IEnumerable&lt;Employee&gt;, (long Id, string Name, IEnumerable &lt;Employee&gt;Employees)&gt;</code></p>
<blockquote>
<p>和Join()不同，SQL没有与GroupJoin()等价的东西</p>
</blockquote>
<h4 id="GroupJoin-实现外部连接"><a href="#GroupJoin-实现外部连接" class="headerlink" title="GroupJoin()实现外部连接"></a>GroupJoin()实现外部连接</h4><p>前面描述的内部联接称为同等联接（equi-joins），因为它们基于同等的键求值——只有在两个集合中都有对象时，它们的记录才会出现在结果集中。但在某些情况下，即使对应的对象不存在，也有必要创建一条记录。空部门也应该显示。</p>
<p>组合使用GroupJoin()、SelectMany()和DefaultIfEmpty()来实现</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> items = departments.GroupJoin(<br>            employees,<br>            department =&gt; department.Id,<br>            employee =&gt; employee.DepartmentId,<br>            (department, departmentEmployees) =&gt; <span class="hljs-keyword">new</span><br>            &#123;<br>                department.Id,<br>                department.Name,<br>                Employees = departmentEmployees<br>            &#125;).SelectMany(<br>                departmentRecord =&gt;<br>                    departmentRecord.Employees.DefaultIfEmpty(),<br>                    (departmentRecord, employee) =&gt; <span class="hljs-keyword">new</span><br>                    &#123;<br>                        departmentRecord.Id,<br>                        departmentRecord.Name,<br>                        departmentRecord.Employees<br>                    &#125;).Distinct();<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> items)<br>        &#123;<br>            Console.WriteLine(item.Name);<br>            <span class="hljs-keyword">foreach</span> (Employee employee <span class="hljs-keyword">in</span> item.Employees)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;/t&quot;</span> + employee);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669172653535.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="SelectMany"><a href="#SelectMany" class="headerlink" title="SelectMany()"></a>SelectMany()</h4><p>处理集合的集合<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669172949087.png" srcset="/img/loading.gif" lazyload><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669172962317.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>Select()会返回两个球员数组，每个都对应原始集合中的球员数组。Select()可以一边投射一边转换，但项的数量不会发生改变。</li>
<li>SelectMany()遍历由Lambda表达式（之前由Select()选择的数组）标识的每一项，并将每一项都放到一个新集合中。新集合整合了子集合中的所有项。所以，不像Select()那样返回两个球员数组，SelectMany()是将选择的每个数组都整合起来，把其中的项整合到一个集合中</li>
</ul>
<p>简单例子:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span>[] text =&#123; <span class="hljs-string">&quot;Zhou Jing&quot;</span>,<span class="hljs-string">&quot;walking in&quot;</span>,<span class="hljs-string">&quot;the sideway&quot;</span> &#125;;<br><br><span class="hljs-keyword">var</span> tokens=text.Select(s =&gt; s.Split());<br><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span>[] line <span class="hljs-keyword">in</span> tokens)<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> token <span class="hljs-keyword">in</span> line)<br>        Console.Write(<span class="hljs-string">&quot;&#123;0&#125;-&quot;</span>, token);<br><br>Console.WriteLine();<br><br><span class="hljs-keyword">var</span> tokens2=text.SelectMany(s=&gt;s.Split(<span class="hljs-string">&#x27; &#x27;</span>));<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> token <span class="hljs-keyword">in</span> tokens2)<br>&#123;<br>    Console.Write(<span class="hljs-string">&quot;&#123;0&#125;-&quot;</span>,token);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果使用Select()，那么获得的tokens是一个string[]数组，还需遍历每个string[]，才能解析出其中的string。相反，如换用SelectMany()，不仅代码量减少了，也更容易理解.</p>
<h4 id="更多标准查询操作符"><a href="#更多标准查询操作符" class="headerlink" title="更多标准查询操作符"></a>更多标准查询操作符</h4><p>都是推迟执行<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669173321788.png" srcset="/img/loading.gif" lazyload><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669173347460.png" srcset="/img/loading.gif" lazyload><br>所有API调用都不需要Lambda表达式。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669173383590.png" srcset="/img/loading.gif" lazyload><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669173438333.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="IQuerable-lt-T-gt-的Queryable扩展"><a href="#IQuerable-lt-T-gt-的Queryable扩展" class="headerlink" title="IQuerable&lt;T&gt;的Queryable扩展"></a><code>IQuerable&lt;T&gt;</code>的<code>Queryable</code>扩展</h3><p><code>IQueryable&lt;T&gt;</code>从<code>IEnumerable&lt;T&gt;</code>派生.扩展方法无法继承.但是有类似的扩展类<code>Queryable</code>添加了全部方法</p>
<p>可通过它实现自定义的LINQ Provider（LINQ提供程序）。LINQ Provider将表达式分解成各个组成部分。一经分解，表达式就可转换成另一种语言，可序列化以便在远程执行，可通过异步执行模式来注入，等等。简单地说，LINQ Provider为标准集合API提供了“解释”机制。利用这种潜力无限的功能，可注入与查询和集合有关的行为。</p>
<p>通过这种类型的表达式，程序语言可轻松协调“面向对象编程”和“关系数据库”。</p>
<p>除非调用GetEnumerator()（甚至MoveNext()），否则不会发生真正的数据获取操作。</p>
<p>应避免因调用Count()或foreach而不经意地造成对集合的重复遍历。</p>
<h3 id="匿名类型对于LINQ"><a href="#匿名类型对于LINQ" class="headerlink" title="匿名类型对于LINQ"></a>匿名类型对于LINQ</h3><p><code>new&#123;&#125;</code></p>
<p>使用元组后,匿名类型可以功成身退</p>
<p>匿名类型纯粹是一项C#语言功能，不是“运行时”中的新类型。编译器遇到匿名类型时，会自动生成CIL类，其属性对应于在匿名类型声明中命名的值和数据类型。</p>
<p>将匿名类型赋给隐式类型的变量，在为局部变量生成的CIL代码中，它的数据类型就是编译器生成的类型。</p>
<h3 id="查询表达式的LINQ"><a href="#查询表达式的LINQ" class="headerlink" title="查询表达式的LINQ"></a>查询表达式的LINQ</h3><p>开发者经常对集合进行筛选来删除不想要的项，以及对集合进行投射将其中的项变成其他形式。</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669186647938.png" srcset="/img/loading.gif" lazyload alt="筛选出非上下文关键字"></p>
<ul>
<li>查询表达式总是以“from子句”开始，以“select子句”或者“group…by子句”结束。</li>
<li>from子句中的标识符word称为范围变量,代表集合中的每一项。类似于foreach循环变量代表集合中的每一项</li>
</ul>
<p>模仿SQL但是从from开始是为了IDE的智能感知</p>
<p>from指定集合where筛选select描述结果</p>
<h4 id="投射"><a href="#投射" class="headerlink" title="投射"></a>投射</h4><p>表达式结果是<code>IEnumerable&lt;T&gt;</code>或<code>IQueryable&lt;T&gt;</code>类型的集合.T由select或groupby的类型推算</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669187030349.png" srcset="/img/loading.gif" lazyload><br>假如数据量非常大，而且检索这些数据的代价非常高（例如要通过Internet从一台远程计算机上获取），那么像这样在“水平”方向上投射，从而减少与集合中每一项关联的数据量，效率的提升将非常明显。使用元组，执行查询时可以不必获取全部数据，而是只在集合中存储和获取需要的数据</p>
<p>除非代码开始遍历selection中的值，否则无论投射、筛选，还是from子句之后的一切都不会执行</p>
<ul>
<li><p>推迟执行的主题，同样的道理也适用于查询表达式</p>
</li>
<li><p>推迟执行通过委托和表达式树来实现。<br>  委托允许创建和操纵方法引用，方法含有可在以后调用的表达式。类似地，可利用表达式树创建和操纵与表达式有关的信息，这种表达式能在以后检查和处理。<br>  where子句的谓词表达式和select子句的投射表达式由编译器转换成表达式Lambda，再转换成委托。查询表达式的结果是包含了委托引用的对象。只有在遍历查询结果时，查询对象才实际地执行委托。</p>
</li>
</ul>
<h4 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h4><p>  筛选条件用谓词表示。</p>
<p>所谓谓词，本质上就是返回bool值的Lambda表达式，例如word.Contains()</p>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>orderby子句<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669187419193.png" srcset="/img/loading.gif" lazyload><br>ascending升序和descending降序</p>
<h4 id="let子句"><a href="#let子句" class="headerlink" title="let子句"></a>let子句</h4><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669187502315.png" srcset="/img/loading.gif" lazyload><br>FileInfo要创建两次（在orderby和select子句中）会为来源集合中的每一项都实例化FileInfo对象两次。可用let子句避免这种无谓的、可能非常昂贵的开销</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669187531870.png" srcset="/img/loading.gif" lazyload>let子句引入一个新的范围变量，它容纳的表达式值可在查询表达式剩余部分使用。可添加任意数量的let子句，只需把它放在第一个from子句之后、最后一个select&#x2F;group by子句之前。</p>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>LINQ表达式允许将单独的项分组到一系列子集合中，还允许那些组与所查询的集合中的项关联。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> selection=<br>    <span class="hljs-keyword">from</span> word <span class="hljs-keyword">in</span> CSharp.Keywords<br>    <span class="hljs-keyword">group</span> word <span class="hljs-keyword">by</span> word.Contains(<span class="hljs-string">&#x27;*&#x27;</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> items <span class="hljs-keyword">in</span> selection)<br>&#123;<br>    Console.WriteLine(Environment.NewLine+<span class="hljs-string">&quot;&#123;0&#125;:&quot;</span>,<br>        items.Key?<br>            <span class="hljs-string">&quot;Contextual Keywords&quot;</span>:<span class="hljs-string">&quot;KeyWords&quot;</span>);<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> items)<br>            &#123;<br>                Console.Write(<span class="hljs-string">&quot; &quot;</span>+<br>                    (items.Key?<br>                        item.Replace(<span class="hljs-string">&quot;*&quot;</span>,<span class="hljs-literal">null</span>               ):item));<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669188034480.png" srcset="/img/loading.gif" lazyload></p>
<p>第一个类型实参指出by关键字后的“group key”（分组依据）表达式是bool类型，第二个类型实参指出group关键字后的“group element”（分组元素）表达式是string类型。也就是说，查询将生成一系列分组，将同一个Boolean key应用于组内的每个string。</p>
<ul>
<li>由于含有group by子句的查询会生成一系列集合，所以对结果进行遍历的常用模式是创建嵌套foreach循环。</li>
<li>group子句使查询生成由<code>IGrouping&lt;TKey, TElement&gt;</code>对象构成的集合</li>
</ul>
<h4 id="into查询延续"><a href="#into查询延续" class="headerlink" title="into查询延续"></a>into查询延续</h4><p>语法糖:创建两个查询并将第一个用作第二个的输入<br>引入的范围变量，成为查询剩余部分的范围变量。之前的不可再用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#">IEnumerable&lt;(<span class="hljs-built_in">bool</span> IsContextualKeyword, IGrouping&lt;<span class="hljs-built_in">bool</span>, <span class="hljs-built_in">string</span>&gt; Items)&gt;<br>    selection =<br>        <span class="hljs-keyword">from</span> word <span class="hljs-keyword">in</span> CSharp.Keywords<br>        <span class="hljs-keyword">group</span> word <span class="hljs-keyword">by</span> word.Contains(<span class="hljs-string">&#x27;*&#x27;</span>)<br>        <span class="hljs-function"><span class="hljs-keyword">into</span> groups</span><br><span class="hljs-function">        <span class="hljs-title">select</span></span><br><span class="hljs-function">        (<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">            IsContextualKeyword: groups.Key,</span></span><br><span class="hljs-params"><span class="hljs-function">            Items: groups</span></span><br><span class="hljs-params"><span class="hljs-function">        </span>)</span>;<br>    Console.WriteLine(selection);<br></code></pre></td></tr></table></figure>

<p>into相当于一个“管道操作符”，它将第一个查询的结果“管道传送”给第二个查询。用这种方式可以链接任意数量的查询。</p>
<h4 id="多个from子句“平整”序列的序列"><a href="#多个from子句“平整”序列的序列" class="headerlink" title="多个from子句“平整”序列的序列"></a>多个from子句“平整”序列的序列</h4><p>将一个序列的序列变成单个序列</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> selection=<br>    <span class="hljs-keyword">from</span> word <span class="hljs-keyword">in</span> CSharp.Keywords<br>    <span class="hljs-keyword">from</span> character <span class="hljs-keyword">in</span> word<br>    <span class="hljs-keyword">select</span> character;<br></code></pre></td></tr></table></figure>

<h3 id="Distinct-去重"><a href="#Distinct-去重" class="headerlink" title="Distinct()去重"></a>Distinct()去重</h3><p>放在select子句之后</p>
<h3 id="查询表达式只是方法调用"><a href="#查询表达式只是方法调用" class="headerlink" title="查询表达式只是方法调用"></a>查询表达式只是方法调用</h3><p>Lambda表达式随后由编译器进行转换来生成一个方法。方法主体就是Lambda的主体，使用时会分配一个对该方法的委托。</p>
<p>每个查询表达式都能（而且必须能）转换成方法调用，但不是每一系列的方法调用都有对应的查询表达式。</p>
<blockquote>
<p>要用查询表达式使查询更易读，尤其是涉及复杂的from，let，join或group子句时。</p>
</blockquote>
<blockquote>
<p>当查询所涉及的操作没有对应的查询表达式语法时，考虑使用标准查询操作符（方法调用形式），例如Count()、TakeWhile()或者Distinct()</p>
</blockquote>
<h2 id="构建集合类型"><a href="#构建集合类型" class="headerlink" title="构建集合类型"></a>构建集合类型</h2><h3 id="更多的集合接口"><a href="#更多的集合接口" class="headerlink" title="更多的集合接口"></a>更多的集合接口</h3><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669192596919.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="ILIST-lt-T-gt-和IDictionary-lt-TKey-TValue-gt"><a href="#ILIST-lt-T-gt-和IDictionary-lt-TKey-TValue-gt" class="headerlink" title="ILIST&lt;T&gt;和IDictionary&lt;TKey,TValue&gt;"></a><code>ILIST&lt;T&gt;</code>和<code>IDictionary&lt;TKey,TValue&gt;</code></h3><p>字典按键值对存储,按键索引<br>列表按顺序存储,按位置访问</p>
<h3 id="ICollection-lt-T-gt"><a href="#ICollection-lt-T-gt" class="headerlink" title="ICollection&lt;T&gt;"></a><code>ICollection&lt;T&gt;</code></h3><ul>
<li><p>Count返回集合中的元素总数。</p>
</li>
<li><p>CopyTo()将集合转换成数组</p>
</li>
</ul>
<h3 id="主要集合类"><a href="#主要集合类" class="headerlink" title="主要集合类"></a>主要集合类</h3><h4 id="List-lt-T-gt"><a href="#List-lt-T-gt" class="headerlink" title="List&lt;T&gt;"></a><code>List&lt;T&gt;</code></h4><p>和数组类似，但是自动扩展</p>
<p>可显式调用TrimToSize()或Capacity来缩小</p>
<ul>
<li><p>可用索引操作符来设置和访问列表元素，索引参数值就是元素在集合中的位置</p>
</li>
<li><p><code>List&lt;T&gt;</code>是有序集合。Add()方法将指定项添加到列表末尾。</p>
</li>
<li><p>Sort()排序</p>
</li>
<li><p>Remove()或RemoveAt()移除</p>
</li>
<li><p>Contains()、Indexof()、LastIndexOf()和BinarySearch()查找</p>
</li>
<li><p>FindAll()查找多个数据项.谓词可是bool委托</p>
<blockquote>
<p>自定义集合排序<br>string类型实现了<code>IComparable&lt;string&gt;</code>接口，它有一个CompareTo()方法。<br>没有实现接口可使用<code>Sort(IComparer&lt;T&gt;）</code><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669193268789.png" srcset="/img/loading.gif" lazyload><br>CompareTo的实现必须为任何可能的数据项排列组合提供一致的排序结果。<br>要确保自定义比较逻辑产生一致的“全序”</p>
</blockquote>
</li>
</ul>
<h4 id="Dictionary-lt-TKey-TValue-gt"><a href="#Dictionary-lt-TKey-TValue-gt" class="headerlink" title="Dictionary&lt;TKey, TValue&gt;"></a><code>Dictionary&lt;TKey, TValue&gt;</code></h4><p>字典类存储的是“名称&#x2F;值”对</p>
<ul>
<li><p>Add()插入</p>
</li>
<li><p>ContainsKey()读取前查询是否存在</p>
</li>
<li><p>Remove()按键删除</p>
</li>
<li><p>ContainsValue()，它顺序搜索集合中的每个元素,按值查找</p>
</li>
<li><p>Keys和Values属性只处理字典类中的键或值。返回的数据类型是<code>ICollection&lt;T&gt;</code>。返回的是对原始字典集合中的数据的引用，而不是返回拷贝</p>
</li>
</ul>
<p>内部是哈希表,按键查的快.不是按顺序存储的</p>
<h4 id="SortedDictionary-lt-TKey-TValue-gt-和SortedList-lt-T-gt"><a href="#SortedDictionary-lt-TKey-TValue-gt-和SortedList-lt-T-gt" class="headerlink" title="SortedDictionary&lt;TKey, TValue&gt;和SortedList&lt;T&gt;"></a><code>SortedDictionary&lt;TKey, TValue&gt;</code>和<code>SortedList&lt;T&gt;</code></h4><p>已经排序好的列表和字典</p>
<h4 id="Stack-lt-T-gt"><a href="#Stack-lt-T-gt" class="headerlink" title="Stack&lt;T&gt;"></a><code>Stack&lt;T&gt;</code></h4><p>后入先出的栈</p>
<ul>
<li><p>Push()将元素送入集合。元素不必唯一。·</p>
</li>
<li><p>Pop()按照与添加时相反的顺序获取并删除元素。</p>
</li>
<li><p>为了在不修改栈的前提下访问栈中的元素，要使用Peek()和Contains()方法。</p>
<ul>
<li><p>Peek()返回Pop()将获取的下一个元素。</p>
</li>
<li><p>Contains()判断一个元素是否在栈的某个地方</p>
</li>
</ul>
</li>
</ul>
<h4 id="Queue-lt-T-gt"><a href="#Queue-lt-T-gt" class="headerlink" title="Queue&lt;T&gt;"></a><code>Queue&lt;T&gt;</code></h4><p>队列集合。先入先出.</p>
<ul>
<li>Enqueue()和Dequeue()入出队列</li>
</ul>
<p>队列集合类会根据需要自动增大,不会减小</p>
<ul>
<li>TrimToSize()确保长时间不变大小</li>
</ul>
<h4 id="LinkedList-lt-T-gt"><a href="#LinkedList-lt-T-gt" class="headerlink" title="LinkedList&lt;T&gt;"></a><code>LinkedList&lt;T&gt;</code></h4><p>链表<br>允许正向和反向遍历。<br>无非泛性类型</p>
<h3 id="提供索引器"><a href="#提供索引器" class="headerlink" title="提供索引器"></a>提供索引器</h3><p>数组、字典和列表都提供了索引器</p>
<p>为了使用索引器，只需将索引放到集合后的方括号中。可定义自己的索引器.索引可获取多个参数，甚至可以重载。本例使用enum防止调用者为不存在的项提供索引。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IPair</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    T First &#123; <span class="hljs-keyword">get</span>; &#125;<br>    T Second &#123; <span class="hljs-keyword">get</span>; &#125;<br><br>    T <span class="hljs-keyword">this</span>[PairItem index] &#123; <span class="hljs-keyword">get</span>; &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> PairItem<br>&#123;<br>    First,<br>    Second<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Pair&lt;T&gt; : IPair&lt;T&gt;<br>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span>(<span class="hljs-params">T first, T second</span>)</span><br>    &#123;<br>        First = first;<br>        Second = second;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T First &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-keyword">public</span> T Second &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-keyword">this</span>[PairItem index]<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">switch</span>(index)<br>            &#123;<br>                <span class="hljs-keyword">case</span> PairItem.First:<br>                    <span class="hljs-keyword">return</span> First;<br>                <span class="hljs-keyword">case</span> PairItem.Second:<br>                    <span class="hljs-keyword">return</span> Second;<br>                <span class="hljs-literal">default</span>:<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(<br>                        <span class="hljs-string">$&quot;The enum index.Tostring()&#125;has not been implemented&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>C#编译器为索引器创建的CIL代码是名为Item的特殊属性，它获取一个实参。接受实参的属性不可以在C#中显式创建，所以Item属性在这方面相当特殊。使用了标识符Item的其他任何成员，即使它有完全不同的签名，都会和编译器创建的成员冲突，所以不被允许。IndexerNameAttibute特性指定[]的名称</p>
</blockquote>
<ul>
<li>索引器还可获取一个可变的参数列表，如:<code>this[params PairItem[] ?branches]</code></li>
</ul>
<h3 id="返回null或者空集合"><a href="#返回null或者空集合" class="headerlink" title="返回null或者空集合"></a>返回null或者空集合</h3><p>返回不含数据项的集合实例。这样可避免强迫调用者在遍历集合前检查null值</p>
<blockquote>
<p>不要用null引用表示空集合。考虑改为使用<code>Enumerable.Empty&lt;T&gt;()</code>方法。</p>
</blockquote>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器用清楚的语法描述了如何循环遍历（也就是迭代）集合类中的数据，尤其是如何使用foreach来遍历。封装集合的内部实现.</p>
<p>自定义集合实现自己的<code>IEnumerator&lt;T&gt;</code>、<code>IEnumerable&lt;T&gt;</code>和对应的非泛型接口</p>
<p>迭代器是实现类的方法的一个途径，是更复杂的枚举数模式的语法简化形式。编译器遇到迭代器时，会把它的内容扩展成实现了枚举数模式的CIL代码。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>迭代器提供了迭代器接口（也就是<code>IEnumerable&lt;T&gt;</code>和<code>IEnumerator&lt;T&gt;</code>这两个接口的组合）的一个快捷实现。</p>
<p>迭代器类似于函数，但它不是返回（return）一个值，而是生成（yield）一系列值。每次迭代器遇到yield return语句都生成一个值，之后控制立即回到请求数据项的调用者。</p>
<blockquote>
<p>一个return语句会触发finally块被执行，而yield return则不会。</p>
</blockquote>
<p>GetEnumerator()在foreach语句中被首次调用时，会创建一个迭代器对象，其状态被初始化为特殊的“起始”状态，表示迭代器尚未执行代码，所以尚未生成任何值。只要foreach语句继续，迭代器就会一直维持其状态。循环每一次请求下一个值，控制就会进入迭代器，从上一次离开的位置继续。该位置是根据迭代器对象中存储的状态信息来判断的。foreach语句终止，迭代器的状态就不再保存了。</p>
<blockquote>
<p>MoveNext()方法由<code>IEnumerator&lt;T&gt;</code>接口提供。</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br>    <span class="hljs-keyword">var</span> jfkFamilyTree = <span class="hljs-keyword">new</span> BinaryTree&lt;<span class="hljs-built_in">string</span>&gt;(<br>        <span class="hljs-string">&quot;John Fitzgerald Kennedy&quot;</span>)<span class="hljs-comment">//SubItems是Pair&lt;T&gt;类型的属性，是一个struct。当属性返回值时，会生成SubItems的一个拷贝，该拷贝在语句执行完毕之后就会丢失。所以，对一个马上就要丢失的拷贝上的First进行赋值，显然会引起误解。</span><br>    &#123;<br>        SubItems = <span class="hljs-keyword">new</span> Pair&lt;BinaryTree&lt;<span class="hljs-built_in">string</span>&gt;&gt;(<br>            <span class="hljs-keyword">new</span> BinaryTree&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Joseph Patrick Kennedy&quot;</span>)<br>            &#123;<br>                SubItems = <span class="hljs-keyword">new</span> Pair&lt;BinaryTree&lt;<span class="hljs-built_in">string</span>&gt;&gt;(<br>                    <span class="hljs-keyword">new</span> BinaryTree&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Patrick Joseph Kennedy&quot;</span>),<br>                    <span class="hljs-keyword">new</span> BinaryTree&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Mary Augusta Hickey&quot;</span>))<br>            &#125;,<br>            <span class="hljs-keyword">new</span> BinaryTree&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Rose Elizabeth Fitzgerald&quot;</span>)<br>            &#123;<br>                SubItems = <span class="hljs-keyword">new</span> Pair&lt;BinaryTree&lt;<span class="hljs-built_in">string</span>&gt;&gt;(<br>                    <span class="hljs-keyword">new</span> BinaryTree&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;John Francis Fitzgerald&quot;</span>),<br>                    <span class="hljs-keyword">new</span> BinaryTree&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Mary Josephine Hannon&quot;</span>))<br>            &#125;)<br>    &#125;;<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> jfkFamilyTree)<br>    &#123;<br>        Console.WriteLine(name);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTree</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinaryTree</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Value = <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator&lt;T&gt; <span class="hljs-title">GetEnumerator</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> Value;<br>        <span class="hljs-keyword">foreach</span> (BinaryTree&lt;T&gt;? tree <span class="hljs-keyword">in</span> SubItems)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(tree <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>)<br>            &#123;<br>                <span class="hljs-keyword">foreach</span>(T item <span class="hljs-keyword">in</span> tree)<br>                &#123;<br>                    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> item;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    IEnumerator IEnumerable.GetEnumerator()<br>    &#123;<br>        <span class="hljs-keyword">return</span> GetEnumerator();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T Value &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-keyword">public</span> Pair&lt;BinaryTree&lt;T&gt;&gt; SubItems &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Pair&lt;T&gt;: IEnumerable&lt;T&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span>(<span class="hljs-params">T first, T second</span>) : <span class="hljs-title">this</span>()</span><br>    &#123;<br>        First = first;<br>        Second = second;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T First &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-keyword">public</span> T Second &#123; <span class="hljs-keyword">get</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator&lt;T&gt; <span class="hljs-title">GetEnumerator</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> First;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> Second;<br>    &#125;<br><br>    IEnumerator IEnumerable.GetEnumerator()<br>    &#123;<br>        <span class="hljs-keyword">return</span> GetEnumerator();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>递归迭代的危险性</p>
</blockquote>
<h4 id="取消更多的迭代-yield-break"><a href="#取消更多的迭代-yield-break" class="headerlink" title="取消更多的迭代:yield break"></a>取消更多的迭代:yield break</h4><ul>
<li><p>yield break使MoveNext()返回false终止循环</p>
<blockquote>
<p>它使设置多个出口成为可能，所以使用时需谨慎，因为阅读代码时如果不小心，就可能错过某个靠前的出口。</p>
</blockquote>
<h3 id="迭代器工作方式"><a href="#迭代器工作方式" class="headerlink" title="迭代器工作方式"></a>迭代器工作方式</h3><p>C#编译器遇到一个迭代器时，会根据枚举数模式将代码展开成恰当的CIL。创建嵌套类来实现<code>IEnumerator&lt;T&gt;</code></p>
</li>
</ul>
<p>因为编译器拿掉了yield return语句，而且生成的类和手工编写的类基本一致，所以C#迭代器的性能与手工实现枚举数模式一致。虽然性能没有提升，但开发效率显著提高了。</p>
<h4 id="多个迭代器"><a href="#多个迭代器" class="headerlink" title="多个迭代器"></a>多个迭代器</h4><p><code>IEnumerable&lt;T&gt;.GetEnumerator()</code>是foreach要隐式寻找的方法。</p>
<p>可声明多个迭代器封装到返回<code>IEnumerable&lt;T&gt;</code>的成员中.在foreach中调用在in之后显式指定该迭代器</p>
<h4 id="yield语句的要求"><a href="#yield语句的要求" class="headerlink" title="yield语句的要求"></a>yield语句的要求</h4><ul>
<li>只有在返回<code>IEnumerator&lt;T&gt;</code>或者<code>IEnumerable&lt;T&gt;</code>类型的成员中使用</li>
<li>该成员不能包含return语句</li>
<li>只能在方法，自定义操作符，索引器&#x2F;属性的get访问器方法中出现。成员不能获取任何ref&#x2F;out参数</li>
<li>不能在匿名方法&#x2F;Lambda中出现</li>
<li>不能在catch&#x2F;finally中出现。<ul>
<li>可在没有catch的try中出现</li>
</ul>
</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射是指对程序集中的元数据进行检查的过程。编译时维持关于代码的大部分元数据。</p>
<ul>
<li>访问程序集中类型的元数据。</li>
<li>使用元数据在运行时动态调用类型的成员</li>
</ul>
<h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>获取System.Type的实例，代表目标类型<strong>实例</strong>。</p>
<ul>
<li>Name</li>
<li>IsPublic</li>
<li>BaseType</li>
<li>Assembly</li>
<li>GetInterfaces()<br>-Type.GetProperties()、Type.GetMethods()、Type.GetFields()<ul>
<li>扩展方法只能作为实现类型的静态成员</li>
<li>返回类型在System.Reflection命名空间中</li>
</ul>
</li>
<li>Type.GetCustomAttributes()修饰的特性</li>
</ul>
<p>获取方式：</p>
<ul>
<li><p>object.GetType()</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">DateTime dateTime=<span class="hljs-keyword">new</span>();<br><br>Type type=dateTime.GetType();<br><span class="hljs-keyword">foreach</span> (PropertyInfo property <span class="hljs-keyword">in</span> type.GetProperties())<br>&#123;<br>    Console.WriteLine(property.Name);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>静态类无法实例化，无法调用</p>
</li>
<li><p>typeof()在编译时绑定到特定的Type实例，并直接获取类型作为参数</p>
</li>
</ul>
<h3 id="成员调用"><a href="#成员调用" class="headerlink" title="成员调用"></a>成员调用</h3><ul>
<li>可绕过可访问性规则</li>
<li>MemberInfo成员反射类</li>
<li>属性:PropertyInfo SetValue()设置属性<ul>
<li>参数包括要设置值的对象、新值以及一个额外的index参数（除非属性是索引器，否则该参数为null）</li>
</ul>
</li>
<li>方法:MethodInfo Invoke()成员调用</li>
</ul>
<h3 id="泛型类上的反射"><a href="#泛型类上的反射" class="headerlink" title="泛型类上的反射"></a>泛型类上的反射</h3><p>可判断类或方法是否包含泛型类型，以及其中可能包含的任何类型参数&#x2F;类型实参。</p>
<ul>
<li><p>类型参数的类型:<code>typeof(T)</code></p>
</li>
<li><p>是否支持泛型:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Type type=<span class="hljs-keyword">typeof</span>(System.Nullable&lt;&gt;);<br>Console.WriteLine(type.ContainsGenericParameters);<br>Console.WriteLine(type.IsGenericType);<br>type = <span class="hljs-keyword">typeof</span>(System.Nullable&lt;DateTime&gt;);<br>Console.WriteLine(type.ContainsGenericParameters);<br>Console.WriteLine(type.IsGenericType);<br></code></pre></td></tr></table></figure>

<ul>
<li>是否包含尚未设置的泛型参数:<code>Type.ContainsGenericParameters</code></li>
<li><code>Type.IsGenericType</code>是指示类型是否泛型的Boolean属性</li>
</ul>
</li>
<li><p>为泛型类或方法获取类型参数</p>
<ul>
<li><p><code>GetGenericArguments()</code>从泛型类获取泛型实参的列表</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">Stack&lt;<span class="hljs-built_in">int</span>&gt; s=<span class="hljs-keyword">new</span>();<br><br><span class="hljs-keyword">var</span> type=s.GetType();<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> generic <span class="hljs-keyword">in</span> type.GetGenericArguments())<br>&#123;<br>    Console.WriteLine(generic.FullName);<span class="hljs-comment">//System.Int32</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="nameof-1"><a href="#nameof-1" class="headerlink" title="nameof"></a>nameof</h3><ul>
<li>在参数异常中提供参数的类型名</li>
<li>在方法调用中返回参数的类型名</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>特性是可添加到编程元素（如程序集、类型、成员和参数）的注释。 它们存储在程序集的元数据中，并且可在运行时使用反射 API 进行访问。</p>
<p>以声明的方式将信息与代码相关联   </p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">MyClass my=<span class="hljs-keyword">new</span>();<span class="hljs-comment">//提示弃用,over</span><br>[<span class="hljs-meta">Obsolete(<span class="hljs-string">&quot;over&quot;</span>)</span>]<br><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    [<span class="hljs-meta">return:Description(<span class="hljs-string">&quot;返回2&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Test</span>()</span>=&gt;<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>多个可<code>,</code></li>
</ul>
<ul>
<li>反射到的成员都可以获取修饰的特性,如<code>GetCustomAttributes</code></li>
</ul>
<h3 id="通用特性"><a href="#通用特性" class="headerlink" title="通用特性"></a>通用特性</h3><table>
<thead>
<tr>
<th><code>assembly</code></th>
<th>整个程序集</th>
</tr>
</thead>
<tbody><tr>
<td><code>module</code></td>
<td>当前程序集模块</td>
</tr>
<tr>
<td><code>field</code></td>
<td>类或结构中的字段</td>
</tr>
<tr>
<td><code>event</code></td>
<td>事件</td>
</tr>
<tr>
<td><code>method</code></td>
<td>方法或 <code>get</code> 和 <code>set</code> 属性访问器</td>
</tr>
<tr>
<td><code>param</code></td>
<td>方法参数或 <code>set</code> 属性访问器参数</td>
</tr>
<tr>
<td><code>property</code></td>
<td>Property</td>
</tr>
<tr>
<td><code>return</code></td>
<td>方法、属性索引器或 <code>get</code> 属性访问器的返回值</td>
</tr>
<tr>
<td><code>type</code></td>
<td>结构、类、接口、枚举或委托</td>
</tr>
</tbody></table>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Reflection;<br>[<span class="hljs-meta">assembly: AssemblyTitleAttribute(<span class="hljs-string">&quot;Production assembly 4&quot;</span>)</span>]<br>[<span class="hljs-meta">module: CLSCompliant(true)</span>]<br></code></pre></td></tr></table></figure>

<h3 id="自定义特性"><a href="#自定义特性" class="headerlink" title="自定义特性"></a>自定义特性</h3><p>从System.Attribute派生后，一个普通的类就变成特性</p>
<p>名称必须以Attribute结束</p>
<h3 id="用构造函数初始化特性"><a href="#用构造函数初始化特性" class="headerlink" title="用构造函数初始化特性"></a>用构造函数初始化特性</h3><p>特性还可封装数据:做元数据，使用反射获得</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAttribute</span>:<span class="hljs-title">Attribute</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestAttribute</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">alias</span></span>)</span><br>    &#123;<br>        Alias=<span class="hljs-keyword">alias</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Alias &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><br>&#123;<br>    [<span class="hljs-meta">TestAttribute(<span class="hljs-string">&quot;?&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> Help &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>向某个构造应用特性时，只有常量值和typeof()表达式才允许作为实参。</p>
<blockquote>
<p>如特性有必需的属性值，要提供只能取值的属性</p>
<p>要为具有必需属性的特性提供构造函数参数来初始化属性。</p>
<p>避免提供构造函数参数来初始化和可选参数对应的特性属性</p>
</blockquote>
<p>获得</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">TypeInfo typeInfo = <span class="hljs-keyword">typeof</span>(MyClass).GetTypeInfo();<span class="hljs-comment">//获得程序集信息</span><br>Console.WriteLine(<span class="hljs-string">&quot;The assembly qualified name of MyClass is &quot;</span> + typeInfo.AssemblyQualifiedName);<br><br><span class="hljs-keyword">var</span> attrs = typeInfo.GetCustomAttributes();<span class="hljs-comment">//反射获得特性列表</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> attr <span class="hljs-keyword">in</span> attrs)<br>    Console.WriteLine(<span class="hljs-string">&quot;Attribute on MyClass: &quot;</span> + attr.GetType().Name);<br></code></pre></td></tr></table></figure>

<h3 id="AttributeUsageAttribute"><a href="#AttributeUsageAttribute" class="headerlink" title="AttributeUsageAttribute"></a>AttributeUsageAttribute</h3><p>标记特性.限制特性的使用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">AttributeUsage(AttributeTargets.Property)</span>]<br><span class="hljs-keyword">class</span> <span class="hljs-title">TestAttribute</span>:<span class="hljs-title">Attribute</span><br>&#123;<br><br>&#125;<br>[<span class="hljs-meta">TestAttribute</span>]<span class="hljs-comment">//error</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &#123; &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>AllowMultiple是具名参数</p>
<p>有了具名参数后，就可直接对特性的数据进行赋值，而不必为特性属性的每一种组合都提供对应的构造函数。由于一个特性的许多属性都是可选的，所以具名参数许多时候都非常好用。</p>
</li>
</ul>
<h3 id="FlagsAttribute"><a href="#FlagsAttribute" class="headerlink" title="FlagsAttribute"></a>FlagsAttribute</h3><p>将枚举可组合</p>
<h3 id="ConditionalAttribute"><a href="#ConditionalAttribute" class="headerlink" title="ConditionalAttribute"></a>ConditionalAttribute</h3><p>清除调用操作:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta">#<span class="hljs-keyword">define</span> test1</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br>    Test1();<br>    Test2();<span class="hljs-comment">//未调用</span><br><br>&#125;<br>[<span class="hljs-meta">Conditional(<span class="hljs-string">&quot;test2&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test2</span>()</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;test2 ok&quot;</span>);<br>&#125;<br><br>[<span class="hljs-meta">Conditional(<span class="hljs-string">&quot;test1&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test1</span>()</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;test1 ok&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>类似#if&#x2F;#endif预处理指令,但是不能从程序集中清除CIL代码.而是在编译时移除调用操作.语法显得更清晰，因为开发者只需为目标方法添加ConditionalAttribute特性，无须对调用者本身进行任何修改。</p>
<ul>
<li>必须只能void不能包含out</li>
</ul>
<h2 id="动态编程"><a href="#动态编程" class="headerlink" title="动态编程"></a>动态编程</h2><p>运行时”会在程序执行时对这个机制进行解析，而不是由编译器在编译时验证和绑定。</p>
<blockquote>
<p>从较高的级别上说，经常会有对象天生就不适合赋予一个静态类型。例子包括从XML&#x2F;CSV文件、数据库表、Internet Explorer DOM或者COM的IDispatch接口加载数据，或者调用用动态语言写的代码（比如调用IronPython对象中的代码）</p>
</blockquote>
<p>四个绑定方式:</p>
<ol>
<li>针对底层CLR类型使用反射</li>
<li>调用自定义IDynamicMetaObjectProvider，它使一个DynamicMetaObject变得可用</li>
<li>通过COM的IUnknown和IDispatch接口来调用</li>
<li>调用由动态语言（比如IronPython）定义的类型</li>
</ol>
<h3 id="dynamic调用反射"><a href="#dynamic调用反射" class="headerlink" title="dynamic调用反射"></a>dynamic调用反射</h3><p>反射的关键功能之一就是动态查找和调用特定类型的成员。这要求在执行时识别成员名或其他特征，比如一个特性</p>
<p>C# 4.0新增的动态对象提供了更简单的办法来通过反射调用成员。但该技术的限制在于，编译时需要知道成员名和签名</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">dynamic</span> data=<span class="hljs-string">&quot;hello world&quot;</span>;<br>Console.WriteLine(data);<br>data=<span class="hljs-number">2</span>;<br>Console.WriteLine(data);<br>data=DateTime.Now;<br>Console.WriteLine(data.Day);<span class="hljs-comment">//没有智能提示的Day</span><br></code></pre></td></tr></table></figure>

<p>编译时不会检查指定成员是否可用，甚至不会检查dynamic对象的基础类型是什么。</p>
<p>不存在成员<code>Microsoft.CSharp.RuntimeBinder.RuntimeBinderException</code></p>
<ul>
<li><p>从dynamic到一个替代类型的成功转换要依赖基础类型的支持(装箱拆箱)</p>
</li>
<li><p>任何dynamic成员调用都返回dynamic对象</p>
</li>
<li><p>GetType()会返回代表运行时类型</p>
</li>
<li><p>用dynamic来实现的反射不支持扩展方法</p>
</li>
</ul>
<blockquote>
<p>究其根本，dynamic是一个System.Object.dynamic特殊的动态行为只在编译时出现，这个行为是将它同一个System.Object区分开的关键。</p>
</blockquote>
<blockquote>
<p>内部原理:在CIL中，dynamic类型实际是一个System.Object。<br>事实上，如果没有任何调用，dynamic类型的声明和System.Object没有区别。但一旦调用它的成员，区别就变得明显了。为调用成员，编译器要声明<code>System.Runtime.CompilerServices.CallSite&lt;T&gt;</code>类型的一个变量。如ToString()通过一个Create()工厂方法来实例化<code>CallSite&lt;Func&lt;CallSite,object,string&gt;&gt;</code>另外还会动态定义一个方法，该方法可通过参数CallSite site，object dynamicTarget和string result进行调用。<code>CallSite&lt;T&gt;.Target()</code>调用。<br>执行时，反射确保签名匹配。生成表达式树，得到类似的CIL在调用点缓存，通过委托实际出处罚调用</p>
</blockquote>
<h3 id="比较静态和动态"><a href="#比较静态和动态" class="headerlink" title="比较静态和动态"></a>比较静态和动态</h3><p>静态编程:</p>
<ul>
<li>类型安全。</li>
<li>访问动态数据不方便</li>
</ul>
<p>动态编程</p>
<ul>
<li>无验证</li>
<li>动态数据访问方便</li>
</ul>
<h3 id="自定义动态类型"><a href="#自定义动态类型" class="headerlink" title="自定义动态类型"></a>自定义动态类型</h3><p>实现<code>IDynamicMetaObjectProvider</code>接口。</p>
<p>首选继承<code>DynamicObject</code></p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>CPU 实际执行程序的硬件单元</p>
<p>进程 某个程序当前正在执行的实例.</p>
<p>c#本质描述控制流，线程是控制点</p>
<p>单线程&#x2F;多线程</p>
<p>任务 可能出现高延迟的工作单元，作用是产生结果值或者希望的副作用</p>
<p>线程池 多个线程的集合，通过一定逻辑决定如何为线程分配工作。</p>
<p>多线程处理主要用于两个方面：实现多任务和解决延迟。</p>
<p>添加更多线程会进一步降低性能，直到最后处理器的大量时间被花在从一个线程切换到另一个线程上，而不是花在线程的执行上。</p>
<blockquote>
<p>不要以为多线程必然会使代码更快。<br>要在通过多线程来加快解决处理器受限问题时谨慎衡量性能。</p>
</blockquote>
<p>多线程大多数操作都不是原子性的.竞态条件.内部模型的复杂性.锁定造成死锁</p>
<h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>多线程编程的复杂性:</p>
<ol>
<li><p>监视异步操作的状态,知道何时完成.<br> 最好不要采取轮询线程状态或阻塞并等待的办法</p>
</li>
<li><p>线程池.<br> 避免了启动和终止线程的巨大开销</p>
</li>
<li><p>避免死锁<br> 在防止数据同时被两个不同的线程访问的同时避免死锁</p>
</li>
<li><p>为不同操作提供原子性兵同步数据访问</p>
</li>
</ol>
<ul>
<li>任何时候只要有需要长时间运行的方法，就可能需要多线程编程——即异步调用该方法</li>
</ul>
<p>C# 5.0总结了常见的多线程编程模式，并推出了<code>Task</code></p>
<p>###TPL</p>
<p>创建线程代价高昂，而且每个线程都要占用大量虚拟内存（例如Windows默认1MB）。前面说过，更有效的做法是使用线程池：需要时分配线程，为线程分配异步工作，运行至完成，再为后续异步工作重用线程，而不是在工作结束后销毁再重新创建线程。</p>
<p>TPL在开始异步工作时都不是创建一个线程，而是创建Task,默认从线程池请求一个工作者线程</p>
<p>通过将异步工作的概念抽象到Task对象中，TPL提供了一个能代表异步工作的对象，还提供了面向对象的API与工作交互–Task</p>
<blockquote>
<p>委托是同步的封装，而任务是异步的封装</p>
</blockquote>
<h4 id="理解异步任务"><a href="#理解异步任务" class="headerlink" title="理解异步任务"></a>理解异步任务</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> repetition = <span class="hljs-number">10000</span>;<br>Task task = Task.Run(() =&gt;<span class="hljs-comment">//工作者线程</span><br>    &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>; count &lt; repetition; count++)<br>        &#123;<br>            Console.Write(<span class="hljs-string">&#x27;-&#x27;</span>);    <br>        &#125;<br>     &#125;);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>; count &lt; repetition; count++)<span class="hljs-comment">//主线程</span><br>&#123;<br>    Console.Write(<span class="hljs-string">&#x27;+&#x27;</span>);<br>&#125;<br>task.Wait();<span class="hljs-comment">//强迫主线程等待分配给任务的所有工作完成。</span><br></code></pre></td></tr></table></figure>

<ul>
<li>一旦调用Task.Run()，作为实参传递的Action几乎立即开始执行。这称为“热”任务<ul>
<li>冷任务:将Task对象传递给方法。方法决定调用时机。不常见</li>
</ul>
</li>
<li>Task.WaitAll()和Task.WaitAny()</li>
<li>需要返回结果可用Func委托.读取<code>Result</code>自动造成当前线程的阻塞</li>
<li><code>IsCompleted</code>不管结束是否正常都设为true.<ul>
<li>更详细的任务状态信息可通过读取Status属性来获得</li>
</ul>
</li>
<li>Task.CurrentId返回正在执行的Task的id(唯一标识符)</li>
<li>AsyncState关联额外的数据。</li>
</ul>
<p>例如，假定要用多个任务计算一个<code>List&lt;T&gt;</code>中的值。为此，每个任务都将值的索引包含到AsyncState属性中。这样当任务结束后，代码可用AsyncState（先转型成int）访问列表中的特定索引位置。因为在多线程中修改集合不安全.</p>
<p>###任务延续</p>
<p>控制流:决定了接下来要发生的事情:<br><code>Console.WriteLine(x.ToString());</code>也是控制流，如果ToString正常结束则调用wirteLine(),将刚才的返回值作为实参传给他。<br>接下来发生的事情 就是一个延续</p>
<p>控制流中的每个控制点都有个延续<br>C#编程其实就是在延续的基础上构造延续，直至整个程序的控制流结束。</p>
<p>异步方法的延续是多维的。并行的执行路径</p>
<p>Task使我们能将较小的任务合并成较大的任务，只需描述好异步延续就可以了。</p>
<p>合并任务:</p>
<ul>
<li><p>Task.ContinueWith()当先驱任务完成后，第二个任务（延续任务）自动以异步方式开始</p>
<ul>
<li>同一个先驱的多个延续任务无法在编译时确定执行顺序。</li>
</ul>
<ul>
<li><p>有多个重载版本<code>TaskContinuationOptions</code></p>
<ul>
<li><p>OnlyOnFauled 先驱任务没有出异常</p>
</li>
<li><p>OnlyOnCanceled 先驱任务没有被取消</p>
</li>
</ul>
<ul>
<li>OnlyOnRanToCompletion 先驱任务成功完成</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="AggregateException"><a href="#AggregateException" class="headerlink" title="AggregateException"></a>AggregateException</h3><p>处理Task上的未处理异常</p>
<p>不能用try块包装Start()调用来捕捉异常，因为控制会立即从调用返回，然后控制会离开try块，而这时离工作者线程发生异常可能还有好久。一个解决方案是将任务的委托主体包装到try&#x2F;catch块中。抛出并被工作者线程捕捉的异常不会造成问题，因为try块在工作者线程上能正常地工作。但对于工作者线程不捕捉的未处理的异常来说就麻烦了。</p>
<p>任何线程上的未处理异常都被视为严重错误.</p>
<p>任务调度器会用一个“catchall”异常处理程序来包装委托。如果任务抛出未处理的异常，那么该处理程序会捕捉并记录异常细节，避免CLR自动终止进程。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#">Task task = Task.Run(() =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException());<br><span class="hljs-keyword">try</span><br>&#123;            <br>    task.Wait();<br>&#125;<br><span class="hljs-keyword">catch</span> (AggregateException ex)<br>&#123;<br>    ex.Handle(eachEx =&gt;<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;error:<span class="hljs-subst">&#123;eachEx&#125;</span>&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>AggregateException可能包含从一个或多个出错的任务收集到的异常</p>
<ul>
<li>包含的异常列表通过InnerExceptions属性获取</li>
</ul>
</li>
<li><p>Handle()处理谓词。成功处理true.false返回新的异常列表</p>
</li>
<li><p>任务的Exception属性来了解出错任务的状态,无需抛出异常.使用空包容<code>!</code></p>
</li>
<li><p>可通过TaskScheduler.UnobservedTaskException事件来登记未处理的任务异常</p>
</li>
</ul>
<h4 id="处理线程上未处理的异常"><a href="#处理线程上未处理的异常" class="headerlink" title="处理线程上未处理的异常"></a>处理线程上未处理的异常</h4><p>任何线程上的未处理异常默认都将造成应用程序终止。未处理异常代表严重的、事前没意识的bug，而且异常可能因为关键数据结构损坏而发生。</p>
<p>更好的方案是不马上关闭程序，而是先保存工作数据并记录异常.</p>
<ul>
<li>AppDomain的UnhandledException事件，<br>  通知,不允许应用程序从未处理异常中恢复并继续执行。事件处理程序运行完毕，应用程序会显示“Windows错误报告”对话框并退出（如果是控制台应用程序，异常详细信息还会在控制台上显示）</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> System.Diagnostics.Stopwatch _Clock = <span class="hljs-keyword">new</span>();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            _Clock.Start();<br>            System.AppDomain.CurrentDomain.UnhandledException +=<br>                (s, e) =&gt;<br>                    &#123;<br>                        Message(<span class="hljs-string">&quot;event hander starting&quot;</span>);<br>                        Delay(<span class="hljs-number">4000</span>);<br>                    &#125;;<br>            Thread thread = <span class="hljs-keyword">new</span> Thread(() =&gt;<br>            &#123;<br>                Message(<span class="hljs-string">&quot;throwing exception&quot;</span>);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();<br>            &#125;);<br><br>            thread.Start();<br>            Delay(<span class="hljs-number">2000</span>);<br>        &#125;<br>        <span class="hljs-keyword">finally</span><br>        &#123;<br>            Message(<span class="hljs-string">&quot;finally block running&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delay</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span><br>    &#123;<br>        Message(<span class="hljs-string">$&quot;sleeping for <span class="hljs-subst">&#123;i&#125;</span> ms&quot;</span>);<br>        Thread.Sleep(i);<br>        Message(<span class="hljs-string">&quot;Awake&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Message</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> text</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;:&#123;1:0000&#125;:&#123;2&#125;&quot;</span>,<br>            Thread.CurrentThread.ManagedThreadId,<br>            _Clock.ElapsedMilliseconds,<br>            text);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669337047451.png" srcset="/img/loading.gif" lazyload><br>过程:新线程4，主线程1.调用3，一会抛出未处理异常，调用时间处理程序，进入睡眠4s。操作1,1睡眠2s醒来后运行finally，2秒后3醒来，未处理线程导致进程崩溃<br>如果主线程睡的更久，finally不会触发</p>
<blockquote>
<p>避免程序在任何线程上产生未处理异常<br>考虑登记“未处理异常”事件处理程序以进行调试、记录和紧急关闭<br>要取消未完成的任务而不要在程序关闭期间允许其运行</p>
</blockquote>
<p>###取消任务</p>
<p>协作式取消，一种安全地取消不再需要的任务的得体、健壮和可靠的技术。</p>
<p>支持取消的任务要监视一个CancellationToken对象（位于System.Threading命名空间）。任务定期轮询它，检查是否发出了取消请求。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Threading;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-comment">//using AddisonWesley.Michaelis.EssentialCSharp.Shared;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">string</span> stars = <span class="hljs-string">&quot;*&quot;</span>.PadRight(Console.WindowWidth - <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;*&#x27;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;Push ENTER to exit.&quot;</span>);<br>        CancellationTokenSource cancellationTokenSource =<br>        <span class="hljs-keyword">new</span> CancellationTokenSource();<br>        Task task = Task.Run(<br>            () =&gt;<br>                Writepi(cancellationTokenSource.Token),<br>                    cancellationTokenSource.Token);<br>        Console.ReadLine();<br>        cancellationTokenSource.Cancel();<br>        Console.WriteLine(stars);<br>        task.Wait();<br>        Console.WriteLine();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Writepi</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        CancellationToken cancellationToken</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> batchsize = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">string</span> piSection = <span class="hljs-built_in">string</span>.Empty;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!cancellationToken.IsCancellationRequested<br>            || i == <span class="hljs-built_in">int</span>.MaxValue)<br>        &#123;<br>            piSection = i++.ToString();<br>            Console.Write(piSection);<br>            <span class="hljs-comment">//    PiCalculator.Calculate(</span><br>            <span class="hljs-comment">//batchsize, (i++) * batchsize);</span><br>            <span class="hljs-comment">//Console.Write(piSection);</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>启动任务后，一个Console.Read()会阻塞主线程。与此同时，任务继续执行，计算并打印pi的下一位。用户按Enter键后，执行就会遇到一个CancellationTokenSource.Cancel()调用。在代码中，对task.Cancel()的调用和对task.Wait()的调用是分开的，两者之间会打印一行星号。目的是证明在观察到取消标记之前，极有可能发生一次额外的循环迭代.</p>
<p>任务会继续运行，直到它检查标记，发现标记的所有者已请求取消任务，这时才会得体地关闭任务。</p>
<ul>
<li>Cancel()实际会在从CancellationTokenSource.Token拷贝的所有取消标记上设置IsCancellationRequested属性<ul>
<li>提供给异步任务的是CancellationToken(能轮询取消请求)而不是CancellationTokenSource(提供标记)</li>
<li>CancellationToken是结构，所以能拷贝值(线程安全)。CancellationTokenSource.Token返回的是标记的副本。<ul>
<li>IsCancellationRequested属性一旦true，跳出轮询</li>
<li>可调用Register()方法在CancellationTokenSource的Cancel()上登记一个侦听器委托。</li>
<li>ThrowIfCancellationRequested()抛出TaskCanceledExceptio异常，主动报告如取消任务会在某些方面造成破坏（例如，导致无法返回一个有效的结果）等问题<ul>
<li>在此任务上调用Wait()（或获取Result），结果和在任务中抛出其他任何异常一样：这个调用会抛出AggregateException。意味着任务的执行状态可能不完整。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>在程序退出时，要先终止正在执行的任务，而不要对它放任不管</p>
</blockquote>
<p>###Task.Factory.StartNew()</p>
<p>Task.Run()是Task.Factory.StartNew()的简化形</p>
<p>Task.Factory.StartNew()在C#4.0中用于调用一个需创建一个额外线程的CPU密集型方法。</p>
<p>要用TaskCreationOptions控制任务，要指定其他调度器，或出于性能考虑要传递对象状态，这时就应考虑Task.Factory.StartNew()。</p>
<p>只有需要将创建和调度分开时（这种情况很少见），才应考虑在用构造函数实例化线程后添加一个Start()调用。</p>
<p>###长时间运行的任务</p>
<p>线程池假设工作项是处理器受限的，而且运行时间较短。</p>
<p>如果事先知道任务时间长，可提前通知.获得专用线程和更多的时间分片.</p>
<ul>
<li><p>在调用<code>StartNew()</code>时使用<code>TaskCreationOptions.LongRunning</code>选项.</p>
<ul>
<li><p>Run()不支持.</p>
</li>
<li><p>少用</p>
</li>
</ul>
</li>
</ul>
<h3 id="对任务清理资源"><a href="#对任务清理资源" class="headerlink" title="对任务清理资源"></a>对任务清理资源</h3><p>支持IDisposable,依赖的是程序退出时的自动WaitHandle终结器调用。</p>
<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><p>并行扩展库相当有用，因为它允许使用更高级的抽象——任务，而不必直接和线程打交道。</p>
<p>TPL和PLINQ问世前的Thread提供了对操作系统线程的安装</p>
<ul>
<li><p>Thread类中的Sleep()方法为很多人所熟知，但实际开发中应当避免使用它</p>
<ul>
<li>这个方法告诉操作系统在一段时间之内不要给当前线程分配CPU时间，从而使线程休眠。在系统中，创建和运行一个线程是一件开销较大的操作，我们开创线程的目的是让它产出更多的工作结果，而不是让它休眠。</li>
<li>可时间0的休眠,让出时间片</li>
<li>可在测试代码中使用</li>
</ul>
</li>
<li><p>ThreadPool类限制程序创建线程的数量，以避免对系统运行效率产生负面影响。</p>
<blockquote>
<p>这是因为当系统中的活跃线程数量大于CPU的逻辑核心数量时，系统将会使用分配时间片的方式来模拟并行执行，然而用这种方式实现的“并行”执行其实要比分先后执行慢很多。此外，虽然ThreadPool本身能够很好的工作，但是它既不擅长处理长期执行的任务，也并没有为线程之间的同步提供足够的功能。基于这些原因，我们需要一套抽象程度更高的API将ThreadPool作为底层实现包装起来。而TPL就是这样的API。有了它，就应该避免直接使用ThreadPool。</p>
</blockquote>
</li>
</ul>
<h3 id="TAP"><a href="#TAP" class="headerlink" title="TAP"></a>TAP</h3><p>基于任务的异步编程模式</p>
<p>异步执行的任务缺点最主要的便是会颠倒程序的逻辑，使得整个程序变得难于理解。</p>
<h4 id="同步执行高延迟操作"><a href="#同步执行高延迟操作" class="headerlink" title="同步执行高延迟操作."></a>同步执行高延迟操作.</h4><p>案例:用WebClient下载网页并且统计下载内容中特定单词出现的次数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">using</span> System.IO;<br><br><span class="hljs-keyword">using</span> System.Net;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><br><br>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> DefaultUrl = <span class="hljs-string">&quot;https://IntelliTect.com&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><br>    &#123;<br><br>        <span class="hljs-comment">//if (args.Length == 0)</span><br><br>        <span class="hljs-comment">//&#123;</span><br><br>        <span class="hljs-comment">//    Console.WriteLine(&quot;ERROR:No findText argument specified.&quot;);</span><br><br>        <span class="hljs-comment">//    return;</span><br><br>        <span class="hljs-comment">//&#125;</span><br><br>        <span class="hljs-built_in">string</span> findText = <span class="hljs-string">&quot;IntelliTect&quot;</span>;<br><br>        <span class="hljs-built_in">string</span> url = DefaultUrl;<br><br>        <span class="hljs-keyword">if</span> (args.Length &gt; <span class="hljs-number">1</span>)<br><br>            url = args[<span class="hljs-number">1</span>];<br><br>        Console.Write(<br><br>            <span class="hljs-string">$&quot;Searching for &#x27;<span class="hljs-subst">&#123;findText&#125;</span>&#x27;at URL &#x27;<span class="hljs-subst">&#123;url&#125;</span>&#x27;.&quot;</span>);<br><br>        Console.WriteLine(<span class="hljs-string">&quot;Downloading....&quot;</span>);<br><br>        <span class="hljs-keyword">using</span> WebClient webClient = <span class="hljs-keyword">new</span> WebClient();<br><br>        <span class="hljs-built_in">byte</span>[] downloadData =<br><br>            webClient.DownloadData(url);<br><br>        Console.WriteLine(<span class="hljs-string">&quot;Searching....&quot;</span>);<br><br>        <span class="hljs-built_in">int</span> textOccurrenceCount = Countoccurrences(<br><br>            downloadData, findText);<br><br>        Console.WriteLine(<br><br>            @<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Environment.NewLine&#125;</span>&#x27;<span class="hljs-subst">&#123;findText&#125;</span>&#x27;appears</span><br><span class="hljs-string"></span><br><span class="hljs-string">                <span class="hljs-subst">&#123;textOccurrenceCount&#125;</span>times at URL &#x27;<span class="hljs-subst">&#123;url&#125;</span>&#x27;.&quot;</span>);<br><br>        Console.ReadKey();<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Countoccurrences</span>(<span class="hljs-params"><span class="hljs-built_in">byte</span>[] downloadData, <span class="hljs-built_in">string</span> findText</span>)</span><br><br>    &#123;<br><br>        <span class="hljs-built_in">int</span> textOccurrenceCount =<span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">using</span> MemoryStream stream = <span class="hljs-keyword">new</span> MemoryStream(downloadData);<br><br>        <span class="hljs-keyword">using</span> StreamReader reader = <span class="hljs-keyword">new</span> StreamReader(stream);<br><br>        <span class="hljs-built_in">int</span> findIndex = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-built_in">int</span> length = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">do</span><br><br>        &#123;<br><br>            <span class="hljs-built_in">char</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[reader.BaseStream.Length];<br><br>            length = reader.Read(data);<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;length; i++)<br><br>            &#123;<br><br>                <span class="hljs-keyword">if</span> (findText[findIndex] == data[i])<br><br>                &#123;<br><br>                    findIndex++;<br><br>                    <span class="hljs-keyword">if</span> (findIndex == findText.Length)<br><br>                    &#123;<br><br>        S               textOccurrenceCount++;<br><br>                        findIndex = <span class="hljs-number">0</span>;<br><br>                    &#125;<br><br>                &#125;<br><br>                <span class="hljs-keyword">else</span><br><br>                &#123;<br><br>                    findIndex = <span class="hljs-number">0</span>;<br><br>                &#125;<br><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (length != <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> textOccurrenceCount;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>发起Web请求的线程会被I&#x2F;O操作阻塞，直到操作完成才能恢复，而这将浪费一个线程的运算能力，它本可以在等待过程中做其他更有意义的工作。例如，我们可以在等待和缓慢接收网络数据的过程中向用户显示一个动态的进度。</p>
<h4 id="使用TPL实现异步执行高延迟操作"><a href="#使用TPL实现异步执行高延迟操作" class="headerlink" title="使用TPL实现异步执行高延迟操作"></a>使用TPL实现异步执行高延迟操作</h4><p>唯一的区别是，在下载网页和检索关键词的过程中，在“Download…”和“Searching…”两行打印的后面会显示更多的点，其数量取决于操作的实际耗时。这些点用于提示用户：操作正在正常进行中，请耐心等待。</p>
<p>为了实现这个有用的异步特性，我们需要付出的代价是代码变得更加复杂。TPL相关的语句不断地介入到业务流程的代码中。我们无法在异步操作WebClient.DownloadDataTaskAsync(url)的后面直接写上检索关键词的代码（即调用异步版本的CountOccurrences()），为了让异步操作正常工作，需要使用ContinueWith()语句、调用Unwrap()以及实现一套复杂的try&#x2F;catch处理</p>
<h4 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h4><p>使用async&#x2F;await实现基于任务的异步模式</p>
<p>async&#x2F;await关键字让编译器来承担异步程序的复杂性，从而使程序员可以集中精力实现真正的业务逻辑。</p>
<p>你不必再考虑串接ContinueWith()语句、调用Results()方法获取结果、调用Unwrap()方法，以及复杂的错误处理等。如果有后继任务需要等待前驱任务先成功完成再执行，编译器也会自动安排恰当的线程来实现这个要求。</p>
<ol>
<li>方法签名上使用了<code>async</code>键字，表明当该方法被调用时将发生异步执行</li>
<li>该方法返回的是一个<code>Task&lt;int&gt;</code>型对象而不是一个单纯的int。</li>
</ol>
<ul>
<li>任何具有async关键字的方法都必须返回一个有效的异步返回值类型<ul>
<li><code>void</code>或<code>Task</code>,<code>Task&lt;T&gt;</code><br>,<code>VauleTask&lt;T&gt;,IAsyncEnumerable&lt;T&gt;/IAsyncEnumerator&lt;T&gt;</code>等支持支持GetAwaiter()的对象</li>
<li>如果一个异步方法实际上并不返回数据，也可以返回Task类对象，至少可以让调用者获取异步任务的执行状态，比如可以检查异步任务是否已完成。</li>
</ul>
</li>
<li>在异步方法内部，当需要调用其他异步方法并且等待其执行结果时，可以在调用时使用await操作符</li>
<li>await会自动将逻辑上的返回值从Task对象中提取出来。<code>Task&lt;int&gt;提取int</code></li>
</ul>
<ul>
<li>可在并行工作结束await去等待和提取异步操作的结果</li>
</ul>
<blockquote>
<p>一个方法具有async关键字，它也会默认地运行于调用者的线程中.该方法需要启动异步任务以便开始真正的异步执行，只使用async关键字并不会改变执行线程。此方法仅仅是一个只能返回某一种异步类型的方法。<br>当前线程并不会被await关键字暂停，而是会从它开始“分叉”。</p>
</blockquote>
<p>async关键字的存在有两个意义。首先它明确提示阅读代码的人：该方法有可能会被编译器根据需要自动改写。其次它告诉编译器：在该方法内遇到await关键字时，那条语句将被异步执行。</p>
<p>main方法也可以async</p>
<p>可以在程序最外层的catch块中捕获所有尚未处理的异常，并且在程序被迫结束之前将出错信息保存在日志中。由于保存日志往往是一件比较耗时的操作，因此很有必要异步执行。</p>
<h3 id="异步返回值ValueTask-lt-T-gt"><a href="#异步返回值ValueTask-lt-T-gt" class="headerlink" title="异步返回值ValueTask&lt;T&gt;"></a>异步返回值<code>ValueTask&lt;T&gt;</code></h3><p>当异步方法无须执行异步任务，而是提前返回时，该类型可以提供轻量级的对象构造；反之，则可以转换为全功能的异步返回类型。而不是Task及其泛型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ValueTask&lt;<span class="hljs-built_in">byte</span>[]&gt; CompressAsync(<span class="hljs-built_in">byte</span>[] buffer)<br>&#123;<br>    <span class="hljs-keyword">if</span> (buffer.Length ==<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> buffer;<br>    &#125;<br>    <span class="hljs-keyword">using</span> MemoryStream memoryStream=<span class="hljs-keyword">new</span> MemoryStream();<br>    <span class="hljs-keyword">using</span> System.IO.Compression.GZipStream gZipStream=<br>        <span class="hljs-keyword">new</span> System.IO.Compression.GZipStream(<br>            memoryStream,<br>            System.IO.Compression.CompressionMode.Compress);<br>    <span class="hljs-keyword">await</span> gZipStream.WriteAsync(buffer, <span class="hljs-number">0</span>, buffer.Length);<br>    <span class="hljs-keyword">return</span> memoryStream.ToArray();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>即使异步方法GZipStream.WriteAsync()返回的是<code>Task&lt;T&gt;</code>对象，但是对它执行await的异步方法仍然可以返回<code>ValueTask&lt;T&gt;</code>类型</p>
<blockquote>
<p>选择:</p>
<ul>
<li><p>无返回值，Task</p>
</li>
<li><p>异步方法有可能异步完成,或有可能缓存常见的结果Task对象，<code>Task&lt;T&gt;</code></p>
</li>
</ul>
<blockquote>
<p>事实上一个Task<bool>对象只会包含true或false两个可能的值，所以可以预先创建两个包含两种可能值的对象并缓存起来，从而在异步方法即将退出时直接返回缓存的对象。</p>
</blockquote>
<ul>
<li>如果操作可能同步完成并且不能有效地缓存所有常见的返回值,<code>ValueTask&lt;T&gt;</code></li>
</ul>
</blockquote>
<h4 id="异步返回值类型解析"><a href="#异步返回值类型解析" class="headerlink" title="异步返回值类型解析"></a>异步返回值类型解析</h4><p>await关键字后面的表达式一般为<code>Task</code>、<code>Task&lt;T&gt;</code>或<code>ValueTask&lt;T&gt;</code>类型</p>
<p>Task类型的await操作本质上等于一个返回void的表达式。也就是说，你只能在单行语句中使用它。</p>
<p>await语句中的异步任务返回<code>Task&lt;int&gt;</code>则可以写成返回的任务值的运算式.</p>
<h3 id="异步流"><a href="#异步流" class="headerlink" title="异步流"></a>异步流</h3><p>将异步模式和迭代器组合.</p>
<ul>
<li>yield return可以在异步方法中异步地产生可被迭代的数据</li>
<li>async foreach迭代异步方法的返回值</li>
</ul>
<p>注入取消令牌并提供取消的方法是通过WithCancellation()扩展方法，要支持异步流方法中的取消，需要添加可选的CancellationToken参数和EnumeratorCancellationAttribute特性</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> IAsyncEnumerable&lt;<span class="hljs-built_in">string</span>&gt;</span><br><span class="hljs-function">    <span class="hljs-title">EncryptFilesAsync</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">string</span> directoryPath <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">string</span> searchPattern <span class="hljs-string">&quot;*&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        [EnumeratorCancellation]CancellationToken</span></span><br><span class="hljs-params"><span class="hljs-function">            cancellationToken <span class="hljs-literal">default</span></span>)</span><br>&#123; &#125;<br></code></pre></td></tr></table></figure>

<h4 id="自定义支持异步迭代器"><a href="#自定义支持异步迭代器" class="headerlink" title="自定义支持异步迭代器"></a>自定义支持异步迭代器</h4><p>如果一个集合类不支持异步迭代器，自行实现一个类，使他继承<code>IAsyncEnumerable&lt;T&gt;</code>接口并实现GetAsyncEnumerator()方法</p>
<ul>
<li>请注意，<code>IAsyncDisposable.DisposeAsync()</code>和<code>IAsyncEnumerator&lt;T&gt;.MoveNextAsync()</code>方法都是<code>IEnumerators&lt;T&gt;</code>中等效方法的异步版本，而<code>Current</code>属性则不是异步的。（此外，在异步实现中没有<code>Reset()</code>方法。）</li>
</ul>
<blockquote>
<p>一个方法被声明为异步的（使用async关键字）不会自动导致对它的调用并行运行。</p>
<ul>
<li>为了保证并行执行，需要在异步方法中使用await执行其他异步任务，或使用类似System.Threading.Tasks.Parallel.ForEach()的方法</li>
</ul>
</blockquote>
<h4 id="IAsyncDisposable和await-using"><a href="#IAsyncDisposable和await-using" class="headerlink" title="IAsyncDisposable和await using"></a>IAsyncDisposable和await using</h4><ul>
<li>IAsyncDisposable是IDisposable的异步版本,具有DisposeAsync()方法</li>
<li>await using声明或语句来调用它。和using语句用法相同</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">await</span> <span class="hljs-keyword">using</span> FileStream outputFileStream=<br>    <span class="hljs-keyword">new</span> FileStream(encryptedFileName,FileMode.Create);<br>&#123;&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>IAsyncDisposable和IDisposable不通过继承相互关联。</p>
</blockquote>
<h4 id="LINQ和IAsyncEnumerable"><a href="#LINQ和IAsyncEnumerable" class="headerlink" title="LINQ和IAsyncEnumerable"></a>LINQ和IAsyncEnumerable</h4><p>若要在程序中使用异步LINQ，需要在工程中添加System.Linq.Async NuGet包</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">await</span> <span class="hljs-keyword">foreach</span> (<br>    (<span class="hljs-built_in">string</span> fileName,<span class="hljs-built_in">string</span> encryptedFileName) <br>    <span class="hljs-function"><span class="hljs-keyword">in</span> <span class="hljs-title">EncryptFileAsync</span>(<span class="hljs-params">files</span>)</span><br><span class="hljs-function">        .<span class="hljs-title">Zip</span>(<span class="hljs-params">files.ToAsyncEnumerable(</span>)))</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;fileName&#125;</span>=&gt;<span class="hljs-subst">&#123;encryptedFileName&#125;</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>面代码中使用的Where()、Select()和Zip()方法。因为它们是在IAsyncEnumerable而不是在<code>IEnumerable&lt;T&gt;</code>中的扩展方法，所以被认为是“异步版本”的方法</p>
<ul>
<li><p>ToAsyncEnumerable()将<code>IEnumerable&lt;T&gt;</code>转换为<code>IAsyncEnumerable&lt;T&gt;</code>。类似地，可以用ToEnumerable()方法进行相反的转换。</p>
</li>
<li><p>异步LINQ方法的“标量”版本与<code>IEnumerable&lt;T&gt;</code>类似，也具有<em>Await()、</em>AwaitAsync()和*AwaitWithCancellation()系列方法。关键的区别在于它们都返回一个<code>ValueTask&lt;T&gt;</code>对象。<br>  这样我们就可以利用await将其返回值直接提取成为double类型，从而可以忽略其实际的类型：<code>ValueTask&lt;double&gt;</code>。</p>
</li>
</ul>
<p>###异步void</p>
<p>  允许使用返回类型（也可以说它并不是一种类型）不支持GetAwaiter()<br>  当一个异步方法返回void时，调用者无法得知该异步任务何时完成。无法报告异常,抛出异常最终出现在UI的SynchronizationContext上,成为未处理异常</p>
<blockquote>
<p>尽量避免使用async void方法，除非它们是void类型的事件处理程序的订阅者。应该避免抛出异常或者提供同步上下文来接收同步事件通知.</p>
</blockquote>
<h3 id="有效异步返回值类型的扩展"><a href="#有效异步返回值类型的扩展" class="headerlink" title="有效异步返回值类型的扩展"></a>有效异步返回值类型的扩展</h3><p>await要求类型为可等待类型，即包含一个名为GetAwaiter()的方法。返回对象:实现INotifyCompletion接口,且有个GetResult()方法</p>
<h3 id="异步Lambda和本地函数"><a href="#异步Lambda和本地函数" class="headerlink" title="异步Lambda和本地函数"></a>异步Lambda和本地函数</h3><p>await允许Lambda表达式转换为委托.<br>也可以使用本地函数代替Lambda表达式</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#">TaskTest taskTest = <span class="hljs-keyword">new</span> TaskTest();<br>Task&lt;<span class="hljs-built_in">int</span>&gt; result = taskTest.CalculateAsync(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>Console.WriteLine(<span class="hljs-string">$&quot;我做了其他操作...<span class="hljs-subst">&#123;DateTime.Now&#125;</span>&quot;</span>);<br>Console.WriteLine(<span class="hljs-string">$&quot;获得结果为<span class="hljs-subst">&#123;result.Result&#125;</span>...<span class="hljs-subst">&#123;DateTime.Now&#125;</span>&quot;</span>);<br>Console.WriteLine(<span class="hljs-string">$&quot;输出结果之后的操作...<span class="hljs-subst">&#123;DateTime.Now&#125;</span>&quot;</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TaskTest</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">CalculateAsync</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> Task.Run(() =&gt;<br>        &#123;<br>            System.Threading.Thread.Sleep(<span class="hljs-number">4</span> * <span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> a + b;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>async Lambda表达式的返回值必须也是符合规则的类型</p>
</li>
<li><p>重新改写的Lambda表达式使用return语句通知调用者异步任务已经完成。</p>
</li>
<li><p>在执行刚进入异步Lambda表达式时，也会先同步执行直到遇到第一个await语句才开始异步执行。</p>
</li>
<li><p>await之后的所有指令将作为从异步方法返回处的延续执行（如果可等待任务已经完成，则将简单地同步执行而不是作为延续）。</p>
</li>
<li><p>async Lambda表达式也可以通过await操作符来调用</p>
</li>
</ul>
<h3 id="实现自定义的异步方法"><a href="#实现自定义的异步方法" class="headerlink" title="实现自定义的异步方法"></a>实现自定义的异步方法</h3><p>通过使用await关键字调用其他异步任务来实现异步方法相对容易。但是最终总是需要创建一个“最外层”的异步方法来返回异步任务对象。</p>
<p>要实现异步方法并在调用的进程完成时返回调用者的同步上下文，我们可以依赖<code>TaskCompletionSource&lt;T&gt;</code>对象</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Task&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">ReadTask</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Stream stream, <span class="hljs-built_in">byte</span>[] buffer, <span class="hljs-built_in">int</span> offset, <span class="hljs-built_in">int</span> count, <span class="hljs-built_in">object</span> state</span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> tcs = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-built_in">int</span>&gt;();<br>    stream.BeginRead(buffer, offset, count, ar =&gt;<br>    &#123;<br>        <span class="hljs-keyword">try</span> &#123; tcs.SetResult(stream.EndRead(ar)); &#125;<br>        <span class="hljs-keyword">catch</span> (Exception exc) &#123; tcs.SetException(exc); &#125;<br>    &#125;, state);<br>    <span class="hljs-keyword">return</span> tcs.Task;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>异步方法需要的另一个重要特性是取消机制<br>TAP（基于任务的异步模式）依赖于与TPL（基于任务的并行库）相同的取消机制，即使用System.Threading.CancellationToken</p>
<blockquote>
<p>在编写异步程序时请记住以下要点</p>
</blockquote>
<ul>
<li><p>当程序执行到await关键字时，它右侧的表达式会生成一个异步任务，同时当前程序的执行会返回到调用者那里。从此开始，调用者后续的语句便和异步方法（假设它尚未完成）并行执行。</p>
</li>
<li><p>异步任务完成后，异步方法内的程序便从await之后恢复执行。如果等待的任务产生结果，则获得该结果，否则抛出异常。</p>
</li>
<li><p>异步方法中的return语句导致与方法调用相关联的异步任务完成。如果return语句有值，则返回的值成为任务的执行结果。</p>
</li>
</ul>
<h3 id="任务调度器和同步上下文"><a href="#任务调度器和同步上下文" class="headerlink" title="任务调度器和同步上下文"></a>任务调度器和同步上下文</h3><p>System.Threading.Tasks.TaskScheduler类，使用线程池来适当地调度任务，并确定如何安全有效地执行它们，包括何时重用、销毁这些任务，或是创建额外的任务.</p>
<ul>
<li>也可以从之派生自定义任务调度器</li>
<li>静态FromCurrentSynchronizationContext()可以多得特殊的实例，将任务调度到当前线程关联的同步上下文</li>
</ul>
<p>任务的等待需要参考同步上下文.</p>
<p>默认同步上下文导致由线程池来决策线程分配问题。有时线程池认为使用新线程效率更高，有时它决定重用现有线程会更好</p>
<p>C#会根据不同的应用程序类型自动设置恰当的同步上下文(控制台应用程序是SynchronizationContext)</p>
<h3 id="在Windows-UI程序使用async-x2F-await"><a href="#在Windows-UI程序使用async-x2F-await" class="headerlink" title="在Windows UI程序使用async&#x2F;await"></a>在Windows UI程序使用async&#x2F;await</h3><p>UI单线程.</p>
<p>async&#x2F;await模式(TAP)的主要优点之一是：它利用同步上下文来确保出现在await语句之后的代码始终在与调用await语句相同的同步上下文中执行。这种方法的价值在于它消除了显式切换回UI线程来更新界面控件的需要。</p>
<p>TPL不是立即执行后续代码，而是查询同步上下文，将await任务返回的信息发布到消息泵。接下来，由于UI线程监视消息泵，因此在获得继续工作的消息时，它会调用await调用之后的代码。（因此，后续代码的调用与处理消息泵的调用者在同一线程上。）</p>
<p>充分考虑了代码可读性问题。</p>
<blockquote>
<p>无论await语句是在迭代中出现还是作为单独的语句出现，它们都将串行执行，即一个接一个地按照调用线程调用它们的顺序执行。其底层实现是在Task.ContinueWith()的语义等价实现中将它们串在一起，而且await操作符之间的所有其他代码都将在调用者的同步上下文中执行。</p>
</blockquote>
<h2 id="并行迭代"><a href="#并行迭代" class="headerlink" title="并行迭代"></a>并行迭代</h2><h3 id="并行执行循环迭代"><a href="#并行执行循环迭代" class="headerlink" title="并行执行循环迭代"></a>并行执行循环迭代</h3><p>将大型任务（例如，计算pi的100万个十进制数字）拆分为任意数量的可以并行运行的小任务非常容易。通常这类计算很容易通过添加并行数量来提高速度。</p>
<p>TPL（基于任务的并行库）提供了一个方便的方法Parallel.For()，它正是用来实现将顺序的循环并行化的、。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> iterations=<span class="hljs-number">1000</span>;<br><span class="hljs-built_in">string</span>[] sections=<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[iterations];<span class="hljs-comment">//放在数组而不是sring是因为在循环中计算的部分很可能不会按顺序完成，因此如果在每个独立迭代完成时组装一部分结果，则很可能无法得到正确的组装顺序。此外由于代码中的+=操作符不是原子操作，可能引发竞争条件，。所以使用数组</span><br>Parallel.For(<span class="hljs-number">0</span><span class="hljs-comment">/*起始值*/</span>, iterations<span class="hljs-comment">/*循环结束值*/</span>, i =&gt; <br>    &#123;<br>        sections[i]=PiCalculator.Calculate(i);<span class="hljs-comment">/*具体的计算方法*/</span><br>    &#125;<span class="hljs-comment">/*Action*/</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果一个对CPU资源占用较大的计算可以很容易被分割为多个彼此完全独立的部分以任意顺序执行，则要使用并行循环。</p>
</blockquote>
<ul>
<li>还有个类似的foreach循环 ForEach()</li>
</ul>
<p>TPL将决定效率最高的线程数量。</p>
<h3 id="TPL如何自动调整执行效率"><a href="#TPL如何自动调整执行效率" class="headerlink" title="TPL如何自动调整执行效率"></a>TPL如何自动调整执行效率</h3><p>基于线程池。</p>
<p>爬山算法在开始阶段不断创建新线程来运行任务，然后监控这些任务的性能。当发现性能开始下降时就减少线程，使性能回升到最佳。</p>
<p>工作窃取算法能够识别工作量过度饱和以及过度枯竭的线程。工作量不足的线程会从过于繁忙的线程“窃取”任务。</p>
<h3 id="在并行循环中处理异常"><a href="#在并行循环中处理异常" class="headerlink" title="在并行循环中处理异常"></a>在并行循环中处理异常</h3><p>TPL会捕获与任务相关的异常状况并抛出AggregateException异常。</p>
<p>每一个迭代都有可能发生异常，而所有被抛出过的异常都会被包装进System.AggregateException，并通过InnerExceptions属性提供给异常处理程序</p>
<h3 id="取消并行迭代"><a href="#取消并行迭代" class="headerlink" title="取消并行迭代"></a>取消并行迭代</h3><p>异步任务不会阻塞调用者线程，除非调用者明确要求等待任务完成（比如使用await关键字）。<br>并行循环一旦开始执行，在所有迭代完成之前不会自行返回。因此，当需要取消并行循环时，通常需要从执行并行循环的线程以外的线程发起取消请求。如<code>Task.Run()</code>调用<code>Parallel.ForEach&lt;T&gt;()</code></p>
<p>并行循环使用与任务相同的取消令牌机制。<br>ForEach()方法的其中一个重载版本接收一个ParallelOptions类型参数。<br>CancellationTokenSource对象作为取消令牌，然后创建一个ParallelOptions类型的并行参数对象并将取消令牌包装进参数对象，最后在并行ForEach()时提供参数对象。<br>当需要时可以调用已关联令牌的Cancel()方法提前终止并行循环。<br>还会通过抛出OperationCanceledException异常来通知执行被取消。</p>
<blockquote>
<p>如果取消并行循环，框架会通过检查IsCancellationRequested属性来阻止任何尚未开始的迭代启动，而正在执行的迭代将继续运行到它们各自的正常终点。此外，即使在所有迭代均已完成后调用Cancel()，框架仍会发送取消事件。（可通过cts.Token.Register()注册监听事件。）</p>
</blockquote>
<h3 id="ParallelOptions"><a href="#ParallelOptions" class="headerlink" title="ParallelOptions"></a>ParallelOptions</h3><ul>
<li><p>MaxDegreeOfParallelism属性还可控制最大并行度,通常不必要.见于特殊的算法和环境:</p>
<ul>
<li>当需要分析或者调试程序问题时，可以通过将最大并行度设定为1以确保循环的每一次迭代都顺序执行。</li>
<li>影响并行度的外部因素（如硬件配置等）明确已知。例如，如果并行操作需要使用多个USB端口，那么创建多于可用端口数量的线程很可能没有意义。</li>
<li>应用场景中具有长时间运行的循环迭代（例如，几分钟或几小时）。线程池无法区分长时间运行的迭代和阻塞，因此最终可能导致引入许多新线程，而所有这些线程都将被for循环迭代消耗。随着时间的推移，这会导致进程中出现大量线程</li>
</ul>
</li>
<li><p>TaskScheduler属性指定优先调度.</p>
</li>
<li><p>CancellationToken属性可用于与循环通信，通知循环不再进一步迭代。此外，循环的调用者也可以通过该属性得知循环是否被取消执行。</p>
</li>
</ul>
<h3 id="中断并行循环"><a href="#中断并行循环" class="headerlink" title="中断并行循环"></a>中断并行循环</h3><p>这里的“中断”表示在中断迭代之后不应开始新的迭代，但是所有当前正在执行的迭代都将继续运行完成。</p>
<p>For()的重载版本.<br>ParallelLoopState对象的Break方法(指示不再需要执行索引值高于当前值的迭)或Stop方法(表明根本不需要运行更多的迭代)<br>IsCompleted属性，是否所有迭代都被调度执行。<br>LowestBreakIteration属性为发出终止循环指令的最小迭代号，类型为long?。如果为null，则说明循环正常结束，没有被打断。</p>
<h2 id="并行执行LINQ查询"><a href="#并行执行LINQ查询" class="headerlink" title="并行执行LINQ查询"></a>并行执行LINQ查询</h2><p>Parallel LINQ API（简称PLINQ）</p>
<p><code>AsParallel()</code>是ParallelEnumerable静态类的扩展方法，告诉运行时可以并行执行查询。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> parallel=data.AsParallel().OrderBy(item=&gt;item);<br></code></pre></td></tr></table></figure>

<p>并行标准查询方法返回的结果类型是<code>ParallelQuery&lt;T&gt;</code>或<code>OrderedParallelQuery&lt;T&gt;</code>，两者都会提示编译器应该继续使用并行版本的标准查询操作。</p>
<p>查询表达式和AsParallel()</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> parallel=<span class="hljs-keyword">from</span> text <span class="hljs-keyword">in</span> data.AsParallel() <span class="hljs-keyword">group</span> text <span class="hljs-keyword">by</span> text[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure>

<ul>
<li>不要让多个线程同时不恰当地访问和修改同一内存，这样做会导致竞争条件错误。</li>
</ul>
<p>抛出的异常是OperationCanceledException.<br>执行PLINQ查询也是在调用线程上的同步操作。</p>
<p>PLINQ使用取消令牌是通过方法返回的<code>ParallelQuery&lt;T&gt;</code>对象的WithCancellation()扩展方法传入之后，便可调用Cancel()<br>两种方法取消:</p>
<ol>
<li><p>放在try&#x2F;catch中捕捉OperationCanceledException</p>
</li>
<li><p>将CancellationToken传递给ParallelEncrypt()并作为Run()的第二个参数.<br>这将导致task.Wait()抛出一个AggregateException，其InnerException属性将被设置为TaskCanceledException。然后可以捕获聚合异常，就像从并行操作中捕获任何其他异常一样。</p>
</li>
</ol>
<p>												</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>在避免死锁的同时防止出现竞态条件</p>
<h3 id="线程同步的意义"><a href="#线程同步的意义" class="headerlink" title="线程同步的意义"></a>线程同步的意义</h3><p>竞态条件:一个C#语句可能涉及好几个步骤,所以代码中的访问数据可能同时被多个线程的步骤访问.</p>
<p>关于变量读写的原子性。在读写的时候，如果类型大小超过本机(指针大小)整数，就会部分的读取，long能被64位完整读写，但是decimal28位就不保证是原子性，可能会在仅仅拷贝了32位之后被打断，造成以后读取一个不正确的值，这称为一次torn read（被撕裂的读取</p>
<h3 id="多线程和局部变量"><a href="#多线程和局部变量" class="headerlink" title="多线程和局部变量"></a>多线程和局部变量</h3><p>局部变量没必要同步。加载到栈上，每个线程都有自己的逻辑栈。<br>因此每个方法调用的每个局部变量都有自己的实例(所以不共享)</p>
<p>但是像循环迭代For一样公开局部变量就会公开局部变量造成竞态条件</p>
<h3 id="用Monitor同步"><a href="#用Monitor同步" class="headerlink" title="用Monitor同步"></a>用Monitor同步</h3><p>System.Threading.Monitor类.监视器,阻止第二个线程进入受保护的代码段.</p>
<ul>
<li>Monitor.Enter()通过共享作为参数传递的同一个对象引用</li>
<li>Monitor.Exit()</li>
</ul>
<blockquote>
<p>所有代码都要用try&#x2F;finally块包围起来。否则受保护代码段内发生的异常可能造成Monitor.Exit()永远无法调用，无限阻塞其他线程。</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> _Sync=<span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">long</span> _Count=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Task task=Task.Run(()=&gt;Test());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">bool</span> lockTaken=<span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span><br>            &#123;<br>                Monitor.Enter(_Sync,<span class="hljs-keyword">ref</span> lockTaken);<br>                _Count--;<br>            &#125;<br>            <span class="hljs-keyword">finally</span>    <br>            &#123;<br>                <span class="hljs-keyword">if</span> (lockTaken)<br>                &#123;<br>                    Monitor.Exit(_Sync);<br>                &#125;<br>            &#125;<br>        &#125;<br>        task.Wait();<br>        Console.WriteLine(_Count);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">bool</span> lockTaken = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span><br>            &#123;<br>                Monitor.Enter(_Sync, <span class="hljs-keyword">ref</span> lockTaken);<br>                _Count++;<br>            &#125;<br>            <span class="hljs-keyword">finally</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (lockTaken)<br>                &#123;<br>                    Monitor.Exit(_Sync);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Monitor.Pulse()进入就绪队列.指出下一个就轮到它获得锁（并可开始执行）.仅允许一个进入.</li>
</ul>
<h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><p>Monitor的语法糖</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> _Sync = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">long</span> _Count = <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>  &#123;<br>      Task task = Task.Run(() =&gt; Test());<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>      &#123;<br>          <span class="hljs-keyword">lock</span> (_Sync)<br>          &#123;<br>              _Count++;<br>          &#125;<br>      &#125;<br>      task.Wait();<br>      Console.WriteLine(_Count);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>  &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>      &#123;<br>          <span class="hljs-keyword">lock</span> (_Sync)<br>          &#123;<br>              _Count--;<br>          &#125;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同步以牺牲性能为代价。</p>
<blockquote>
<p>对象设计的最佳实践是对可变的静态状态进行同步（永远不变的东西不必同步），不同步任何实例数据。</p>
</blockquote>
<h3 id="锁对象的选择"><a href="#锁对象的选择" class="headerlink" title="锁对象的选择"></a>锁对象的选择</h3><p>在前面的例子中，同步变量_Sync被声明为私有和只读。确保值不变，这就在同步块的进入和退出之间建立了关联。设为私有确保类外部的同步块不能同步同一个对象.</p>
<ul>
<li>在值类型上使用lock关键字，编译器会报错。因为进行装拆箱得到不同的对象.</li>
</ul>
<h3 id="避免锁this、typeof和string"><a href="#避免锁this、typeof和string" class="headerlink" title="避免锁this、typeof和string"></a>避免锁this、typeof和string</h3><p>  this虽然只有实例自身内部的代码能用this关键字来阻塞，但创建实例的调用者仍可将那个实例传给一个同步锁。typeof和this差不多，但是用于静态类型，也会出现错误</p>
<p>结果就是对两套不同的数据进行同步的两个同步块可能相互阻塞。虽然看起来不太可能，但共享同一个同步目标可能影响性能，极端的时候甚至会造成死锁。</p>
<p>string:这是因为要考虑到字符串留用问题。如同一个字符串常量在多个位置出现，那么所有位置都可能引用同一个实例，使锁定的范围大于预期。</p>
<h3 id="避免使用MethodImplAttribute同步"><a href="#避免使用MethodImplAttribute同步" class="headerlink" title="避免使用MethodImplAttribute同步"></a>避免使用MethodImplAttribute同步</h3><p>MethodImplAttribute和MethodImplOptions.Synchronized方法配合，该特性能将一个方法标记为已同步，确保每次只有一个线程执行方法。</p>
<p>本质上看成是lock(this)</p>
<h3 id="将字段声明为volatile"><a href="#将字段声明为volatile" class="headerlink" title="将字段声明为volatile"></a>将字段声明为volatile</h3><p>编译器和&#x2F;或CPU有时会对代码进行优化，使指令不按照它们的编码顺序执行，或干脆拿掉一些无用指令。</p>
<p>volatile强迫对字段的所有读写操作都在代码指定的位置发生，而不是在优化的位置发生.</p>
<blockquote>
<p>一般很少使用volatile修饰符。即便使用，也可能因为疏忽而使用不当。lock比volatile更好，除非对volatile的用法有绝对的把握。</p>
</blockquote>
<h3 id="System-Threading-Interlocked类"><a href="#System-Threading-Interlocked类" class="headerlink" title="System.Threading.Interlocked类"></a>System.Threading.Interlocked类</h3><p>相对同步代价低，直接由处理器支持，而且面向特定的同步模式(交换值、加减等)。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span>? _Data;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Initialize</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> newValue</span>)</span><br>&#123;<br>    Interlocked.CompareExchange(<br>        <span class="hljs-keyword">ref</span> _Data,newValue,<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="多个线程时的事件通知"><a href="#多个线程时的事件通知" class="headerlink" title="多个线程时的事件通知"></a>多个线程时的事件通知</h3><p>如委托可能由多个线程同时访问，就需同步委托的赋值和触发。</p>
<p>C# 6.0为这个问题提供了轻松的解决方案。使用空条件操作符(原子性操作)就可以了。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">OnTempChanged?.Invoke(<span class="hljs-keyword">this</span>,<span class="hljs-keyword">new</span> TempEventArgs(<span class="hljs-keyword">value</span>));<br></code></pre></td></tr></table></figure>

<p>之前的操作:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">TempChangedHandler localOnChange=OnTempChanged;<span class="hljs-comment">//只有一个线程会访问localOnChange实例</span><br><span class="hljs-keyword">if</span> (localOnChange!=<span class="hljs-literal">null</span>)<br>&#123;<br>    localOnChange(<br>        <span class="hljs-keyword">this</span>,<span class="hljs-keyword">new</span> TempEventArgs(<span class="hljs-keyword">value</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="同步设计最佳实践"><a href="#同步设计最佳实践" class="headerlink" title="同步设计最佳实践"></a>同步设计最佳实践</h3><ol>
<li><p>避免死锁<br>多个线程请求独占对相同的两个或多个同步目标（资源）的所有权，且以不同顺序请求锁。<br>移除其中任何一个条件，都能阻止死锁的发生:</p>
<ul>
<li>排他或互斥</li>
<li>占有并等待</li>
<li>不可抢先</li>
<li>循环等待条件</li>
</ul>
</li>
<li><p>何时提供同步<br>所有静态可变数据都应该是线程安全的</p>
<p>应声明私有静态变量，并提供公共方法来修改数据。   </p>
<p>除了显式设计成由多个线程访问的类之外，程序员在多个线程中共享对象时，应针对要共享的数据解决好它们自己的同步问题。</p>
</li>
<li><p>避免不必要的锁定，如:<br>在线程之间使用不可变的类型，避免对同步的需要<br>避免锁定本来就是线程安全的操作(如小于本机的证书的值的读写)</p>
</li>
</ol>
<h3 id="更多同步类型"><a href="#更多同步类型" class="headerlink" title="更多同步类型"></a>更多同步类型</h3><ul>
<li><p>Mutex和Monitor差不多。还可进行跨进程访问</p>
</li>
<li><p>WaitHandle众多同步类的基类</p>
</li>
</ul>
<ul>
<li><p>ManualResetEvent和ManualResetEventSlim重置事件类.提供了一个要么打开要么关闭的锁</p>
</li>
<li><p>Semaphore&#x2F;SemaphoreSlim和CountdownEve.只限制在一个关键执行区域中同时通过n个调用。信号量本质上是保持了对资源池的一个计数。计数为0就阻止对资源池更多访问，直到其中的一个资源返回。有可用资源后，就可把它拿给队列中的下一个已阻塞请求。</p>
</li>
<li><p>并发集合类实现<code>IProducerConsumerCollection&lt;T&gt;</code><br>  天生安全的不可修改集合:Immutable</p>
<h3 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h3><p>同步的一个替代方案是隔离，而实现隔离的一个办法就是使用线程本地存储，线程就有了专属的变量实例。<br>线程本地存储的实现：</p>
</li>
<li><p><code>ThreadLocal&lt;T&gt;</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;<span class="hljs-built_in">double</span>&gt; _Count =<br>        <span class="hljs-keyword">new</span> ThreadLocal&lt;<span class="hljs-built_in">double</span>&gt;(() =&gt; <span class="hljs-number">0.01134</span>);<span class="hljs-comment">//虽然字段是静态的，但却有一个不同的实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> Count<br>    &#123;<br>        <span class="hljs-keyword">get</span> =&gt; _Count.Value;<br>        <span class="hljs-keyword">set</span> =&gt; _Count.Value = <span class="hljs-keyword">value</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(Decrement);<br>        thread.Start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>        &#123;<br>            Count++;<br>        &#125;<br>        thread.Join();<br>        Console.WriteLine(<span class="hljs-string">&quot;M&quot;</span>+Count);<br>        Console.ReadKey();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Decrement</span>()</span><br>    &#123;<br>        Count = -Count;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>        &#123;<br>            Count--;<br>        &#125;<br>        Console.WriteLine(<span class="hljs-string">&quot;D&quot;</span> + Count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  由于Count基于的是ThreadLocal<T>类型的静态字段，所以运行Main()的线程和运行Decrement()的线程在_Count.Value中存储有独立的值。</p>
</li>
<li><p><code>ThreadStaticAttribute</code>老版本,而且是ThreadLocal的底层:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">ThreadStatic</span>]<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> _Count=<span class="hljs-number">0.0114</span>;<br></code></pre></td></tr></table></figure>

<p>  在“Decrement Count”显示结果没有小数部分，说明没有进行初始化</p>
<pre><code class="hljs">  _Count虽然在声明时赋值，但只有和“正在运行静态构造函数的线程”关联的线程静态实例（也就是线程本地存储变量_Count）才会被初始化。
</code></pre>
</li>
</ul>
<p>性价比分析:</p>
<ul>
<li>可为数据库链接使用线程本地存储.</li>
<li>要将经常需要的上下文信息提供给其他方法使用，同时不显式地通过参数来传递数据，如用户安全信息使用本地存储</li>
</ul>
<h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><p>async&#x2F;await(TAP)+Task.Delay()</p>
<p>TAP的一个关键功能就是async调用之后执行的代码会在支持的线程上下文中继续，从而避免UI跨线程问题。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        CancellationToken token=<span class="hljs-keyword">new</span>();<br>        Task task=TickAsync(token);<br>        task.Wait();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">TickAsync</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        CancellationToken token</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> minute = <span class="hljs-number">10</span>; minute &gt;<span class="hljs-number">0</span>; minute--)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (token.IsCancellationRequested)<br>                <span class="hljs-keyword">break</span>;<br>            Console.Write(minute);<br>            <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">100</span>);<br>            Console.Write(<span class="hljs-string">&quot;s &quot;</span>);<br>        &#125;<br>        Console.WriteLine(<span class="hljs-string">&quot;ok&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>UI线程安全的计时器:</p>
<ul>
<li>System.Windows.Forms.Timer</li>
<li>System.Windows.Threading.DispatcherTimer</li>
<li>System.Timers.Timer</li>
</ul>
<p>性能优化的计时器:System.Threading.Timer</p>
<h2 id="平台和操作性和不安全代码"><a href="#平台和操作性和不安全代码" class="headerlink" title="平台和操作性和不安全代码"></a>平台和操作性和不安全代码</h2><h3 id="平台调用"><a href="#平台调用" class="headerlink" title="平台调用"></a>平台调用</h3><p>访问非托管代码库。如访问操作系统未由托管API公开的非托管代码或避免检查&#x2F;垃圾回收</p>
<p>CLI通过P&#x2F;Invoke提供该功能，它允许对非托管DLL所导出的函数执行API调用</p>
<h3 id="声明外部函数"><a href="#声明外部函数" class="headerlink" title="声明外部函数"></a>声明外部函数</h3><p>extern声明为外部函数，无方法体，几乎都是静态方法.具体实现由DllImport特性指定.dll名称和具体的函数名称</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">VirtualMemoryManager</span><br>&#123;<br>    [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;kernel32.dll&quot;</span>,EntryPoint=<span class="hljs-string">&quot;GetCurrentProcess&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> IntPtr <span class="hljs-title">GetCurrentProcessHandle</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="参数的数据类型"><a href="#参数的数据类型" class="headerlink" title="参数的数据类型"></a>参数的数据类型</h3><p>确定目标DLL和导出的函数后，最困难的一步是标识或创建与外部函数中的非托管数据类型对应的托管数据类型<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1669728638612.png" srcset="/img/loading.gif" lazyload><br>托管代码需要为每种数据类型提供相应的定义</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;kernel32.dll&quot;</span>,SetLastError=true)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> IntPtr <span class="hljs-title">VirtualAllocEx</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        IntPtr hProcess,</span></span><br><span class="hljs-params"><span class="hljs-function">        IntPtr lpAdress,</span></span><br><span class="hljs-params"><span class="hljs-function">        IntPtr dwSize,</span></span><br><span class="hljs-params"><span class="hljs-function">        AllocationType flAllocatiuonType,//枚举类型</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">uint</span> flProtect</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>不要将内存指针HANDLE和LPVOID等类型映射为不变内存的int，而应把它们映射为System.IntPtr，其大小将随处理器内存布局而变化。</p>
<p>IntPtr并非只能表示“作为整数存储的指针”，它还能表示“指针大小的整数”</p>
<h3 id="使用ref而不是指针"><a href="#使用ref而不是指针" class="headerlink" title="使用ref而不是指针"></a>使用ref而不是指针</h3><p>许多时候，非托管代码会为传引用（pass-by-reference）参数使用指针。在这种情况下，P&#x2F;Invoke不要求在托管代码中将数据类型映射为指针。相反，应将对应参数映射为ref或out，具体取决于参数是输入&#x2F;输出，还是仅输出</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">uint</span> lpflOldProtect<br><span class="hljs-comment">/*文档中lpflOldProtect被定义为[out]参数（虽然签名没有强制要求），但在随后的描述中，又指出该参数必须指向一个有效的变量，而不能是NULL。文档出现这种自相矛盾的说法，难免令人迷惑，但这是一个很常见的情况。针对这种情况，我们的指导原则是为P/Invoke类型参数使用ref而不是out，因为被调用者总是能忽略随同ref传递的数据，反之则不然。*/</span><br></code></pre></td></tr></table></figure>

<h3 id="StructLayoutAttribute"><a href="#StructLayoutAttribute" class="headerlink" title="StructLayoutAttribute"></a>StructLayoutAttribute</h3><p>顺序布局.<br>声明API需要的类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">StructLayout(LayoutKind.Sequential)</span>]<br><span class="hljs-keyword">struct</span> ColorRef<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span> Red;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span> Green;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span> Blue;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">byte</span> Unused;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ColorRef</span>(<span class="hljs-params"><span class="hljs-built_in">byte</span> red,<span class="hljs-built_in">byte</span> green,<span class="hljs-built_in">byte</span> blue</span>)</span><br>    &#123;<br>        Blue=blue;<br>        Green=green;<br>        Red=red;<br>        Unused=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>默认情况下，托管代码可以优化类型的内存布局，所以内存布局可能不是从一个字段到另一个字段顺序存储。</p>
<p>强制顺序布局，使类型能直接映射，而且能在托管和非托管代码之间逐位拷贝，你需要添加StructLayoutAttribute并指定LayoutKind.Sequential枚举值（从文件流读写数据时，如要求顺序布局，也要这样修饰。）</p>
<p>开发者应遵循常规的C#设计规范来构思，即类型在行为上是像值类型还是像引用类型，以及大小是否很小（小于16字节才适合设计成结构）</p>
<h3 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h3><p>DllImport的SetLastError设为true。可自动用真确的错误数据初始化抛出的System.ComponentModel.Win32Exception()</p>
<p>可提供每个API所用的自定义错误检查，同时仍可通过标准方式报告错误。</p>
<h3 id="SafeHandle"><a href="#SafeHandle" class="headerlink" title="SafeHandle"></a>SafeHandle</h3><p>涉及用完需要清理的资源，如句柄。应该提供实现IDisposable和终结器的类。<br>内建支持System.Runtime.InteropServices.SafeHandle类,抽象成员IsInvalid和ReleaseHandle方法(放入资源清理代码)</p>
<h3 id="调用外部函数"><a href="#调用外部函数" class="headerlink" title="调用外部函数"></a>调用外部函数</h3><p>声明好的P&#x2F;Invoke函数可像调用其他任何类成员一样调用。注意导入的DLL必须在路径中（编辑PATH环境变量，或放在与应用程序相同的目录中）才能成功加载。</p>
<h3 id="用包装器简化API调用"><a href="#用包装器简化API调用" class="headerlink" title="用包装器简化API调用"></a>用包装器简化API调用</h3><p>无论错误处理、结构还是常量值，优秀的API开发者都应该提供一个简化的托管API将底层Win32 API包装起来</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">VirtualMemoryManager</span><br>&#123;    <br>    [<span class="hljs-meta">Flags</span>]<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">enum</span>  MemoryFreeType<br>    &#123;<br>        Decommit=<span class="hljs-number">0x1000</span>,<br>        XX=<span class="hljs-number">0x2000</span><br>    &#125;<br><br>    [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;kernel32.dll&quot;</span>,SetLastError=true)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">VirtualFreeEx</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        IntPtr hProcess,IntPtr lpAddress,</span></span><br><span class="hljs-params"><span class="hljs-function">        IntPtr dwSize,IntPtr dwFreeType</span>)</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">VirtualFreeEx</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        IntPtr hProcess, IntPtr lpAddress,</span></span><br><span class="hljs-params"><span class="hljs-function">        IntPtr dwSize</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">bool</span> result=VirtualFreeEx(hProcess,<br>            lpAddress,dwSize,<br>            (IntPtr)MemoryFreeType.Decommit);<br>        <span class="hljs-keyword">if</span> (!result)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> System.ComponentModel.Win32Exception();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">VirtualFreeEx</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        IntPtr lpAddress,IntPtr dwSize</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> VirtualFreeEx(GetCurrentProcessHandle(),lpAddress,dwSize);<br>    &#125;<br><br>    [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;kernel32.dll&quot;</span>,SetLastError=true)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> IntPtr <span class="hljs-title">VirtualFreeEx</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        IntPtr hProcess, IntPtr lpAddress,</span></span><br><span class="hljs-params"><span class="hljs-function">        IntPtr dwSize,</span></span><br><span class="hljs-params"><span class="hljs-function">        AllocationType flAllocationType,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">uint</span> flProtect</span>)</span>;<br><br>    <span class="hljs-comment">//...    </span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="指针映射委托"><a href="#指针映射委托" class="headerlink" title="指针映射委托"></a>指针映射委托</h3><p>例如，为了设置计时器，需提供一个到期后能由计时器回调的函数指针。具体地说，需传递一个与回调签名匹配的委托实例。</p>
<h3 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h3><ul>
<li>不要无谓重复现有的、已经能执行非托管API功能的托管类</li>
<li>要将外部方法声明为私有或内部</li>
</ul>
<ul>
<li>要提供使用了托管约定的公共包装器方法，包括结构化异常处理、为特殊值使用枚举等。</li>
<li>要为非必需参数选择默认值来简化包装器方法。</li>
<li>要用SetLastErrorAttribute将使用SetLastError错误码的API转换成抛出Win32-Exception的方法（在Windows上）要用SetLastErrorAttribute将使用SetLastError错误码的API转换成抛出Win32-Exception的方法（在Windows上）</li>
<li>要扩展SafeHandle或实现IDisposable并创建终结器来确保非托管资源被高效清理</li>
<li>要在非托管API需要函数指针的时候使用和所需方法的签名匹配的委托类型</li>
<li>要尽量使用ref参数而不是指针类型</li>
</ul>
<h3 id="指针和地址"><a href="#指针和地址" class="headerlink" title="指针和地址"></a>指针和地址</h3><p>在操纵内存映射设备或实现时间关键算法的时候，C#通过“不安全代码”构造提供这方面的支持。</p>
<h3 id="不安全代码"><a href="#不安全代码" class="headerlink" title="不安全代码"></a>不安全代码</h3><p>c#强类型，运行时类型检查.<br><code>unsafe</code>修饰或代码块.本质是预处理指令.</p>
<p>在不安全代码块中可使用指针之类的不安全构造.</p>
<p>需要显示通知编译器:文件AllowUnsafeBlocks设为true</p>
<h3 id="指针声明"><a href="#指针声明" class="headerlink" title="指针声明"></a>指针声明</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">byte</span>* pData;<br></code></pre></td></tr></table></figure>

<p>pData的值代表一个或多个连续字节的内存位置的地址<br><code>*</code>之前指定的类型是被引用类型，指针指向的位置存储的值的类型</p>
<p>因为指针是指向内存地址的整数，所以不会被垃圾回收。<br>c#不允许非托管类型以外的被引用类型，如引用类型泛型类型，或者包含这些类型.</p>
<p>指针类型的终极基类System.IntPtr才可转换为object</p>
<h3 id="指针赋值"><a href="#指针赋值" class="headerlink" title="指针赋值"></a>指针赋值</h3><p>指针默认值为null</p>
<p><code>&amp;</code>获取值类型的地址</p>
<p>要求:</p>
<ul>
<li><p>数据必须属于一个变量</p>
</li>
<li><p>数据必须是非托管类型</p>
</li>
<li><p>变量需要用fixed固定.不能移动.如数组就不是固定的.</p>
</li>
<li><p>fixed的代码块中，赋值的数据不会移动</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">fixed</span>(<span class="hljs-built_in">byte</span>* pData=&amp;bytes[<span class="hljs-number">0</span>])&#123;&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>可用缩写的bytes取代冗长的&amp;bytes[0]赋值</p>
<p>可声明<code>char*</code>类型的指针赋值给string</p>
<p>fixed语句可能导致内存堆中出现碎片，最好的做法是在执行前期就固定好代码块.</p>
<ul>
<li><p>stackalloc在栈上分配内存，也可以防止GC移动数据</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">byte</span>* bytes=<span class="hljs-keyword">stackalloc</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">42</span>];<br></code></pre></td></tr></table></figure>

<p>一般情况下，程序只有不到1 MB的栈空间（实际可能更少）</p>
</li>
</ul>
<h3 id="指针解引用"><a href="#指针解引用" class="headerlink" title="指针解引用"></a>指针解引用</h3><p>指针要进行解引用才能访问指针引用的一个类型的值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">byte</span> data=*pData;<br></code></pre></td></tr></table></figure>

<p>它的作用是解引用pData所引用的byte所在的位置，并生成一个byte类型的变量<br>提供该位置的单个的byte的读写</p>
<p>指针间的比较实际会转变成地址位置值的比较</p>
<p>不能对<code>void*</code>的指针进行解引用。必须把它转换成其他任何指针类型的变量，然后对后一种类型执行解引用。</p>
<h3 id="访问成员"><a href="#访问成员" class="headerlink" title="访问成员"></a>访问成员</h3><p><code>x-&gt;y</code>是<code>(*x).y</code>的简化形式</p>
<h2 id="通过委托执行不安全代码"><a href="#通过委托执行不安全代码" class="headerlink" title="通过委托执行不安全代码"></a>通过委托执行不安全代码</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">unsafe</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodInvoker</span>(<span class="hljs-params"><span class="hljs-built_in">byte</span>* buffer</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">ChapterMain</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))<br>        &#123;<br>            <span class="hljs-keyword">unsafe</span><br>            &#123;<br>                <span class="hljs-built_in">byte</span>[] codeBytes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[]&#123;<br>                    <span class="hljs-number">0x49</span>,<span class="hljs-number">0x89</span>,<span class="hljs-number">0xd8</span>,<br>                    <span class="hljs-number">0x49</span>,<span class="hljs-number">0x89</span>,<span class="hljs-number">0xc9</span>,<br>                    <span class="hljs-number">0x48</span>,<span class="hljs-number">0x31</span>,<span class="hljs-number">0xc8</span>,<br>                    <span class="hljs-number">0x0f</span>,<span class="hljs-number">0xa2</span>,<br>                    <span class="hljs-number">0x4c</span>,<span class="hljs-number">0x89</span>,<span class="hljs-number">0xc8</span>,<br>                    <span class="hljs-number">0x89</span>,<span class="hljs-number">0x18</span>,<br>                    <span class="hljs-number">0x89</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0x04</span>,<br>                    <span class="hljs-number">0x89</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x08</span>,<br>                    <span class="hljs-number">0x4c</span>,<span class="hljs-number">0x89</span>,<span class="hljs-number">0xc3</span>,<br>                    <span class="hljs-number">0xc3</span><br>                &#125;;<br>                <span class="hljs-built_in">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">byte</span>[<span class="hljs-number">12</span>];<br><br>                <span class="hljs-keyword">using</span> (VirtualMemoryPtr codeBytesptr = <span class="hljs-keyword">new</span> VirtualMemoryPtr(codeBytes.Length))<br>                &#123;<br>                    Marshal.Copy(<br>                    codeBytes, <span class="hljs-number">0</span>,<br>                    codeBytesptr, codeBytes.Length);<br>                    MethodInvoker method = Marshal.<br>                    <span class="hljs-comment"><span class="hljs-doctag">///</span></span><br>                    GetDelegateForFunctionPointer&lt;MethodInvoker&gt;(codeBytesptr);<br>                    <span class="hljs-comment"><span class="hljs-doctag">///</span></span><br>                    <span class="hljs-keyword">fixed</span> (<span class="hljs-built_in">byte</span>* newBuffer = &amp;buffer[<span class="hljs-number">0</span>])<br>                    &#123;<br>                        method(newBuffer);<br>                    &#125;<br>                    Console.Write(<span class="hljs-string">&quot;Processor Id:&quot;</span>);<br>                &#125;<br>                Console.WriteLine(ASCIIEncoding.ASCII.GetChars(buffer));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;this sample for windows&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="CLI-1"><a href="#CLI-1" class="headerlink" title="CLI"></a>CLI</h2><p>C#语言编译时和执行时所依赖的公共语言基础结构</p>
<p>c#生成CIL中间语言.执行时编译成机器码在代理的虚拟执行系统VES即运行时中执行</p>
<p>CIL和运行时包含在CLI中</p>
<p>CLI是理解C#程序的执行环境以及C#如何与其他程序和库（甚至是用其他语言编写的）进行无缝交互的一个重要规范<br>包含</p>
<ul>
<li>VES</li>
<li>CIL</li>
<li>CTS公共类型系统</li>
<li>CLS公共语言规范</li>
</ul>
<ul>
<li>元数据</li>
<li>框架</li>
</ul>
<h3 id="CLI实现"><a href="#CLI实现" class="headerlink" title="CLI实现"></a>CLI实现</h3><p>  。NET Core、Microsoft .NET Framework和Xamarin等</p>
<p>Microsoft .NET Framework主要包括</p>
<ul>
<li>BCL内建CLI数据类型的基础，用于支持IO、集合类、自定义特性、字符串处理</li>
<li>ASO.NET</li>
<li>WPF</li>
</ul>
<h3 id="NET-Standard"><a href="#NET-Standard" class="headerlink" title=".NET Standard"></a>.NET Standard</h3><p>跨平台，创建“类库(.NET Standard)”项目</p>
<h3 id="基类库"><a href="#基类库" class="headerlink" title="基类库"></a>基类库</h3><p>  BCL，核心类库</p>
<p>BCL包含的类库提供基础类型和API，允许程序以一致的方式和“运行时”及底层操作系统交互。BCL包含对集合、简单文件访问、安全性、基础数据类型（例如string）、流等的支持。</p>
<p>框架类库FCL包含对富客户端UI、Web UI、数据库访问、分布式通信等的支持。</p>
<h3 id="翻译成机器码"><a href="#翻译成机器码" class="headerlink" title="翻译成机器码"></a>翻译成机器码</h3><p>C#编译需要两个步骤：<br>1.C#编译器将C#转换为CIL。<br>2.将CIL转换为处理器能执行的指令。</p>
<p>“运行时”能理解CIL语句，并能将它们编译为机器码。通常要由“运行时”内部的一个组件执行从CIL到机器码的编译。该组件称为即时（just-in-time，JIT）编译器。程序安装或执行时，便可能发生JIT编译，或者说即时编译（jitting）</p>
<h3 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h3><p>即使“运行时”将CIL代码转换为机器码并开始执行，也在继续管理代码的执行。在“运行时”这样的一个代理上下文中执行的代码称为托管代码，在“运行时”控制下的执行过程称为托管执行。对执行的控制转向数据，数据就成为托管数据，因为数据所需的内存是由“运行时”自动分配和回收的。</p>
<h4 id="垃圾回收-1"><a href="#垃圾回收-1" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>据程序的需要自动分配和回收内存的过程</p>
<p>垃圾回收器只负责内存管理</p>
<p>CLI的大多数实现都使用一个分代的（generational）、支持压缩的（compacting）以及基于标记并清除（mark-and-sweep）的算法。</p>
<h4 id="平台可移植性"><a href="#平台可移植性" class="headerlink" title="平台可移植性"></a>平台可移植性</h4><p>代码的移植工作必须由“运行时”的实现来完成</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>托管环境为应用程序带来了额外开销，无论它有多简单。</p>
<p>CLI程序不一定比非CLI程序快，但性能是有竞争力的。</p>
<h4 id="程序集、清单和模块"><a href="#程序集、清单和模块" class="headerlink" title="程序集、清单和模块"></a>程序集、清单和模块</h4><p>编译器输出的通常是一个程序集，可以是类库，也可以是可执行文件本身</p>
<p>清单包括:<br>·程序集定义和导入的类型·程序集本身的版本信息·程序集依赖的其他文件·程序集的安全权限</p>
<p>模块将程序分成单独的组件，还可实现多种语言来开发一个程序集.</p>
<p>模块和程序集这两个术语偶尔可以互换。但在谈及CLI兼容程序或库的时候，首选术语是程序集</p>
<p>虽然程序集可包含多个模块和文件，但整个文件组只有一个版本号，而且该版本号被放在程序集的清单中。</p>
<h4 id="CLI-2"><a href="#CLI-2" class="headerlink" title="CLI"></a>CLI</h4><p>支持多种语言在同一个应用程序内的交互</p>
<h4 id="CTS"><a href="#CTS" class="headerlink" title="CTS"></a>CTS</h4><p>语言的互操作性<br>定义了类型的结构及其在内存中的布局，另外还规定了与类型有关的概念和行为。除了与类型中存储的数据有关的信息，CTS还包含了类型的操作指令。</p>
<p>类型分为值和对象</p>
<h4 id="CLS"><a href="#CLS" class="headerlink" title="CLS"></a>CLS</h4><p>注重库的实现.面向的是库开发者，为他们提供编写库的标准，使这些库能从大多数源语言中访问——无论使用库的源语言是否相容于CTS。</p>
<p>之所以称为公共语言规范，是因为它的另一个目的是鼓励CLI语言提供一种方式来创建可供互操作的库——或者说能从其他语言访问的库。</p>
<h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>还包含与程序中包含的类型和文件有关的元数据</p>
<p>·程序或类库中每一个类型的描述；<br>·清单信息，包括与程序本身有关的数据，以及它依赖的库；<br>·在代码中嵌入的自定义特性，提供与特性所修饰的构造有关的额外信息。</p>
<h4 id="NET-Native和AOT编译"><a href="#NET-Native和AOT编译" class="headerlink" title=".NET Native和AOT编译"></a>.NET Native和AOT编译</h4><p>.NET Native功能（由.NET Core和最近的.NET Framework实现支持）用于创建平台特有的可执行文件。这称为AOT（Ahead Of Time）编译。</p>
<h5 id="NET-Native由于避免了对代码进行JIT编译，所以使用C-编程也能达到原生代码的性能和更快的启动速度。"><a href="#NET-Native由于避免了对代码进行JIT编译，所以使用C-编程也能达到原生代码的性能和更快的启动速度。" class="headerlink" title=".NET Native由于避免了对代码进行JIT编译，所以使用C#编程也能达到原生代码的性能和更快的启动速度。"></a>.NET Native由于避免了对代码进行JIT编译，所以使用C#编程也能达到原生代码的性能和更快的启动速度。</h5><p>学习资料:<br><a target="_blank" rel="noopener" href="https://weread.qq.com/web/reader/16d32eb07297616a16d8f40k81232fb025f812b4ba28a23">c#8.0本质论</a>+</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0/" class="category-chain-item">学习</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/c/" class="category-chain-item">c#</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>c#学习笔记</div>
      <div>http://tupi00.github.io/2022/12/01/skill/csharp/csharp/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>tupi</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年12月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/30/skill/csharp/csharp%E7%B1%BB%E5%BA%93%E5%AD%A6%E4%B9%A0-BCL/" title="">
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    

  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

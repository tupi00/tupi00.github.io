

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>

<meta name="referrer" content="no-referrer" />


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#1f3144">
  <meta name="author" content="tupi">
  <meta name="keywords" content="unity">
  
    <meta name="description" content="title: 数据结构和算法的学习date: 1669967503019category_bar: trueindex_img: https:&#x2F;&#x2F;blog-1314860893.cos.ap-nanjing.myqcloud.com&#x2F;v2-4537af4143f242a63266873ccece7196_720w%20(1).webpcategories:   [学习] [数据结构和算法]">
<meta property="og:type" content="article">
<meta property="og:title" content="tupi的博客">
<meta property="og:url" content="http://tupi00.github.io/2022/12/02/skill/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="tupi的博客">
<meta property="og:description" content="title: 数据结构和算法的学习date: 1669967503019category_bar: trueindex_img: https:&#x2F;&#x2F;blog-1314860893.cos.ap-nanjing.myqcloud.com&#x2F;v2-4537af4143f242a63266873ccece7196_720w%20(1).webpcategories:   [学习] [数据结构和算法]">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/v2-4537af4143f242a63266873ccece7196_720w%20(1).webp">
<meta property="article:published_time" content="2022-12-02T07:51:43.019Z">
<meta property="article:modified_time" content="2022-12-10T13:17:57.425Z">
<meta property="article:author" content="tupi">
<meta property="article:tag" content="unity">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/v2-4537af4143f242a63266873ccece7196_720w%20(1).webp">
  
  
  
  <title>tupi的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tupi00.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>归来</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        tupi
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-12-02 15:51" pubdate>
          2022年12月2日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          99 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none"></h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：6 分钟前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <hr>
<p>title: 数据结构和算法的学习<br>date: 1669967503019<br>category_bar: true<br>index_img: <a target="_blank" rel="noopener" href="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/v2-4537af4143f242a63266873ccece7196_720w%20(1).webp">https://blog-1314860893.cos.ap-nanjing.myqcloud.com/v2-4537af4143f242a63266873ccece7196_720w%20(1).webp</a><br>categories: </p>
<ul>
<li>[学习]</li>
<li>[数据结构和算法]</li>
</ul>
<hr>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/v2-4537af4143f242a63266873ccece7196_720w%20(1).webp" srcset="/img/loading.gif" lazyload><br>将进酒<br>李白 〔唐代〕</p>
<p>君不见黄河之水天上来，奔流到海不复回。<br>君不见高堂明镜悲白发，朝如青丝暮成雪。<br>人得意须尽欢，莫使金樽空对月。<br>天生我材必有用，千金散尽还复来。<br>烹羊宰牛且为乐，会须一饮三百杯。<br>岑夫子，丹丘生，将进酒，杯莫停。<br>与君歌一曲，请君为我倾耳听。<br>钟鼓馔玉不足贵，但愿长醉不愿醒。<br>古来圣贤皆寂寞，惟有饮者留其名。<br>陈王昔时宴平乐，斗酒十千恣欢谑。<br>主人何为言少钱，径须沽取对君酌。<br>五花马、千金裘，呼儿将出换美酒，与尔同销万古愁。</p>
<hr>
<p>程序设计&#x3D;数据结构+算法<br>    数据:可被输入和处理的符号集合<br>        数据元素:一条记录<br>            数据项<br>        数据对象:性质相同的数据元素的集合<br>        数据结构:相互之间特定关系的数据元素的集合<br>            逻辑结构:数据元素间关系<br>                集合结构:数据元素属于同一个集合,平等<br>                线性结构:一对一关系<br>                树形结构:一对多的层次关系<br>                图形结构:多对多的关系<br>            物理结构:存储形式<br>                顺序存储：连续的物理位置，数组<br>                链式存储：不连续的物理位置，结点(数据+指针)<br>    抽象数据类型<br>        原子类型:整形、字符型、实数<br>        结构类型:若干个类型组成<br>        抽象:抽出事物具有的普遍性的本质<br>    算法:解决特定问题求解步骤的描述,有限序列<br>        输入<br>        输出<br>        有穷性<br>        确定性<br>        可行性<br>    空间复杂度<br>    时间复杂度:大O阶数<br>        常数阶<br>        对数阶:每次for都更进一大步<br>        线性阶<br>        nlongn阶<br>        平方阶:两层for<br>        指数阶<br>    最坏和平均</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>线性表<br>零个或多个数据元素的有限序列。</p>
<h2 id="顺序列表"><a href="#顺序列表" class="headerlink" title="顺序列表"></a>顺序列表</h2><p>顺序表</p>
<p>存储空间的起始位置:数组data<br>线性表最大容量:maxSize<br>线性表当前容量:length</p>
<p>获取:通过数组索引获取.O(1)<br>增加:索引后每个元素位置+1.O(n)<br>    从后先前<br>删除:索引后每个元素位置-1.O(n)<br>    从前往后</p>
<pre><code class="c#">class SeqList
&#123;
    public int[] data;
    public int length;
    public int maxSize;

    public SeqList(int maxSize)
    &#123;
        this.maxSize = maxSize;
        data = new int[maxSize];
        length=0;
    &#125;

    public int GetElem(int index)
    &#123;
        Judge(index);
        return data[index];
    &#125;

    public void Insert(int elem, int index)
    &#123;
        Judge(index);
        if (length==maxSize)
        &#123;
            throw new Exception(&quot;线性表已满&quot;);
        &#125;
        for (int i = length; i &gt; index; i--)
        &#123;
            data[i] = data[i-1];
        &#125;
        data[index] = elem;
        length++;
    &#125;
    public void Delete(int index)
    &#123;
        Judge(index);
        for (int i = index; i &lt; length-1; i++)
        &#123;
            data[i]=data[i+1];
        &#125;
        length--;
    &#125;
    void Judge(int index)
    &#123;
        if (index &gt; length || index &lt; 0)
        &#123;
            throw new Exception($&quot;容量为&#123;maxSize&#125;,长度为&#123;length&#125;,输入为&#123;index&#125;&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>c#实现 <code>List&lt;T&gt;</code></p>
<ul>
<li>易读取;元素关系间简单</li>
<li>不易增删;长度要确定;存储空间碎片化</li>
</ul>
<h2 id="链式列表"><a href="#链式列表" class="headerlink" title="链式列表"></a>链式列表</h2><p>链表LinkList</p>
<p>数据元素:结点Node<br>    存储的数据:data<br>    指向下一个结点:node<br>起始位置的头结点:head<br>数据长度length</p>
<p>查询GetElem:根据遍历index次next	O(n)<br>增加Add:先找到结点:		找出后为O(1)<br>    head 头结点为自己，自己的next原头部的next<br>    其他 上一个的next为自己，自己的next为index结点<br>删除Delete:	先找到结点:		找出后为O(1)<br>    head head&#x3D;head.next<br>    其他 index上一个的next&#x3D;index的next</p>
<pre><code class="c#">public class LinkList
&#123;
    public class Node
    &#123;
        public Node next;
        public int data;
    &#125;
    
    public int length=0;
    public Node head;
    
    public Node GetElem(int index)
    &#123;
        Node temp=head;
        for (int i = 0; i &lt; index; i++)
        &#123;
            temp=temp.next;
        &#125;
        return temp;
    &#125;
    public void Insert(int value,int index)
    &#123;
        Judge(index);
        Node node = new Node() &#123; data = value&#125;;
        if (index==0)
        &#123;
            node.next=head;
            head=node;
        &#125;
        else
        &#123;
            Node temp = GetElem(index - 1);
            node.next = temp.next;
            temp.next = node;
        &#125;
        length++;
    &#125;
    public void Delete(int index)
    &#123;
        Judge(index);
        if (index==length)
        &#123;
            throw new Exception(&quot;超出范围&quot;);
        &#125;
        if (index==0)
        &#123;
            head=head.next;
        &#125;
        else
        &#123;
            Node node=GetElem(index-1);
            node.next=node.next.next;
        &#125;
        length--;
    &#125;
    void Judge(int index)
    &#123;
        if (index&lt;0||index&gt;length)
        &#123;
            throw new Exception(&quot;超出范围&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>c#实现 <code>LinkedList</code>双向链表</p>
<ul>
<li>增删快，个数无限，随意分配</li>
<li>查找慢</li>
</ul>
<h2 id="其他表"><a href="#其他表" class="headerlink" title="其他表"></a>其他表</h2><ul>
<li>静态链表:用数组实现链表</li>
<li>循环链表:链表末尾结点指向头结点</li>
<li>双向链表:每个结点可以指向前驱结点</li>
</ul>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>Stack限定仅在表尾进行插入和删除操作的线性表<br>后进后出<br>栈顶出栈.</p>
<p>插入push	O(1)<br>删除pop	O(1)</p>
<blockquote>
<p>c#实现 Stack</p>
</blockquote>
<h2 id="顺序存储结构-栈"><a href="#顺序存储结构-栈" class="headerlink" title="顺序存储结构-栈"></a>顺序存储结构-栈</h2><p>SeqStack<br>底层数据data<br>栈顶指针top -1开始</p>
<pre><code class="c#">class SeqStack
&#123;
    int[] data;
    public int top;
    public SeqStack(int maxSize)
    &#123;
        data=new int[maxSize];
        top=-1;
    &#125;
    public int GetElem(int index)
    &#123;
        Judge(index);
        return data[index];
    &#125;
    public void Push(int elem)
    &#123;
        if ((top + 1) == data.Length)
        &#123;
            throw new NotImplementedException();
        &#125;
        top++;
        data[top]=elem;
    &#125;
    public void Pop()
    &#123;
        if (top==-1)
        &#123;
            throw new NotImplementedException();
        &#125;
        top--;
    &#125;

    void Judge(int index)
    &#123;
        if (index&gt;top||index&lt;0)
        &#123;
            throw new NotImplementedException();
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li>只准栈顶进出元素</li>
<li>需要确定数组大小</li>
</ul>
<h3 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h3><p>一个数组被两个栈使用</p>
<p>让一个栈的栈底为数组的始端，即下标为0处，另一个栈为栈的末端，即下标为数组长度n－1处</p>
<p>两个栈见面之时，也就是两个指针之间相差1时，即top1+1&#x3D;&#x3D;top2为栈满。</p>
<h2 id="链式存储栈"><a href="#链式存储栈" class="headerlink" title="链式存储栈"></a>链式存储栈</h2><p>链栈.<br>将栈顶放在链表的头部.<br>栈顶成为头结点，头插法.</p>
<p>栈顶结点:top<br>结点个数:count</p>
<pre><code class="c#">class LinkStack
&#123;
    public class Node
    &#123;
        public Node next;
        public int data;
    &#125;
    public Node top;
    public int count;
    
    public LinkStack()
    &#123;
        top=new Node();
        count=0;
    &#125;	
    public int GetElem(int index)
    &#123;
        Judge(index);
        Node temp=top;
        if (index==0)
        &#123;
            
        &#125;
        else
        &#123;
            for (int i = 0; i &lt; index; i++)
            &#123;
                temp = temp.next;
            &#125;
        &#125;
        return temp.data;
    &#125;
    public void Push(int data)
    &#123;
        Node node = new Node() &#123; data = data &#125;;
        if (count == 0)
        &#123;
            top = node;
        &#125;
        else
        &#123;
            node.next = top;
            top = node;
        &#125;
        count++;
    &#125;
    public void Pop()
    &#123;
        if (count==0)
        &#123;
            throw new NotImplementedException();
        &#125;
        top=top.next;
        count--;
    &#125;
    void Judge(int index)
    &#123;
        if (index&lt;0||index&gt;count)
        &#123;
            throw new NotImplementedException();
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li>不存在栈满,无确定的空间浪费</li>
<li>存取不方便，指针开销</li>
</ul>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数.<br>    每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出</p>
<p>递归的计算机基础是栈</p>
<p>斐波那契数列实现 1 1 2 3 5 8 13…</p>
<pre><code class="c#">Console.WriteLine(Fib(6));
int Fib(int num)
&#123;
    if (num &lt; 2)
    &#123;
        return 1;
    &#125;
    return Fib(num-1)+Fib(num-2);
&#125;
</code></pre>
<h2 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h2><p>四则运算表达式求值</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>只允许在一端进行插入操作、而在另一端进行删除操作的线性表<br>先进先出，插入队尾，删除队头</p>
<p>队头front<br>队尾rear</p>
<blockquote>
<p>c#实现 Queue</p>
</blockquote>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>解决顺序队列存储不足的问题<br>队头不一定要在下标0处<br>留下一个元素用来判断队列满</p>
<p>空队列 <code>front==rear</code> 队头有元素.<br>获取元素	(front+index)%data.Length<br>队满 <code>（rear+1）%maxSize==front</code><br>通用队列长度 <code>(rear－front+QueueSize)%QueueSize</code><br>假溢出时，rear从0开始 <code>rear==(rear+1)%data.Length</code></p>
<pre><code class="c#">class SeqQueue
&#123;
    public int[] data;
    int front;
    int rear;

    public int Head &#123;get=&gt;front;&#125;
    public int Length &#123; get =&gt; (rear - front + data.Length) % data.Length; &#125;
    public SeqQueue(int length)
    &#123;
        data = new int[length];
        front = 0;
        rear = 0;
    &#125;
    public int GetElem(int index)
    &#123;
        if(front==rear)
        &#123;
            throw new Exception(&quot;无元素&quot;);
        &#125;
        return data[(front+index)%data.Length];
    &#125;
    public void EnQueue(int elem)
    &#123;
        if((rear+1)%data.Length==front)
           throw new();
        if(rear==(rear+1)%data.Length)
           rear=0;
            
        data[rear] = elem;
        rear=(rear+1)%data.Length;
    &#125;
    public void DeQueue()
    &#123;
        if(rear==front)
        throw new();
        front=(front+1)%data.Length;
    &#125;
&#125;```
## 链队
```c#
class LinkQueue
&#123;
    public class QNode
    &#123;
        public QNode next;
        public int data;
    &#125;
    QNode front=new();
    QNode rear=new();
    public LinkQueue()
    &#123;
        front=rear;
    &#125;
    
    public void EnQueue(int data)
    &#123;
        QNode elem = new QNode() &#123;data=data&#125;;
        rear.next = elem;
        rear = elem;
    &#125;
    public void DeQueue()
    &#123;
        if (front==rear)
        &#123;
            throw new Exception();
        &#125;
        front=front.next;
    &#125;
    public void Print()
    &#123;
        QNode node=front;
        while (true)
        &#123;
            if (node==null)
            &#123;
                break;
            &#125;
            Console.Write(node.data);
            node=node.next;
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><p>零个或多个字符组成的有限序列，又名叫字符串</p>
<p>末尾<code>\0</code></p>
<p>按长度和ASCII码比较</p>
<h2 id="KMP模式匹配算法"><a href="#KMP模式匹配算法" class="headerlink" title="KMP模式匹配算法"></a>KMP模式匹配算法</h2><p>其关键是利用匹配失败后的信息,尽量减少模式串与主串的匹配次数以达到快速匹配的目的<br>用首字母查询，固定长度遍历.避免重复查询操作.用空间换时间</p>
<p>next数组，元素前面的字符串的前缀和后缀相等长度+1(因为要跑到已经判断的元素的后面再去判断)。如<code>ababaaaba 为011234223</code> a:无前缀为-1+1&#x3D;0 ab:无 aba:a-a长1 abab:ab-ab长2 ababa:aba-aba长3</p>
<pre><code class="c#">public class KMP
&#123;
    static void Main(string[] args)
    &#123;
        Console.WriteLine(KMP.GetIndex(&quot;aaadbcxdbc&quot;, &quot;dbc&quot;));
    &#125;
    public static int[] GetNext(String ps)
    &#123;
        char[] p = ps.ToArray();
        int[] next = new int[p.Length];
        next[0] = -1;//0上的元素无前后缀
        int j = 0;
        int k = -1;
        while (j &lt; p.Length - 1)
        &#123;
            if (k == -1 || p[j] == p[k])//p[j]表示后缀的单个字符，p[k]为前缀的单个字符
            &#123;
                next[++j] = ++k;//记录在案
            &#125;
            else
            &#123;
                k = next[k];//回溯
            &#125;
        &#125;
        return next;
    &#125;

    public static int GetIndex(String ts, String ps)
    &#123;
        char[] t = ts.ToArray();
        char[] p = ps.ToArray();
        int i = 0; // 主串的位置
        int j = 0; // 模式串的位置
        int[] next = GetNext(ps);
        while (i &lt; t.Length &amp;&amp; j &lt; p.Length)
        &#123;
            if (j == -1 || t[i] == p[j])
            &#123;
                i++;
                j++;
                
                if (j == p.Length)//全部相等，返回下标
                    return i - j;
            &#125;
            else
            &#123;
                j = next[j]; // j回到指定位置
            &#125;
        &#125;
        return -1;
    &#125;
&#125;
</code></pre>
<p>算法改进:<br>S&#x3D;“aaaabcde”，子串T&#x3D;“aaaaax”，其next数组值分别为012345<br>会在i&#x3D;5上再次多余4次(j&#x3D;4,3,2,1)判断,可直接到i&#x3D;6判断</p>
<pre><code class="c#">public static int[] GetNextVal(String ps)
    &#123;
        char[] p = ps.ToArray();
        int[] nextval = new int[p.Length];
        nextval[0] = -1;
        int j = 0;
        int k = -1;
        while (j &lt; p.Length - 1)
        &#123;
            if (k == -1 || p[j] == p[k])
            &#123;
                ++j;
                ++k;
                if (p[j]!=p[k])//当前字符和前缀字符不同
                &#123;
                    nextval[j]=k;//则当前的k为nextval在j位置上的值
                &#125;
                else
                &#123;
                    nextval[j]=nextval[k];//如果相同则将前缀字符的nextval值赋值给nextval在j位置的值
                &#125;
            &#125;
            else
            &#123;
                k = nextval[k];//回溯
            &#125;
        &#125;
        return nextval;
    &#125;
</code></pre>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>n个结点的有限集，每个集本身也是个树.<br>递归.</p>
<p>子树之间不相交</p>
<p>子树数为结点的度，横向<br>度为0的结点为叶结点<br>度不为0的称为分支结点<br>树的度是各个结点的度的最大值(子结点最多的个数)</p>
<p>结点关系:<br>子树的根为结点的Child；该结点称为孩子的Parent;同一个双亲的孩子之间互称Sibling</p>
<p>层次,纵向<br>深度为拥有树的最大层次(故从0开始)，也称高度.</p>
<p>有序树:各子树从左到右有次序，无法交换</p>
<p>森林是m棵互不相交的树的集合</p>
<p>树由一个根结点和若干个子树构成.<br>结点具有相同的数据类型和层次关系</p>
<p>树的存储结构:</p>
<ol>
<li>双亲表示法  data parent </li>
<li>孩子表示法  data child1 child2</li>
<li>孩子兄弟表示法 data firstchild rightslib</li>
</ol>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是特殊的树，每个结点最多两个子结点，为左右子树<br>斜树:只有做左结点或只有右结点<br>满二叉树:除了最后一层其他层都有两个结点<br>完全二叉树:最后与层可以有空，但是有顺序的空，前满后空.</p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>第i层最多:2^(i-1)个结点<br>    第三层为2<em>2&#x3D;4个<br>深度为k的二叉树最多有2^k-1个节点<br>    第一层为1&#x3D;2^0-1<br>度数:n0&#x3D;n2＋1<br>完全二叉树的深度为(log 2 n)+1<br>完全二叉树第i层:<br>    i&#x3D;1为根<br>    i&gt;1则双亲是i&#x2F;2<br>    2</em>i&gt;n则无左孩子;否则左孩子的节点为2<em>i<br>    2</em>i+1&gt;n则无右孩子;否则右孩子的节点为2*i+1</p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><ul>
<li>顺序存储: 从上到下，从左到右 ^表示不存在</li>
</ul>
<pre><code class="c#">class BitTree
&#123;
    record BitNode
    &#123;
        BitNode lchild;
        BitNode rchild;
        int data;
    &#125;
    BitNode[] nodes;
    int Count &#123;get=&gt;nodes.Length;&#125;
&#125;
</code></pre>
<ul>
<li>二叉链表：lchild表示左孩子，data数据,rchild表示右孩子</li>
</ul>
<pre><code class="c#">class BitTree
&#123;
    record BitNode
    &#123;
        BitNode lchild;
        BitNode rchild;
        int data;
    &#125;
    BitNode root;
&#125;
</code></pre>
<h3 id="建立二叉树"><a href="#建立二叉树" class="headerlink" title="建立二叉树"></a>建立二叉树</h3><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树:"></a>遍历二叉树:</h3><ul>
<li>前序遍历<br>  先访问根结点，再访问完左结点，最后访问右结点<br>  嫡长子继承制度<br>  ABDGHCEIF</li>
<li>中序遍历<br>  先访问根结点的左子树，再访问根节点，最后访问右子树<br>  找父再找弟<br>  GDHBAEICF</li>
<li>后序遍历<br>  从左到右访问叶子后访问左右子树，最后访问根结点<br>  先兄弟再找父亲<br>  GHDBIEFCA</li>
<li>层序遍历<br>  从根结点开始，从上到下，从左到右<br>  辈分<br>  ABCDEFGHI</li>
</ul>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>使序列成为一个按关键字有序的序列操作.</p>
<p>稳定性:多关键字时,主次关系是否影响到顺序</p>
<p>内排序:排序过程中所有记录都在内存中<br>外排序:排序过程需要多次交换内外存中的数据.</p>
<p>案例数据:</p>
<pre><code class="c#">public class SqList
&#123;
    int[] _data;

    public int Length &#123; get =&gt; _data.Length; &#125;

    public int this[int index]
    &#123;
        get =&gt; _data[index];
        set =&gt; _data[index] = value;
    &#125;
    public SqList(int[] data)
    &#123;
        _data = data;
    &#125;
        
    public void Swap(int index1, int index2)
    &#123;
        int temp = _data[index1];
        _data[index1] = _data[index2];
        _data[index2] = temp;
    &#125;
    public void Print()
    &#123;
        for (int i = 0; i &lt; Length; i++)
        &#123;
            Console.Write(_data[i] + &quot; &quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="暴力排序"><a href="#暴力排序" class="headerlink" title="暴力排序"></a>暴力排序</h2><pre><code class="c#">class SortUtil
&#123;
    public static void Sort(SqList list)
    &#123;
        for (int i = 0; i &lt; list.Length; i++)
        &#123;
            for (int j = i + 1; j &lt; list.Length; j++)
            &#123;
                if (list[i] &gt; list[j])
                &#123;
                    list.Swap(i, j);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>有很多的不必要操作。排序一位对其他的关键字没有帮助</p>
<h2 id="冒泡算法"><a href="#冒泡算法" class="headerlink" title="冒泡算法"></a>冒泡算法</h2><p>两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止</p>
<pre><code class="c#">class BubbleSort
&#123;
    public static void Sort(SqList list)
    &#123;
        for (int i = 0; i &lt; list.Length; i++)
        &#123;
            for (int j = list.Length-1; j &gt;i; j--)
            &#123;
                if (list[i] &gt; list[j])
                &#123;
                    list.Swap(i, j);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>较小值放在前面。<br>泡往上升，如果比自己小就代替自己往上升.</p>
<p>优化:对半排序的队列排序,{2,1,3,4,5,6,7,8,9}除前面几个外都排好了.无需全部冒泡</p>
<pre><code class="c#">public static void Sort(SqList list)
&#123;
    bool flag=true;
    for (int i = 0; i &lt; list.Length&amp;&amp;flag; i++)
    &#123;
        flag=false;
        for (int j = list.Length-1; j &gt;i; j--)
        &#123;
            //Console.Write($&quot;&#123;i&#125;-&#123;j&#125;;&quot;);/*用来看冒泡了几次*/
            if (list[i] &gt; list[j])
            &#123;
                list.Swap(i, j);
                flag=true;/*有数据交换就插旗*/
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>时间复杂度为O(n^2)</p>
<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>选出最小的，放到前面</p>
<pre><code class="c#">class SelectSort
&#123;
    public static void Sort(SqList list)
    &#123;
        int min;/*最小值的下标*/
        for (int i = 0; i &lt; list.Length; i++)
        &#123;
            min=i;
            for(int j=i+1;j&lt;list.Length;j++)
            &#123;
                if(list[i]&gt;list[j])
                &#123;
                    min=j;
                &#125;
            &#125;
            list.Swap(i,min);
        &#125;
    &#125;
&#125;
</code></pre>
<p>时间复杂度为O(n^2)。但是性能略优于冒泡排序</p>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>将一个记录插入到已经排序好的有序表中.</p>
<pre><code class="c#">internal static void InsertSort(SqList list)
&#123;
    for(int i=1;i&lt;list.Length;i++)
    &#123;
        if (list[i] &lt; list[i - 1])/*记录需要插入到指定位置，其他元素向后移动*/
        &#123;
            int temp=list[i];
            int j;
            /*让每个大于temp的后移*/
            for (j = i - 1;j &gt;= 0/*防止下标溢出*/&amp;&amp;list[j] &gt; temp ;j--)
            &#123;
                list[j+1]=list[j];
            &#125;
            list[j+1]=temp;
        &#125;
    &#125;
&#125;
</code></pre>
<p>时间复杂度:平均为(n*n)&#x2F;4.<br>O(n^2)</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>基本有序<br>如213456789<br>指1 5 9 3 7 8 2 4 6 1 5 1 0<br>成1 0 1 1 2 3 4 5 5 6 7 8 9<br>小的基本在前面，大的基本在后面</p>
<pre><code class="c#">internal static void ShellSort(SqList list)
&#123;
    int increment=list.Length;
    do
    &#123;
        increment=increment/3;/*增量序列*/
        for (int i = increment; i &lt; list.Length; i++)
        &#123;
            if(list[i]&lt;list[i-increment])/*插入有序增量子表*/
            &#123;
                int temp=list[i];
                int j;
                for(j=i-increment;j&gt;=0&amp;&amp;temp&lt;list[j];j-=increment)
                &#123;
                    list[j+increment]=list[j];/*记录后移*/
                &#125;
                list[j+increment]=temp;/*插入*/
            &#125;
        &#125;
    &#125;while(increment&gt;1);
&#125;
</code></pre>
<p>将相隔某个“增量”的记录组成一个子序列，实现<strong>跳跃式</strong>的移动，使得排序的效率提高。</p>
<p>增量序列最好为dlta[k]&#x3D;2^(t-k+1)-1（0≤k≤t≤[log2(n+1)]）<br>此时时间复杂度为O(n^(3&#x2F;2))。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>小顶堆:根结点比子结点小的完全二叉树<br>堆排序:将待排的序列构造出小顶堆，最小值就是堆顶的根结点，移走根结点，剩下的序列重新构建成堆，得到次小值</p>
<pre><code class="c#">internal static void HeapSort(SqList list)
&#123;
    ///构建初始小顶堆
    for (int i = list.Length / 2; i &gt;= 0; i--)
    &#123;
        HeapAdjust(list, i, list.Length);
    &#125;
    ///排序
    for (int i = list.Length - 1; i &gt;= 1; i--)
    &#123;
        list.Swap(0, i);/*将最小值放在最前面*/
        HeapAdjust(list, 0, i - 1/*剩下的长度*/);
    &#125;
    ///构建堆
    static void HeapAdjust(SqList list, int i, int length)
    &#123;
        int temp = list[i];
        for (int j = 2 * i; j &lt; length - 1; j *= 2)
        &#123;
            if (j &lt; length &amp;&amp; list[j] &lt; list[j + 1])
            &#123;
                ++j;
            &#125;
            if (temp &gt;= list[j])
            &#123;
                break;
            &#125;
            list[i] = list[j];
            i = j;
        &#125;
        list[i] = temp;
    &#125;
&#125;
</code></pre>
<p>利用完全二叉树深度是⌊log2n⌋+1的特性，效率较高</p>
<p>复杂度为O(nlogn)<br>不适合元素较少的序列<br>跳跃式不稳定的排序方法</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>通过两两合并排序后再合并，最终获得了一个有序的数组。<br>形成的也是个完全二叉树，每个结点上的数据是一个有序数组<br>递归式:</p>
<pre><code class="c#">
</code></pre>
<p>迭代式:</p>
<pre><code class="C#">
</code></pre>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://tupi00.github.io/2022/12/02/skill/数据结构和算法/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>tupi</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年12月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/01/skill/csharp/" title="c#学习笔记">
                        <span class="hidden-mobile">c#学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    

  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>



<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>

<meta name="referrer" content="no-referrer" />


<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#1f3144">
  <meta name="author" content="tupi">
  <meta name="keywords" content="unity">
  
    <meta name="description" content="行路难·其一[李白]金樽清酒斗十千，玉盘珍羞直万钱。停杯投箸不能食，拔剑四顾心茫然。欲渡黄河冰塞川，将登太行雪满山。闲来垂钓碧溪上，忽复乘舟梦日边。行路难，行路难，多歧路，今安在？长风破浪会有时，直挂云帆济沧海详情地址 规范 标识符和私有字段_驼峰 静态s_ 线程t_   常量和公共Pascal 连接字符串使用$. 频繁追加StringBuilder   new&#x2F;强转的使用var 显示声">
<meta property="og:type" content="article">
<meta property="og:title" content="c#学习">
<meta property="og:url" content="http://tupi00.github.io/2022/11/06/%E6%8A%80%E6%9C%AF/csharp/index.html">
<meta property="og:site_name" content="tupi的博客">
<meta property="og:description" content="行路难·其一[李白]金樽清酒斗十千，玉盘珍羞直万钱。停杯投箸不能食，拔剑四顾心茫然。欲渡黄河冰塞川，将登太行雪满山。闲来垂钓碧溪上，忽复乘舟梦日边。行路难，行路难，多歧路，今安在？长风破浪会有时，直挂云帆济沧海详情地址 规范 标识符和私有字段_驼峰 静态s_ 线程t_   常量和公共Pascal 连接字符串使用$. 频繁追加StringBuilder   new&#x2F;强转的使用var 显示声">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/8f43d3cb984565983b69724a9a4f1917.jpg">
<meta property="article:published_time" content="2022-11-06T11:48:12.384Z">
<meta property="article:modified_time" content="2022-11-20T14:20:13.340Z">
<meta property="article:author" content="tupi">
<meta property="article:tag" content="unity">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/8f43d3cb984565983b69724a9a4f1917.jpg">
  
  
  
  <title>c#学习 - tupi的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tupi00.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>归来</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="c#学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        tupi
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-06 19:48" pubdate>
          2022年11月6日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          33k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          276 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="学习"
        id="heading-4ef520d6cd20ba4a727af08e17e4939e" role="tab" data-toggle="collapse" href="#collapse-4ef520d6cd20ba4a727af08e17e4939e"
        aria-expanded="true"
      >
        学习
        <span class="list-group-count">(10)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-4ef520d6cd20ba4a727af08e17e4939e"
           role="tabpanel" aria-labelledby="heading-4ef520d6cd20ba4a727af08e17e4939e">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2022/11/05/%E6%8A%80%E6%9C%AF/wpf/" title="WPF学习之旅"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">WPF学习之旅</span>
        </a>
      
    
      
      
        <a href="/2022/11/06/%E6%8A%80%E6%9C%AF/csharp/" title="c#学习"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">c#学习</span>
        </a>
      
    
      
      
        <a href="/2022/11/04/%E6%8A%80%E6%9C%AF/git/" title="git"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">git</span>
        </a>
      
    
      
      
        <a href="/2022/11/06/%E5%AD%A6%E6%A0%A1/java/" title="java作业"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">java作业</span>
        </a>
      
    
      
      
        <a href="/2022/11/06/%E6%8A%80%E6%9C%AF/unity/" title="unity的学习"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">unity的学习</span>
        </a>
      
    
      
      
        <a href="/2022/11/04/%E6%8A%80%E6%9C%AF/win/" title="windows shell"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">windows shell</span>
        </a>
      
    
      
      
        <a href="/2022/11/12/%E6%8A%80%E6%9C%AF/tu/" title="图"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">图</span>
        </a>
      
    
      
      
        <a href="/2022/11/06/%E6%8A%80%E6%9C%AF/1/" title="数据结构和算法的学习"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">数据结构和算法的学习</span>
        </a>
      
    
      
      
        <a href="/2022/11/06/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" title="数据结构和算法的学习"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">数据结构和算法的学习</span>
        </a>
      
    
      
      
        <a href="/2022/11/07/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">设计模式</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="c#"
        id="heading-240aa2cec4b29c56f3bee520a8dcee7e" role="tab" data-toggle="collapse" href="#collapse-240aa2cec4b29c56f3bee520a8dcee7e"
        aria-expanded="true"
      >
        c#
        <span class="list-group-count">(4)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-240aa2cec4b29c56f3bee520a8dcee7e"
           role="tabpanel" aria-labelledby="heading-240aa2cec4b29c56f3bee520a8dcee7e">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2022/11/05/%E6%8A%80%E6%9C%AF/wpf/" title="WPF学习之旅"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">WPF学习之旅</span>
        </a>
      
    
      
      
        <a href="/2022/11/06/%E6%8A%80%E6%9C%AF/csharp/" title="c#学习"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">c#学习</span>
        </a>
      
    
      
      
        <a href="/2022/11/06/%E6%8A%80%E6%9C%AF/unity/" title="unity的学习"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">unity的学习</span>
        </a>
      
    
      
      
        <a href="/2022/11/09/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" title="学习路线"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">学习路线</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">c#学习</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：1 分钟前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/8f43d3cb984565983b69724a9a4f1917.jpg" srcset="/img/loading.gif" lazyload><br>行路难·其一<br>[李白]<br>金樽清酒斗十千，玉盘珍羞直万钱。<br>停杯投箸不能食，拔剑四顾心茫然。<br>欲渡黄河冰塞川，将登太行雪满山。<br>闲来垂钓碧溪上，忽复乘舟梦日边。<br>行路难，行路难，多歧路，今安在？<br>长风破浪会有时，直挂云帆济沧海<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/c%23%E5%9F%BA%E7%A1%80.png" srcset="/img/loading.gif" lazyload alt="知识结构"><br><a target="_blank" rel="noopener" href="https://www.zhixi.com/view/2d765ec3">详情地址</a></p>
<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><ul>
<li>标识符和私有字段<code>_</code>驼峰<ul>
<li>静态<code>s_</code></li>
<li>线程<code>t_</code></li>
</ul>
</li>
<li>常量和公共Pascal</li>
<li>连接字符串使用<code>$</code>.<ul>
<li>频繁追加<code>StringBuilder</code></li>
</ul>
</li>
<li><code>new</code>&#x2F;强转的使用<code>var</code></li>
<li>显示声明使用<code>new()</code></li>
<li>var在for用，不在foreach用</li>
<li>委托使用<code>Func</code>&#x2F;<code>Action</code></li>
<li>对象创建使用初始值</li>
<li>使用using代替finally的dispose</li>
<li>稍后不需要删除的事件处理使用lambda</li>
</ul>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul>
<li>标识符必须以字母或下划线 (_) 开头驼峰法。</li>
<li>标识符可以包含字母数字下划线。<code>@</code>前缀关键字</li>
</ul>
<h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><ul>
<li>对类型名称、命名空间和所有公共成员使用 PascalCase<ul>
<li>常量也是</li>
</ul>
</li>
<li>接口<code>I</code>开头</li>
<li>属性类型<code>Attribute</code>结尾</li>
<li>不能连续两个下划线</li>
<li>私有的<code>_</code>开头的驼峰<ul>
<li>私有静态字段<code>s_</code>开头</li>
<li>线程静态<code>t_</code></li>
</ul>
</li>
</ul>
<h3 id="布局约定"><a href="#布局约定" class="headerlink" title="布局约定"></a>布局约定</h3><ul>
<li>每行只写一条语句</li>
<li>每个花括号从新行开始</li>
<li>每行只写一个声明</li>
<li>缩进是一个制表符(四个空格)</li>
<li>方法定义与属性定义间至少一个空白行</li>
<li>括号突出表现表达式子句</li>
<li>if永远使用{}</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>请确保所有公共成员都有必要的 XML 注释，从而提供有关其行为的适当说明</li>
<li>以句点结束注释文本。</li>
<li>在注释分隔符 (<code>//</code>) 与注释文本之间插入一个空格</li>
<li>&#x2F;&#x2F;&#x2F;用来描述方法等</li>
<li>&#x2F;&#x2F;写在变量后面，描述值、</li>
<li>&#x2F;**&#x2F;用来描述思路</li>
</ul>
<h3 id="语言准则"><a href="#语言准则" class="headerlink" title="语言准则"></a>语言准则</h3><ul>
<li>总是指定可见性</li>
<li>避免使用<code>this</code>,没有被类封装，因此很难推断谁锁定了它</li>
<li>使用语言关键字而不是BCL类型</li>
<li>使所有内部类型和私有类型成为静态类型或密封类型，除非需要从它们派生。</li>
<li>字符串内插来连接短字符串:<code>string displayName = $&quot;&#123;nameList[n].LastName&#125;, &#123;nameList[n].FirstName&#125;&quot;;</code></li>
<li>若要在循环中追加字符串，尤其是在使用大量文本时，请使用 <code>StringBuilder</code> 对象。</li>
<li>当变量类型明显来自赋值的右侧时，或者当精度类型不重要时，请对本地变量进行隐式类型化<code>var</code>。</li>
<li>当类型并非明显来自赋值的右侧时，请勿使用<code>var</code>。 <ul>
<li>请勿假设类型明显来自方法名称。 </li>
<li>如果变量类型为<code>new</code>运算符或显式强制转换，则将其视为明显来自方法名称。</li>
</ul>
</li>
<li>只有在变量定义语句或字段定义语句中的左侧显式命名类型时，才能使用目标类型的<code>new()</code>。</li>
<li>请勿依靠变量名称来指定变量的类型。 它可能不正确。 在以下示例中，变量名称 inputInt 会产生误导性。 它是字符串  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> inputInt = Console.ReadLine();<br>Console.WriteLine(inputInt);<br></code></pre></td></tr></table></figure></li>
<li>避免使用 var 来代替 dynamic。 如果想要进行运行时类型推理，请使用 dynamic。</li>
<li>使用隐式类型化来确定 for 循环中循环变量的类型。  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> phrase = <span class="hljs-string">&quot;lalalalalalalalalalalalalalalalalalalalalalalalalalalalalala&quot;</span>;<br><span class="hljs-keyword">var</span> manyPhrases = <span class="hljs-keyword">new</span> StringBuilder();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>&#123;<br>   		manyPhrases.Append(phrase);<br>&#125;<br><span class="hljs-comment">//Console.WriteLine(&quot;tra&quot; + manyPhrases);</span><br></code></pre></td></tr></table></figure></li>
<li>不要使用隐式类型化来确定 foreach 循环中循环变量的类型。</li>
<li>当在声明行上初始化数组时，请使用简洁的语法。 在以下示例中，请注意不能使用 var 替代 string[]。  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span>[] vowels1 = &#123; <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;u&quot;</span> &#125;;<br></code></pre></td></tr></table></figure></li>
<li>如果使用显式实例化，则可以使用 var。  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> vowels2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;u&quot;</span> &#125;;<br></code></pre></td></tr></table></figure></li>
<li>使用 <code>Func&lt;&gt;</code> 和 <code>Action&lt;&gt;</code>，而不是定义委托类型。 在类中，定义委托方法。  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Action&lt;<span class="hljs-built_in">string</span>&gt; ActionExample1 = x =&gt; Console.WriteLine(<span class="hljs-string">$&quot;x is: <span class="hljs-subst">&#123;x&#125;</span>&quot;</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Action&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; ActionExample2 = (x, y) =&gt; <br>    Console.WriteLine(<span class="hljs-string">$&quot;x is: <span class="hljs-subst">&#123;x&#125;</span>, y is <span class="hljs-subst">&#123;y&#125;</span>&quot;</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Func&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; FuncExample1 = x =&gt; Convert.ToInt32(x);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; FuncExample2 = (x, y) =&gt; x + y;<br></code></pre></td></tr></table></figure>
<ul>
<li>使用 <code>Func&lt;&gt;</code> 或 <code>Action&lt;&gt;</code> 委托定义的签名来调用方法  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">ActionExample1(<span class="hljs-string">&quot;string for x&quot;</span>);<br>ActionExample2(<span class="hljs-string">&quot;string for x&quot;</span>, <span class="hljs-string">&quot;string for y&quot;</span>);<br>Console.WriteLine(<span class="hljs-string">$&quot;The value is <span class="hljs-subst">&#123;FuncExample1(<span class="hljs-string">&quot;1&quot;</span>)&#125;</span>&quot;</span>);<br>Console.WriteLine(<span class="hljs-string">$&quot;The sum is <span class="hljs-subst">&#123;FuncExample2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)&#125;</span>&quot;</span>);<br></code></pre></td></tr></table></figure></li>
<li>如果创建委托类型的实例，请使用简洁的语法。 在类中，定义委托类型和具有匹配签名的方法。  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#">Del exampleDel2 = DelMethod;<br>exampleDel2(<span class="hljs-string">&quot;Hey&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Del</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DelMethod</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;DelMethod argument: &#123;0&#125;&quot;</span>, str);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>对大多数异常处理使用 <code>try-catch</code> 语句。<ul>
<li>如果具有 <code>try-finally</code> 语句（该语句中 finally 块的唯一代码是对 <code>Dispose</code> 方法的调用），请使用 <code>using</code> 语句代替。</li>
</ul>
</li>
<li>若要通过跳过不必要的比较来避免异常并提高性能，请在执行比较时使用 <code>&amp;&amp;</code>和 <code>||</code>短路效应</li>
<li>使用对象实例化的简洁形式之一  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> ExampleClass();<br></code></pre></td></tr></table></figure>
  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">ExampleClass instance2 = <span class="hljs-keyword">new</span>();<br></code></pre></td></tr></table></figure></li>
<li>使用对象初始值设定项简化对象创建，如以下示例中所示：  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> instance3 = <span class="hljs-keyword">new</span> ExampleClass &#123; Name = <span class="hljs-string">&quot;Desktop&quot;</span>, ID = <span class="hljs-number">37414</span>,<br>    Location = <span class="hljs-string">&quot;Redmond&quot;</span>, Age = <span class="hljs-number">2.3</span> &#125;;<br></code></pre></td></tr></table></figure></li>
<li>如果你正在定义一个稍后不需要删除的事件处理程序，请使用 lambda 表达式。  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form2</span>()</span><br>&#123;<br>    <span class="hljs-keyword">this</span>.Click += (s, e) =&gt;<br>        &#123;<br>            MessageBox.Show(<br>                ((MouseEventArgs)e).Location.ToString());<br>        &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>移动设备、游戏主机、Web应用、物联网、微服务以及桌面应用.</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello,World"></a>Hello,World</h2><p>C#从C和C++继承了基本的语法<br>文件名不用匹配类名<br>vscode,linqpad,vs2022</p>
<h3 id="dotnet-CLI"><a href="#dotnet-CLI" class="headerlink" title="dotnet CLI"></a>dotnet CLI</h3><p>dotnet.exe是dotnet命令行接口（或称dotnet CLI)</p>
<ul>
<li>使用<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir ./HelloWorld<br>cd ./HelloWorld<br>dotnet new console<br></code></pre></td></tr></table></figure>
会创建默认Programs.cs<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dotnet run<br></code></pre></td></tr></table></figure></li>
<li>编译<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">donet build <br></code></pre></td></tr></table></figure>
生成dll文件在.&#x2F;bing&#x2F;Debug&#x2F;xxx&#x2F;里</li>
<li>发布可执行文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dotnet public -runtime<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>编译器根据关键字的固有语法来解释程序员写的表达式.<br>在HelloWorld程序中，class、static和void均是关键字。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668641936821.png" srcset="/img/loading.gif" lazyload><br>*这些是上下文关键字，括号中的数字（n）代表加入该上下文关键字的C#版本。</p>
<h4 id="标识符-1"><a href="#标识符-1" class="headerlink" title="标识符"></a>标识符</h4><p>标识程序员编码的构造。<br>HelloWorld和Main均为标识符。<br><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/standard/design-guidelines/">标识符设计框架准则</a></p>
<ul>
<li>可以<code>@</code>前缀关键字为标识符</li>
</ul>
<h3 id="定义类型"><a href="#定义类型" class="headerlink" title="定义类型"></a>定义类型</h3><ul>
<li>类定义 class 标识符{…}<ul>
<li>要用名词或名词短语命名类。</li>
<li>要为所有类名使用PascalCase大小写风格</li>
</ul>
</li>
</ul>
<h3 id="Main方法"><a href="#Main方法" class="headerlink" title="Main方法"></a>Main方法</h3><p>C#方法是已命名代码块.提供了结构化和组织代码的一种方式，使之更易读。更重要的是，方法可以重用.</p>
<p>C#程序从Main方法开始执行。该方法以static void Main()开头。</p>
<p>Main返回的int是状态码.非0意味着错误.</p>
<p>Main方法支持<code>async/await</code></p>
<h3 id="语句和分隔符"><a href="#语句和分隔符" class="headerlink" title="语句和分隔符"></a>语句和分隔符</h3><p>代码块本身就被视为语句.</p>
<p>允许一条语句跨越多行，根据<code>;</code>判断结束位置</p>
<h3 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h3><p>分号使C#编译器能忽略代码中的空白</p>
<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>声明局部变量。变量声明后可以赋值，可将值替换成新值，并可在计算和输出等操作中使用。但变量一经声明，数据类型就不能改变。</p>
<blockquote>
<p>声明局部变量。变量声明后可以赋值，可将值替换成新值，并可在计算和输出等操作中使用。但变量一经声明，数据类型就不能改变。</p>
</blockquote>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型（或对象类型）是具有相似特征和行为的个体的分类。</p>
<ul>
<li><code>string</code></li>
<li><code>int</code>32位整型</li>
<li><code>char</code>字符</li>
</ul>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>局部变量使用驼峰法命名.</p>
<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>C#要求局部变量在读取前“明确赋值”。</p>
<p>此外，赋值作为一种操作会返回一个值。</p>
<blockquote>
<p>所有string类型的数据，不管是不是字符串字面值,都是不可变的.只能重新赋值</p>
</blockquote>
<h3 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h3><h2 id="控制台输入和输出"><a href="#控制台输入和输出" class="headerlink" title="控制台输入和输出"></a>控制台输入和输出</h2><ul>
<li><code>System.Console.ReadLine()</code><ul>
<li><code>System.Console.Read()</code>返回的是整数</li>
<li><code>System.Console.ReadKey()</code>单次输入</li>
</ul>
</li>
<li><code>System.Console.WriteLine()</code><ul>
<li><code>System.Console.Write()</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>字符串插值功能<code>$&quot;xxx&#123;Name&#125;xxx&quot;</code></p>
<p>字符串复合格式化<code>&quot;xxx&#123;0&#125;xx&#123;1&#125;,Name,Age&quot;</code></p>
</blockquote>
<h3 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h3><ul>
<li>单行注释<code>//</code></li>
<li>多行注释<code>/**/</code><ul>
<li>还能插入语句中</li>
</ul>
</li>
<li>XML注释</li>
</ul>
<blockquote>
<p>写注释来重复代码本来就讲得清的事情，只会使代码变得臃肿并降低可读性，还容易过时，因为将来代码可能更改了但注释却没有来得及更新。</p>
<p>没有注释但可读性好的代码，比需要注释才能说清楚的代码更有价值</p>
<p>不要使用注释，除非代码本身“一言难尽”。要尽量写清楚的代码而不是通过注释澄清复杂的算法。</p>
</blockquote>
<h2 id="托管执行和CLI"><a href="#托管执行和CLI" class="headerlink" title="托管执行和CLI"></a>托管执行和CLI</h2><p>处理器不能直接解释程序集。程序集用的是另一种语言，即公共中间语言IL&#x2F;CIL</p>
<p>C#编译器将C#源代码文件转换成中间语言。为了将CIL代码转换成处理器能理解的机器码，还要完成一个额外的步骤（通常在运行时进行）。</p>
<p>该步骤涉及C#程序执行的一个重要元素：VES(虚拟执行系统)运行时.它根据需要编译CIL代码，这个过程称为即时编译或JIT编译.这种代理方式就是托管代码</p>
<p>运行时管理着诸如内存分配、安全性和JIT编译等方面，从而控制了主要的程序行为。</p>
<blockquote>
<p>执行时”表示“程序执行的时候”</p>
<p>用“运行时”表示负责管理C#程序执行的代理</p>
</blockquote>
<h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p>Common Language Infrastructure，公共语言基础结构.</p>
<p>是一个规范:</p>
<ul>
<li>运行时</li>
<li>CIL</li>
<li>支持语言互操作性的类型系统，称为CTS</li>
<li>编写通过CLI兼容语言访问的库的指导原则</li>
<li>使各种服务能被CLI识别的元数据（包括程序集的布局或文件格式规范）</li>
</ul>
<p>通过复合规范就可以使用服务:语言互操作，类型安全，代码访问安全性，垃圾回收，平台可移植，BCL(基类库)</p>
<blockquote>
<p>ILDASM反汇编</p>
</blockquote>
<h2 id="多个-NET框架"><a href="#多个-NET框架" class="headerlink" title="多个.NET框架"></a>多个.NET框架</h2><ul>
<li><p>.NET Core</p>
</li>
<li><p>Xamarin</p>
</li>
<li><p>Unity</p>
</li>
</ul>
<p>API:应用编程接口，定义软件和其他组件交互方式.</p>
<p>.NET框架”一词指代.NET Core或Microsoft .NET Framework的所有程序集公开的API。API通常包含一组接口和协议（或指令），帮助你使用一系列组件进行编程。</p>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>预定义类型(基元类型),几种类型非常简单，是其他所有类型的基础.</p>
<ul>
<li>八种整数</li>
<li>两种浮点数</li>
<li>一种十进制浮点数</li>
<li>一种布尔</li>
<li>一种字符类型</li>
</ul>
<p>基元数据类型的完整名称提供了短名称,建议使用短名称</p>
<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668675357118.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>将浮点变量设为0.1，很容易表示成0.099999 999 999 999 999或者0.100 000 000 000000 000 1</p>
<p>浮点数精度由有效数位的个数决定.double型浮点数可以表示的有效数字最多为17位，float型为最多9位</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668675382293.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>采用二进制浮点数来存储数值.用十进制和二进制所表示的实数都存在舍入误差问题.</p>
<blockquote>
<p>99.9的二进制表示：1100011.111001100110011001100110011001100110011001101。现在我们需要将小数点左移6位，对应的指数值为+6。此时小数点右侧的位数为51位，这些将会被存放在尾数部分，如果使用double类型可以将数据全部记录，但是如果使用float类型，由于尾数部分只有23位，所有只能记录部分的数据，误差也就产生了！整理一下，符号位为0，指数部分为6+127&#x3D;133，尾数部分直接丢进去，能装多少装多少，以float为例。最终表示为：0 10000101 10001111100110011001100  </p>
</blockquote>
</blockquote>
<h3 id="decimal"><a href="#decimal" class="headerlink" title="decimal"></a>decimal</h3><p>128位精度的十进制浮点类型</p>
<p>decimal类型保证范围内的所有十进制数都是精确的。而不是近似值.</p>
<p>范围小，速度慢，但是精确.</p>
<blockquote>
<p>内部是使用科学计数法来存储</p>
</blockquote>
<h3 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h3><p>表示源代码中的固定值。如<code>12,12.5,&#39;x&#39;,&quot;abc&quot;&#39;</code></p>
<blockquote>
<p>直接将值放到源代码中称为硬编码.难维护</p>
<p>可以考虑从一个外部来源获取值，比如从一个配置文件中。这样以后需要修改值的时候，就不需要重新编译代码了。</p>
</blockquote>
<p>可以使用<code>F</code>和<code>D</code>作为后缀，将字面值分别显式声明为float或者double.<code>U</code>-&gt;uint,ulong.<code>L</code>-&gt;long,ulong</p>
<ul>
<li>数字分隔符<code>_</code></li>
<li>指数计数法<code>E</code>中缀</li>
<li>十六进制<code>0x</code>前缀</li>
<li>二进制<code>0b</code>前缀</li>
</ul>
<blockquote>
<p>数字格式化16进制:<code>$&quot;0x&#123;42:X&#125;&quot;</code></p>
</blockquote>
<blockquote>
<p>round-trip格式来防止丢弃最后文本<code>string.Format(&quot;&#123;0:R&#125;</code></p>
</blockquote>
<h2 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h2><p>条件语句和表达式中表示真或假,值为<code>true/false</code></p>
<p>bool实际大小是一个字节</p>
<h2 id="char"><a href="#char" class="headerlink" title="char"></a>char</h2><p>字符类型char表示16位字符,表示Unicode字符集，注意取值范围不是0~65535</p>
<p>转义序列:</p>
<ul>
<li><code>\n</code></li>
<li><code>\\</code></li>
<li><code>\t</code></li>
<li><code>\b</code></li>
<li><code>\&#39;</code> <code>\&quot;</code></li>
<li><code>\0</code>null</li>
</ul>
<p>使用<code>\uxxx</code>表示16位Unicode字符</p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>零或多个字符的<strong>不可变</strong>有限序列</p>
<p><code>@</code>前缀取消转义(“”除外)</p>
<p>插值是<code>string.Format()</code>的语法糖</p>
<p>常见方法:</p>
<ul>
<li>静态方法<ul>
<li>Format()</li>
<li>Concat()</li>
<li>Compare()默认区分大小写，第三个参数<code>true</code>不区分</li>
</ul>
</li>
<li>实例方法<ul>
<li>StatWith(),EndWith()</li>
<li>ToLower(),ToUpper()</li>
<li>Trim()</li>
<li>Replace()</li>
</ul>
</li>
</ul>
<blockquote>
<p>using static指令避免使用类名,可以直接使用静态方法</p>
</blockquote>
<p>格式化:组合格式化</p>
<p>长度:Length</p>
<blockquote>
<p>可变字符串:<code>System.Text.StringBuilder</code></p>
</blockquote>
<h3 id="null和void"><a href="#null和void" class="headerlink" title="null和void"></a>null和void</h3><ul>
<li><p>null值表明变量不引用任何有效的对象</p>
<ul>
<li>可做文本表示未知。<ul>
<li><code>&quot;&quot;</code>表示空白内容</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>可空修饰符<code>?</code>，声明变量名称后，使值类型也可以为空.<ul>
<li>可空引用类型:当这一概念被启用时，将没有可空修饰符的变量设置为null将会产生警告信息。启用“可空引用类型”的概念<code>#nullable enable</code><ul>
<li><code>string?homeNumber=null;</code>方可使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>	</p>
</blockquote>
</li>
<li><p>void表示无类型，或者没有任何值。</p>
</li>
</ul>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><ul>
<li><code>()</code></li>
</ul>
<blockquote>
<p>checked:将数据溢出引发异常，而不是二进制+1</p>
<p>unchecked阻止异常</p>
</blockquote>
<p>不能数值型到bool的转换</p>
<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>int-&gt;long不会丢失数据，而且不会抛出异常都可以隐式转换</p>
<h3 id="Parse和Convert"><a href="#Parse和Convert" class="headerlink" title="Parse和Convert"></a>Parse和Convert</h3><p>每个数值数据类型都包含一个Parse()方法，允许将字符串转换成对应的数值类型</p>
<p>System.Convert只支持少量类型，且不可扩展</p>
<blockquote>
<p>TryParse()返回false代替抛出异常.</p>
</blockquote>
<h1 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>一个类型要么是值类型，要么是引用类型。区别在于拷贝方式：值类型的数据总是拷贝值；而引用类型的数据总是拷贝引用</p>
<h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>值类型直接包含值，变量引用的位置就是内存中实际存储值的位置</p>
<p>除了string,所有的预定义类型都是值类型.</p>
<p>复制时，修改其中任何一个值都不会影响另一个值.</p>
<blockquote>
<p>由于值类型需要创建内存拷贝，因此定义时不要让它们占用太多内存（通常应该小于16字节）</p>
</blockquote>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>变量存储对数据存储位置的引用，而不是直接存储数据.</p>
<p>运行时”要先从变量中读取内存位置，再“跳转”到包含数据的内存位置。(解引用)</p>
<p>为引用类型的变量分配实际数据的内存区域称为堆</p>
<p>拷贝的是对数据的引用.</p>
<h2 id="可空变量"><a href="#可空变量" class="headerlink" title="可空变量"></a>可空变量</h2><ul>
<li>对于值类型:int? number&#x3D;null将声明一个可空的int型变量，并将其值初始化为null<ul>
<li>在实际中，当我们调用一个值类型变量的方法或者访问其属性时，仍然认为是在对该值类型变量进行解引用<blockquote>
<p>对可空值类型的操作实际是对<code>Nullable&lt;T&gt;</code></p>
</blockquote>
</li>
</ul>
</li>
<li>对于引用类型则会出现空引用异常<ul>
<li>启用引用类型的可空性特性:<code>#nullable enable</code>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta">#nullable enable</span><br><span class="hljs-built_in">string</span>? str=<span class="hljs-literal">null</span>;<br>Console.WriteLine(str?.Length);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p>空检查:.<br>方式1:is判断<br>方式2:<strong>null值条件操作符</strong><code>?.</code></p>
</blockquote>
<h2 id="隐式类型的局部变量"><a href="#隐式类型的局部变量" class="headerlink" title="隐式类型的局部变量"></a>隐式类型的局部变量</h2><p><code>var</code>无需显式声明变量的数据类型，由编译器推断</p>
<blockquote>
<p>匿名类型:在方法内部动态声明的数据类型，而不是通过显式的类定义来声明<br>    <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> v=<span class="hljs-keyword">new</span>&#123;Age=<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><br>但自从C# 7.0引入元组语法后，匿名类型几乎就用不着了。</p>
</blockquote>
<h2 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h2><p>合并数据元素。<br>允许在一条语句中完成对所有变量的赋值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">(<span class="hljs-built_in">string</span> country,<span class="hljs-built_in">double</span> gdp) t=(<span class="hljs-string">&quot;China&quot;</span>,<span class="hljs-number">249310E8</span>);<br></code></pre></td></tr></table></figure>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668677224639.png" srcset="/img/loading.gif" lazyload alt="元组语法"><br>左侧仍然是单独的变量，只是用元组语法一起赋值.虽然右侧的值合并成元组，但在向左侧赋值的过程中，元组已被解构为它的组成部分.使用的是元祖语法，而不是元祖。</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668677243397.png" srcset="/img/loading.gif" lazyload alt="元组"><br>左侧声明一个元组，将右侧的元组赋给它。注意元组含具名项，随后可引用这些名称来获取右侧元组中的值。这正是能在System.Console.WriteLine语句中使用countryInfo.Name、countryInfo.Capital和countryInfo.GdpPerCapita语法的原因。在左侧声明元组造成多个变量组合到单个元组变量（countryInfo）中</p>
<blockquote>
<p>要为元组语法的变量声明使用camelCase大小写规范。</br>考虑为所有元组项名称使用PascalCase大小写风格。</p>
</blockquote>
<p>元组是在对象中封装数据的轻量级方案</p>
<p>元组项数量也是在编译时硬编码好的。最后，不能为元组添加自定义行为（扩展方法不在此列）<br>如果需要和封装数据关联的行为，则应使用面向对象编程并定义一个类</p>
<blockquote>
<p>底层实现:<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668677798083.png" srcset="/img/loading.gif" lazyload><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668677818702.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>可在单个变量中存储同一种类型的多个数据项。使用从零开始的索引进行单独访问数据。固定长度，在声明时确定(可在运行时)。</p>
<p>index from end:<code>^1</code>将访问数组中最后一个元素</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668678006063.png" srcset="/img/loading.gif" lazyload><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668678026733.png" srcset="/img/loading.gif" lazyload></p>
<p>分配数组但不指定初始值，“运行时”会将每个数组元素初始化为它们的默认值</p>
<p><code>^</code>操作符后面不局限于使用字面量数字，也可以使用任何返回正整数的表达式</p>
<ul>
<li><code>Length</code>属性</li>
</ul>
<blockquote>
<p>访问数组之前应当检查数组变量是否为null，而不应该假设数组变量总是指向一个有效的数组。<br>访问数组时，应当从Length属性获得数组长度，而不应该使用假设的长度。<br>应当用^1来访问末尾元素，而不必再使用Length-1</p>
</blockquote>
<p><code>System.Index</code>和<code>System.Range</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">System.Index index=^<span class="hljs-number">42</span>;<span class="hljs-comment">//Value和IsFromEnd属性</span><br>System.Range range=..^<span class="hljs-number">0</span>;<span class="hljs-comment">//index类型的Start和End属性</span><br>range=..;<br></code></pre></td></tr></table></figure>

<p>常用静态方法<code>Array</code>:<code>Sort() BinarySearch()/*先排序在查找*/ Reverse() Clear()/*不是删除元素或Length设为0，而是把元素设为默认值*/</code></p>
<p>实例方法:<code>GetLength() Rank/*维数*/ Clone()/*浅克隆*/</code></p>
<blockquote>
<p>大多数程序现在都用泛型集合类型而非数组来存储数据集合</p>
</blockquote>
<h3 id="字符串作为数组"><a href="#字符串作为数组" class="headerlink" title="字符串作为数组"></a>字符串作为数组</h3><p>访问string类型的变量类似于访问字符数组</p>
<p>由于字符串不可变，所以不能向字符串中的特定位置赋值</p>
<ul>
<li><code>ToCharArray()</code></li>
</ul>
<h1 id="操作符和流程控制"><a href="#操作符和流程控制" class="headerlink" title="操作符和流程控制"></a>操作符和流程控制</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="一元正负操作符"><a href="#一元正负操作符" class="headerlink" title="一元正负操作符"></a>一元正负操作符</h3><h3 id="二元算数操作符"><a href="#二元算数操作符" class="headerlink" title="二元算数操作符"></a>二元算数操作符</h3><ul>
<li>&#96;+-*&#x2F; %</li>
<li><code>()</code></li>
</ul>
<blockquote>
<p>避免将二进制浮点类型用于相等性条件式。要么判断两个值之差是否在容差范围之内，要么使用decimal类型</p>
</blockquote>
<h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><ul>
<li><code>+= -=</code></li>
</ul>
<h3 id="递增递减操作符"><a href="#递增递减操作符" class="headerlink" title="递增递减操作符"></a>递增递减操作符</h3><ul>
<li><code>++ --</code><br>在前先运算，在后先赋值</li>
</ul>
<h3 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h3><p>常量表达式是C#编译器能在编译时求值的表达式（而不是在运行时才能求值）因为其完全由常量操作数构成</p>
<blockquote>
<p>不要用常量表示将来可能改变的任何值。π和金原子的质子数是常量。金价、公司名和程序版本号则应该是变量</p>
</blockquote>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668838771522.png" srcset="/img/loading.gif" lazyload><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668838804383.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><ul>
<li>if</li>
<li>嵌套if</li>
</ul>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><blockquote>
<p>除非是最简单的单行if语句，否则避免省略大括号</p>
</blockquote>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>具名事物的作用域是源代码的一个区域。可在该区域使用非限定名称（前面不加限定前缀的名称）引用该事物。局部变量的作用域就是封闭它的代码块</p>
<h2 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h2><p>if语句中包含在圆括号内的部分是布尔表达式，称为条件</p>
<h3 id="关系操作符和相等操作符"><a href="#关系操作符和相等操作符" class="headerlink" title="关系操作符和相等操作符"></a>关系操作符和相等操作符</h3><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668839059108.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p><code>&amp;&amp; || !</code>短路效应</p>
<h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p><code>?:</code></p>
<blockquote>
<p>考虑使用if&#x2F;else语句而不是过于复杂的条件表达式</p>
</blockquote>
<h2 id="null编程"><a href="#null编程" class="headerlink" title="null编程"></a>null编程</h2><h3 id="检查null值"><a href="#检查null值" class="headerlink" title="检查null值"></a>检查null值</h3><ul>
<li><code>==</code></li>
<li><code>ReferenceEquals()</code></li>
<li><code>is null</code> 比较好用</li>
<li><code>is&#123;&#125;</code></li>
</ul>
<h3 id="空合并操作符"><a href="#空合并操作符" class="headerlink" title="空合并操作符"></a>空合并操作符</h3><ul>
<li><code>??</code>空则使用另一个值。支持短路。</li>
</ul>
<h3 id="空条件操作符"><a href="#空条件操作符" class="headerlink" title="空条件操作符"></a>空条件操作符</h3><ul>
<li><code>?</code>不空才访问<ul>
<li><code>?.</code></li>
<li><code>?[]</code><blockquote>
<p>用于委托更优雅</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="空包容操作符"><a href="#空包容操作符" class="headerlink" title="空包容操作符"></a>空包容操作符</h3><p><code>!</code>该操作符告诉编译器程序员可以保证某个变量一定不为null值，从而在编译时，编译器会相信程序员的保证而不再产生警告信息。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">uri=<span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&#x27;/&#x27;</span>,segments!);<br></code></pre></td></tr></table></figure>

<p>由于Join()方法要求第二个参数不为空，因此如果直接将未赋值的可空型变量segments作为参数，则会产生编译器警告。在C# 8.0中可以使用空包容操作符(!)来避免该警告。</p>
<h2 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符"></a>按位操作符</h2><ul>
<li><code>&gt;&gt; &lt;&lt;</code>位移</li>
<li>&#96;&amp; | ^逻辑</li>
<li><code>~</code>求反</li>
</ul>
<blockquote>
<p>虽然传说x &lt;&lt; 2比x*4快，但不要将移位操作符用于乘除法,现代微处理器都对算术运算进行了完美的优化</p>
</blockquote>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p>控制流程语句在运行时求值条件表达式</p>
<h3 id="while和do-while"><a href="#while和do-while" class="headerlink" title="while和do-while"></a>while和do-while</h3><p>常见于死循环</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>有一套内建的语法规定了如何初始化、递增以及测试一个计数器的值。该计数器称为循环变量。由于循环语法中专门有一个位置是为递增&#x2F;递减操作保留的，所以递增&#x2F;递减操作符经常作为for循环的一部分使用。</p>
<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>foreach循环的特点是每一项只迭代一次：不会像其他循环那样出现计数错误，也不可能越过集合边界</p>
<p>foreach循环期间禁止修改循环变量</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>将一个值和多个常量值比较时，switch比if语句更易理解</p>
<blockquote>
<p>不要使用continue作为跳转语句退出switch小节。尽管switch在循环中时这样写合法，但很容易对之后的switch小节中出现的break产生困惑</p>
</blockquote>
<ul>
<li>任何小节的switch语句会产生编译器警告，但语句仍能通过编译</li>
<li>各小节可为任意顺序，default小节不一定要出现在switch语句最后，甚至可以省略</li>
<li>要求每个switch小节（包括最后一个小节）的结束点“不可到达”。这意味着switch小节通常以break、return、throw或goto结尾</li>
</ul>
<h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><ul>
<li>break</li>
<li>continue</li>
<li>goto<blockquote>
<p>避免使用goto</p>
</blockquote>
</li>
</ul>
<h2 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h2><p>处理器在编译时调用。预处理器指令告诉C#编译器要编译哪些代码，并指出如何处理代码中的特定错误和警告。C#预处理器指令还可告诉C#编译器有关代码组织的信<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668840622931.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>编译器选项生成define<code>dotnet.exe -definr:CSHA Test.cs</code></p>
</blockquote>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEST</span><br><span class="hljs-meta"># <span class="hljs-keyword">if</span> TEST</span><br>...<br><span class="hljs-meta"># <span class="hljs-keyword">elif</span> NOT TEST</span><br>...<br><span class="hljs-meta"># <span class="hljs-keyword">else</span></span><br>...<br><span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<h3 id="启用可空"><a href="#启用可空" class="headerlink" title="启用可空"></a>启用可空</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta">#nullable enable</span><br><span class="hljs-meta">#nullable disable//关闭</span><br><span class="hljs-meta">#nullable restore//将可空引用类型的可用状态恢复为整个工程的全局设置状态</span><br></code></pre></td></tr></table></figure>
<h1 id="方法和参数"><a href="#方法和参数" class="headerlink" title="方法和参数"></a>方法和参数</h1><p>随着程序变得越来越复杂，需要新的思维模式来管理这种复杂性。“过程式”或“结构化”编程的基本思路就是提供对语句分组来构成单元的构造。此外，可通过结构化编程将数据传给一个语句分组，在这些语句执行完毕后返回结果<br>方法组合一系列语句以执行特定操作或计算特定结果。它能为构成程序的语句提供更好的结构和组织。</p>
<blockquote>
<p>要为方法名使用动词或动词短语</p>
</blockquote>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>一个类中的所有方法都必须有唯一签名，C#依据方法名、参数数据类型或参数数量的差异来定义唯一性。</p>
<h3 id="命名空间。"><a href="#命名空间。" class="headerlink" title="命名空间。"></a>命名空间。</h3><p>命名空间是一种分类机制，用于分组功能相关的所有类型。</p>
<p>命名空间主要用于按功能领域组织类型，以便查找和理解这些类型。此外，命名空间还有助于防范类型名称冲突</p>
<h3 id="类型名称"><a href="#类型名称" class="headerlink" title="类型名称"></a>类型名称</h3><p>调用静态方法时，不需要类型名称，是因为编译器能够根据调用位置推断类型。显然，如果编译器无法进行这样的推断，就必须将类型名称作为方法调用的一部分</p>
<p>类型本质上是对方法及其相关数据进行分组的一种方式</p>
<h3 id="方法名称"><a href="#方法名称" class="headerlink" title="方法名称"></a>方法名称</h3><p>每个方法调用都要指定一个方法名称。如前所述，它可能用也可能不用命名空间和类型名称加以限定。方法名称之后是圆括号中的实参列表，每个实参以逗号分隔，对应于声明方法时指定的形参。</p>
<h3 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h3><p>方法可获取任意数量的形参，每个形参都具有特定的数据类型。调用者为形参提供的值称为实参，每个实参都要和一个形参对应。</p>
<h3 id="方法返回值"><a href="#方法返回值" class="headerlink" title="方法返回值"></a>方法返回值</h3><p>void或者数据类型</p>
<h2 id="方法的声明"><a href="#方法的声明" class="headerlink" title="方法的声明"></a>方法的声明</h2><blockquote>
<p>将一组语句转移到一个方法中，而不是把它们留在一个较大的方法中，这是一种重构形式</p>
</blockquote>
<h3 id="参数声明"><a href="#参数声明" class="headerlink" title="参数声明"></a>参数声明</h3><p>可在方法声明的圆括号中添加参数列表</p>
<p>列表中的每个参数都包含参数类型和参数名称，每个参数以逗号分隔</p>
<h3 id="方法返回类型声明"><a href="#方法返回类型声明" class="headerlink" title="方法返回类型声明"></a>方法返回类型声明</h3><ul>
<li>return<ul>
<li>返回元祖类型.多个值可通过C#元组语法打包成元组返回</li>
</ul>
</li>
</ul>
<blockquote>
<p>虽然C#允许提前返回，但为了增强代码的可读性，并使代码更易维护，应尽量确定单一的退出位置，而不是在方法的多个代码路径中散布多个return语句。</p>
</blockquote>
<ul>
<li>指定void作为返回类型表示该方法没有返回值。所以，这种方法不支持向变量赋值，也无法在调用位置作为参数传递。void调用只能作为语句使用.可选的return</li>
</ul>
<h3 id="表达式主体方法"><a href="#表达式主体方法" class="headerlink" title="表达式主体方法"></a>表达式主体方法</h3><p>用表达式代替完整方法主体</p>
<p>表达式主体方法不是用大括号定义方法主体，而是用&#x3D;&gt;操作符</p>
<p>虽然没有显式的return语句，但表达式本身的返回类型必须与方法声明的返回类型匹配</p>
<h2 id="using指令"><a href="#using指令" class="headerlink" title="using指令"></a>using指令</h2><ul>
<li>显示导入命名空间</li>
<li><code>using static</code>，使用静态方法</li>
<li>嵌套:在命名空间内部使用</li>
<li>别名:<code>using T=Test</code></li>
</ul>
<h2 id="Main-的返回值和参数"><a href="#Main-的返回值和参数" class="headerlink" title="Main()的返回值和参数"></a>Main()的返回值和参数</h2><p>假如一个程序的两个类都有Main()方法，可以选取其中一个类作为程序的入口点。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dotnet build /p:StartupObject=Test.Program<br></code></pre></td></tr></table></figure>
<h2 id="高级方法参数"><a href="#高级方法参数" class="headerlink" title="高级方法参数"></a>高级方法参数</h2><h3 id="值参数"><a href="#值参数" class="headerlink" title="值参数"></a>值参数</h3><p>参数默认采用传值方式。换言之，参数值会拷贝到目标参数中。</p>
<p>调用栈在一次调用的末尾“展开”的时候，拷贝的数据会被丢弃。</p>
<blockquote>
<p>如<strong>引用类型的变量</strong>以传值方式传给方法，拷贝的就是引用（地址）本身。这样虽然在被调用的方法中还是更改不了引用（地址）本身，但可以更改地址处的数据。相反，对于<strong>值类型的参数</strong>，参数获得的是值的拷贝，所以被调用的方法怎么都改变不了调用者的变量。</p>
</blockquote>
<h3 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h3><p><code>ref</code>，这使参数以传引用的方式传递，被调用的方法可用新值更新调用者的变量</p>
<p>如果被调用的方法将参数指定为ref，调用者调用该方法时提供的实参应该是附加了ref前缀的变量</p>
<p>事实上，ref参数只是传递的变量的别名。换言之，引用参数的作用只是为现有变量分配参数名，而非创建新变量并将实参的值拷贝给它。</p>
<h3 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h3><p>方法经常要获取一个变量引用，并向变量写入而不读取。这时更安全的做法是以传引用的方式传入一个未初始化的局部变量</p>
<ul>
<li><code>out</code>参数功能上与ref参数完全一致.唯一区别是C#语言对别名变量的读写有不同的规定。如参数被标记为out，编译器会核实在方法所有正常返回的代码路径中，是否都对该参数进行了赋值<ul>
<li>调用时<code>_</code>放弃</li>
<li>返回两个或更多值应首选元组语法</li>
</ul>
</li>
</ul>
<h3 id="只读传引用"><a href="#只读传引用" class="headerlink" title="只读传引用"></a>只读传引用</h3><p><code>in</code>以传引用的方式传入只读值类型。该特性以传引用的方式传入值类型参数，并且让该参数不能被方法修改。这样不仅避免了每次调用方法都创建值类型的拷贝，而且不用担心值类型参数被修改</p>
<p>换言之，其作用是在传值时减少拷贝量，同时把它标识为只读，从而增强性能。该语法要为参数添加in修饰符</p>
<h3 id="返回引用"><a href="#返回引用" class="headerlink" title="返回引用"></a>返回引用</h3><ul>
<li><code>return ref xxx</code><ul>
<li>返回类型前加ref</li>
<li>变量引用返回值值时,双方前加ref</li>
</ul>
</li>
</ul>
<p>返回引用有两个重要的限制，两者都和对象生存期有关：</p>
<ol>
<li>对象仍被引用时不应被垃圾回收；</li>
<li>对象的所有引用都消失之后，不应再占用内存。</li>
</ol>
<p>为符合这些限制，从方法返回引用时只能返回：</p>
<ul>
<li>对字段或数组元素的引用</li>
<li>其他返回引用的属性或方法</li>
<li>作为参数传给“返回引用的方法”的引用</li>
</ul>
<p>ref局部变量被初始化为引用一个特定变量，以后不能修改为引用其他变量</p>
<ul>
<li>声明引用局部变量的同时必须初始化它。为此需要将方法返回的引用赋给它，或将一个变量引用赋给它</li>
<li>允许声明ref局部变量，但不允许声明ref字段</li>
<li>自动实现的属性不能声明为引用类型</li>
<li>允许返回引用的属性</li>
<li>引用局部变量不能用值（比如null或常量）来初始化.必须将返回引用的成员赋给它，或者将局部变量、字段或数组赋给它</li>
</ul>
<h3 id="参数数组"><a href="#参数数组" class="headerlink" title="参数数组"></a>参数数组</h3><p><code>params 数组参数</code>放在最后.</p>
<ul>
<li>参数数组是类型安全的——实参类型必须兼容参数数组的类型</li>
<li>调用者可传递一个实际的数组，而不是传递以逗号分隔的实参列表</li>
</ul>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>事实上，递归通常都是最简单的编码模式，尤其是在和文件系统这样的层次化数据打交道的时候。不过，虽然可读性不错，但一般不是最快的实现。如果必须关注性能，开发者应该为递归实现寻求一种替代方案。至于具体如何选择，通常取决于如何在可读性与性能之间取得平衡。</p>
<blockquote>
<p>栈溢出</p>
</blockquote>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>方法的唯一性取决于方法名、参数数据类型或参数数量的差异。</p>
<p>方法重载是一种操作性多态</p>
<p>重载就是同名不同参数数据类型或参数数量</p>
<p>假定有两个适用的方法，每个都要求将实参隐式转换成形参的类型，最终选择的是形参类型更具体（派生程度更大）的方法.如果有多个适用的方法，但无法从中挑选出最具唯一性的，编译器就会报错，指明调用存在歧义</p>
<h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>方法声明时，在参数列表给参数赋默认值</p>
<blockquote>
<p>要尽量为所有参数提供好的默认值<br>要提供简单的方法重载，必需参数的数量要少<br>考虑从最简单到最复杂的组织重载</p>
</blockquote>
<h3 id="具名参数"><a href="#具名参数" class="headerlink" title="具名参数"></a>具名参数</h3><p>在方法调用时，指定参数赋值<code>age:18</code></p>
<h2 id="基本异常处理"><a href="#基本异常处理" class="headerlink" title="基本异常处理"></a>基本异常处理</h2><ul>
<li><code>try-catch-finally</code></li>
<li><code>throw</code></li>
</ul>
<blockquote>
<p>避免从finally块显式抛出异常（因方法调用而隐式抛出的异常可以接受）<br>要在抛出的异常中描述异常为什么发生。如果可能，顺带说明如何防范更佳<br>要在捕捉并重新抛出异常时使用空的throw语句，以便保留调用栈<br>不要让公共成员将异常作为返回值或者out参数。抛出异常来指明错误，不要把它们作为返回值来指明错误。</p>
</blockquote>
<p>避免使用异常处理来处理预料之中的情况<br><code>TryParse()</code></p>
<blockquote>
<p>不要用异常处理正常的、预期的情况，用它们处理异常的、非预期的情况</p>
</blockquote>
<h3 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h3><p>所有的异常都派生自此类.</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>面向对象编程中，之前学过的所有结构化的、基于控制流的编程构造仍然适用。但将那些构造封装在类中，可以创建更大、更有条理以及更容易维护的程序。从结构化的、基于控制流程的程序转向面向对象的程序，是因为面向对象编程提供了一个额外的组织层次。结果是较小的程序在某种程度上得到了简化。但更重要的是，现在更容易创建较大的程序，因为程序中的代码得到了更好的组织。</p>
<p>面向对象编程的一个关键优势是不必从头创建新程序，而是可以将现有的一系列对象组装到一起，用新功能扩展类，或添加更多的类</p>
<p>类是面向对象编程的三个主要特征——封装、继承和多态性——的基础。</p>
<ul>
<li>封装:1.将方法和数据装入对象 2.在隐藏细节。<ul>
<li>所有类成员（类的数据和方法）的一个分组，使它们不再需要单独处理</li>
<li>方法封装语句</li>
</ul>
</li>
<li>继承:允许在这些相似但又不同的物件之间建立“属于”（is a）关系。类层次结构<ul>
<li>更具体的类型称为派生类型或子类型。更常规的类型称为基类型或者超类型.子”毕竟不是一种“父”</li>
<li>继承最关键的一点是所有派生类型都继承了基类型的成员</li>
</ul>
</li>
<li>多态:一个方法或类型可具有多种形式的实现<ul>
<li>使不同类型能自己处理一个方法的实现细节，因为多个派生类型都包含了该方法，每个派生类型都共享同一个基类型（或接口），后者也包含了相同的方法签名。</li>
</ul>
</li>
</ul>
<h2 id="类的声明和实例化"><a href="#类的声明和实例化" class="headerlink" title="类的声明和实例化"></a>类的声明和实例化</h2><ul>
<li>声明类首先指定关键字class，后跟一个标识符</li>
</ul>
<p>该类的所有代码放到类声明之后的大括号中。虽然并非必须，但一般应该将每个类都放到它自己的文件中，用类名对文件进行命名。这样可以更容易地寻找定义了一个特定类的代码。</p>
<blockquote>
<p>不要在一个源代码文件中放多个类<br>要用所含公共类型的名称命名源代码文件</p>
</blockquote>
<ul>
<li>类和对象<ul>
<li>类是模板，定义了对象在实例化时看起来像什么样子</li>
<li>对象是类的实例</li>
<li>从类创建对象的过程称为实例化</li>
</ul>
</li>
<li>实例化:new关键字实例化对象<br>  -要用new操作符指示“运行时”为对象分配内存、初始化对象，并返回对实例的引用<ul>
<li>对象回收由GC自动完成</li>
</ul>
</li>
</ul>
<h2 id="实例字段"><a href="#实例字段" class="headerlink" title="实例字段"></a>实例字段</h2><p>在类中存储数据的变量称为成员变量,更成为字段，是与包容类型关联的具名存储单元.</p>
<p>实例字段是在类的级别上声明的变量，用于存储与对象（实例）关联的数据。</p>
<h3 id="声明实例字段"><a href="#声明实例字段" class="headerlink" title="声明实例字段"></a>声明实例字段</h3><p>和局部变量声明一样，字段声明包含字段所引用的数据类型。此外，还可在声明的.指示访问等级(默认私有)</p>
<h3 id="访问实例字段"><a href="#访问实例字段" class="headerlink" title="访问实例字段"></a>访问实例字段</h3><p>可设置和获取字段中的数据。注意字段不包含static修饰符，这意味着它是实例字段。</p>
<p>只能从其包容类的实例（对象）中访问实例字段，无法直接从类中访问（换言之，不创建实例就不能访问）。</p>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>必须先获得类的实例才能调用实例成员——无论该实例成员是方法还是字段。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>此关键字可在类的实例成员内部获取对该类的引用</p>
<p>关键字this显式指出当前访问的字段或方法是包容类的实例成员。调用任何实例成员时this都是隐含的，它返回</p>
<blockquote>
<p>this关键字只在必要时才应使用</p>
</blockquote>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>控制封装的访问级别</p>
<ul>
<li>public访问不受限制。接口方法默认</li>
<li>private访问限于包含类。类成员默认私有.</li>
<li>protected访问限于包含类或派生自包含类的类型</li>
<li>internal访问限于当前程序集。类默认</li>
<li>protected internal访问限于当前程序集或派生自包含类的类型。</li>
<li>private protected访问限于包含类或当前程序集中派生自包含类的类型</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li>私有字段,公开属性</li>
</ul>
<p>属性的关键在于，它提供了从编程角度看类似于字段的API。但事实上并不存在这样的字段。</p>
<p>属性声明看起来和字段声明一样，但跟随在属性名之后的是一对大括号，要在其中添加属性的实现。</p>
<p>get和set</p>
<blockquote>
<p>一般原则是方法代表行动，而属性代表数据。属性旨在简化对简单数据的访问(只进行简单计算)。调用属性的成本不应比访问字段高出太多。</p>
</blockquote>
<blockquote>
<p>避免从属性取值方法抛出异常<br>要在属性抛出异常时保留原始属性值<br>如果不需要额外逻辑，要优先使用自动实现的属性，而不是属性加简单支持字段<br>无论私有字段使用哪一种命名方案，属性都要使用PascalCase大小写规范<br>为支持字段附加“_”前缀<br>要使用名词、名词短语或形容词命名属性<br>考虑让某个属性和它的类型同名<br>如果有意义的话，要为Boolean属性附加“Is”“Can”或“Has”前缀<br>要优先使用自动实现的属性而不是字段</p>
</blockquote>
<p>拦截赋值，并通过字段风格的API对参数进行验证，这是属性的优点之一。</p>
<p>一个好的实践是只从属性的实现中访问属性的支持字段。换言之，要一直使用属性，不要直接调用字段</p>
<h3 id="nameof"><a href="#nameof" class="headerlink" title="nameof"></a>nameof</h3><p>属性验证时如判断新赋值无效，就需要抛出ArgumentException()或Argument-NullException()类型的异常。两个异常都获取string类型的实参paramName来标识无效参数的名称</p>
<p>可用nameof操作符来改进。该操作符获取一个标识符（比如value变量）作为参数，返回该名称的字符串形式<code>nameof(value)</code></p>
<p>nameof操作符的优点在于，以后若标识符名称发生改变，重构工具能自动修改nameof的实参</p>
<h3 id="只读和只写属性"><a href="#只读和只写属性" class="headerlink" title="只读和只写属性"></a>只读和只写属性</h3><p>通过移除属性的取值方法或赋值方法，可以改变属性的可访问性。只有赋值方法的属性是只写属性，这种情况较罕见。类似地，只提供取值方法会得到只读属性，任何赋值企图都会造成编译错误。</p>
<h3 id="自动实现的属性"><a href="#自动实现的属性" class="headerlink" title="自动实现的属性"></a>自动实现的属性</h3><p>属性默认值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>[,,] Cells&#123;<span class="hljs-keyword">get</span>;&#125;=<span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure>
<blockquote>
<p>如属性值不变，要创建只读自动实现</p>
</blockquote>
<h3 id="属性作为虚字段"><a href="#属性作为虚字段" class="headerlink" title="属性作为虚字段"></a>属性作为虚字段</h3><p>可以看出属性的行为与虚字段相似。有时甚至根本不需要支持字段.相反，可让属性的取值方法返回计算好的值，而让赋值方法解析值，并将值持久存储到其他成员字段中。</p>
<h3 id="属性和方法调用不允许作为ref或out参数值"><a href="#属性和方法调用不允许作为ref或out参数值" class="headerlink" title="属性和方法调用不允许作为ref或out参数值"></a>属性和方法调用不允许作为ref或out参数值</h3><p>C#允许属性像字段那样使用，只是不允许作为ref或out参数值传递。ref和out参数内部要将内存地址传给目标方法。但由于属性可能是无支持字段的虚字段，也有可能只读或只写，所以不可能传递存储地址。同样的道理也适用于方法调用。如需将属性或方法调用作为ref或out参数值传递，首先必须将值拷贝到变量再传递该变量。方法调用结束后，再将变量的值赋回属性。</p>
<h3 id="属性的内部工作原理"><a href="#属性的内部工作原理" class="headerlink" title="属性的内部工作原理"></a>属性的内部工作原理</h3><p>除了外观与普通方法无异，注意属性在CIL中也是一种显式的构造.因此，语言和编译器并非总是依据一个惯例来解释属性。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>数据的有效性,即使忘了初始化，有构造函数来警告</p>
<h3 id="声明构造函数"><a href="#声明构造函数" class="headerlink" title="声明构造函数"></a>声明构造函数</h3><p>声明构造函数需创建一个无返回类型的方法，方法名必须和类名完全一样。构造函数是“运行时”用来初始化对象实例的方法。</p>
<p>构造函数会覆盖声明字段&#x2F;属性的初始值</p>
<blockquote>
<p>new操作符的实现细节<br>new操作符内部和构造函数是像下面这样交互的。new操作符从内存管理器获取“空白”内存，调用指定构造函数，将对“空白”内存的引用作为隐式的this参数传给构造函数。构造函数链剩余的部分开始执行，在构造函数之间传递引用。这些构造函数都没有返回类型（行为都像是返回void）。构造函数链上的执行结束后，new操作符返回内存引用。现在，该引用指向的内存处于完成初始化的形式。</p>
</blockquote>
<h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>如果类没有显式定义的构造函数，C#编译器会在编译时自动添加一个。该构造函数不获取参数，称为默认构造函数<br>一旦为类显式添加了构造函数，C#编译器就不再自动提供默认构造函数。</p>
<blockquote>
<p>没必要依赖编译器提供的默认构造函数。程序员任何时候都可显式定义默认构造函</p>
</blockquote>
<h3 id="对象初始化器"><a href="#对象初始化器" class="headerlink" title="对象初始化器"></a>对象初始化器</h3><p><code>&#123;&#125;</code>可访问字段和属性进行赋值</p>
<p>这实际只是一种语法糖，最终生成的CIL代码和创建对象实例后单独用语句对字段及属性进行赋值无异.<br>代码中的成员初始化顺序决定了在CIL中调用构造函数后的属性和字段赋值顺序</p>
<blockquote>
<p>要为所有属性提供有意义的默认值，确保默认值不会造成安全漏洞或造成代码执行效率大幅下降<br>要允许属性以任意顺序设置，即使这会造成对象暂时处于无效状态</p>
</blockquote>
<ul>
<li>集合初始化器<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668847210926.png" srcset="/img/loading.gif" lazyload></li>
<li>终结器:终结器是在对象被判定“不可到达”之后的不确定时间内执行</li>
</ul>
<h3 id="重载构造函数"><a href="#重载构造函数" class="headerlink" title="重载构造函数"></a>重载构造函数</h3><blockquote>
<p>如果构造函数的参数只是用于设置属性，那么构造函数参数（camelCase）要使用和属性（PascalCase）相同的名称，区别仅仅是首字母的大小写<br>要为构造函数提供可选参数，并且提供便利的重载构造函数，用好的默认值初始化属性<br>要允许以任何顺序设置属性，即使这会导致暂时无效的对象状态</p>
</blockquote>
<h3 id="构造函数链"><a href="#构造函数链" class="headerlink" title="构造函数链"></a>构造函数链</h3><p>使用this调用另一个构造函数</p>
<blockquote>
<p>可设计个<code>Initialize()</code>集中初始化.获取全部的属性并赋值</p>
</blockquote>
<h2 id="不可空引用类型属性与构造函数"><a href="#不可空引用类型属性与构造函数" class="headerlink" title="不可空引用类型属性与构造函数"></a>不可空引用类型属性与构造函数</h2><p>在一个类中，如果定义了不可空引用类型的字段或者默认实现的属性，则在其宿主类完成实例化之前，这些字段和属性的值需要先被初始化，否则，它们只能拥有默认的null值，而这显然与“不可空”相悖。<br>有时候这类字段和属性可能已经被间接地初始化了，超出了构造函数的直接作用域，因此超出了编译器代码分析的作用域，即便通过构造函数调用的方法或属性能够初始化也是如此</p>
<p>在大部分情况下，不可空引用型字段和自动实现的不可空属性的初始化，都通过构造函数调用属性或方法间接完成。遗憾的是，C#编译器无法识别对不可空引用型字段或属性的间接赋值，即便该间接赋值发生在构造函数里</p>
<h3 id="可读写的引用型不可空属性"><a href="#可读写的引用型不可空属性" class="headerlink" title="可读写的引用型不可空属性"></a>可读写的引用型不可空属性</h3><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668847837700.png" srcset="/img/loading.gif" lazyload><br>既使用可读写的引用型不可空属性，又避免产生不可空属性未初始化的编译器警告。这样做的最终效果是在编译器看来该属性&#x2F;字段为可空（因此不会产生警告），而在调用者看来该属性&#x2F;字段不允许被设置为空。</p>
<p>虽然将不应该为空的字段声明为可空看起来不太正确，但是由于编译器无法识别对不可空字段的间接赋值，因此有时确实需要这样做。好在程序员可以通过字段的私有性，以及精细设</p>
<h3 id="自动实现的只读引用型属性"><a href="#自动实现的只读引用型属性" class="headerlink" title="自动实现的只读引用型属性"></a>自动实现的只读引用型属性</h3><p>如果一个不可空的引用型字段有自动实现的属性，则该属性应该为只读，从而避免该字段被意外设置为null值。但是即便做到了这一点，在构造函数里为该字段进行赋值时，仍然需要检查null值<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668847978636.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>当类的不可空引用型字段需要对应的属性时，要将该字段声明为可空，并且要编写完整实现的属性方法，而不要采用自动实现的方式。在赋值方法中要做好null值检查，在取值方法中要使用空包容操作符。<br>不可空的引用型字段要在构造函数内完成赋值<br>如果一定要为不可空的引用型字段使用自动实现的属性，要将属性声明为只读<br>在操作任何引用型字段或属性时，都要检查null值</p>
</blockquote>
<h2 id="可空特性"><a href="#可空特性" class="headerlink" title="可空特性"></a>可空特性</h2><p>明确告诉编译器你需要处理空值，并需要为此添加一些防护措施，比笼统地关闭空值功能或者关闭空值警告更有意义<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668861767573.png" srcset="/img/loading.gif" lazyload><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668861810817.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>可空泛型<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668861898144.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h2 id="解构函数"><a href="#解构函数" class="headerlink" title="解构函数"></a>解构函数</h2><p>把一个对象封装好的项拆分为它的各个组成部分。</p>
<ul>
<li>方法名必须是Deconstruct，其签名是返回void并接收两个或更多out参数</li>
</ul>
<p>和元祖配合更优雅<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668862193683.png" srcset="/img/loading.gif" lazyload><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668862160314.png" srcset="/img/loading.gif" lazyload><br>也可将对象实例赋给元祖，隐式调用Deconstruct()，和out参数匹配</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">(_,firstName,lastName,salary)=employee;<br></code></pre></td></tr></table></figure>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p><code>static</code></p>
<h3 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h3><p>使用static关键字定义能由多个实例共享的数据</p>
<p>和实例字段（非静态字段）一样，静态字段也可在声明时初始化<br>和实例字段不同，未初始化的静态字段将获得默认值</p>
<p>每创建一个对象实例，非静态字段（实例字段）都要占用一个新的存储位置。静态字段从属于类而非实例。因此，我们使用类名从类外部访问静态字段。</p>
<blockquote>
<p>设计对象时，程序员要考虑字段和方法应声明为静态还是基于实例。一般应将不需要访问任何实例数据的方法声明为静态方法，将需要访问实例数据的方法（实例不作为参数传递）声明为实例方法。静态字段主要存储对应于类的数据，比如新实例的默认值或者已创建实例的个数。而实例字段主要存储和对象关联的数据。</p>
</blockquote>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>和静态字段一样，直接在类名后访问静态方法</p>
<h3 id="静态构造方法"><a href="#静态构造方法" class="headerlink" title="静态构造方法"></a>静态构造方法</h3><p>“运行时”在首次访问类时自动调用静态构造函数。“首次访问类”可能发生在调用普通构造函数时，也可能发生在访问类的静态方法或字段时。由于静态构造函数不能显式调用，所以不允许任何参数。</p>
<p>静态构造函数的作用是将类中的静态数据初始化成特定值，尤其是在无法通过声明时的一次简单赋值来获得初始值的时候</p>
<blockquote>
<p>最好在声明时进行静态初始化（而不要使用静态构造函数）</p>
</blockquote>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>使用静态属性几乎肯定比使用公共静态字段好，因为公共静态字段在任何地方都能调用，而静态属性至少提供了一定程度的封装。</p>
<h3 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h3><p>该类不包含任何实例字段（或方法），创建能实例化的类没有意义</p>
<ol>
<li>它防止程序员写代码来实例化SimpleMath类。</li>
<li>防止在类的内部声明任何实例字段或方法</li>
<li>不可扩展</li>
</ol>
<h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><p>能模拟为其他类创建实例方法。</p>
<p>只需更改静态方法的签名，使第一个参数成为要扩展的类型，并在类型名称前附加this关键字</p>
<p>查看CIL代码，会发现扩展方法是作为普通静态方法调用的。</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668863172652.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>避免随便定义扩展方法，尤其是不要为自己无所有权的类型定义。</p>
</blockquote>
<h2 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const字段（称为常量字段）包含在编译时确定的值，运行时不可修改。</p>
<ul>
<li><p>自动成为静态字段.</p>
<ul>
<li>但将常量字段显式声明为static会造成编译错误</li>
<li>常量字段通常只声明为有字面值的类型<blockquote>
<p>要为永远不变的值使用常量字段<br>避免为将来会发生变化的值使用常量字段</p>
</blockquote>
</li>
</ul>
</li>
<li><p>public常量应该是恒定值.将来可能更改的值应该指定为readonly</p>
</li>
</ul>
<h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>readonly修饰符只能用于字段（不能用于局部变量），它指出字段值只能从构造函数中更改，或在声明时通过初始化器指定。</p>
<p>由于readonly字段必须通过构造函数或初始化器来设置，所以编译器要求这种字段能从其属性外部访问。但除此之外，不要从属性外部访问属性的支持字段</p>
<blockquote>
<p>一般都是不用readonly字段，而是设为只读(无set)属性.<br>要优先选择只读自动实现的属性而不是只读字段</p>
</blockquote>
<h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>假如一个类在它的包容类外部没有多大意义，就适合设计成嵌套类。</p>
<p>嵌套类的独特之处是可以为类自身指定private访问修饰符。.使用private访问修饰符可限定类的作用域，防止从类的外部访问。只有嵌套类才能这样做。</p>
<p>嵌套类另一个有趣的地方在于它能访问包容类的任何成员，其中包括私有成员。反之则不然，包容类不能访问嵌套类的私有成员。</p>
<blockquote>
<p>避免声明公共嵌套类型。少数高级自定义场景才需考虑</p>
</blockquote>
<h2 id="分部类"><a href="#分部类" class="headerlink" title="分部类"></a>分部类</h2><p>分部类是一个类的多个部分，编译器可把它们合并成一个完整的类。</p>
<ul>
<li><code>partial</code><br>除了用于代码生成器，分部类另一个常见的应用是将每个嵌套类都放到它们自己的文件中。</li>
</ul>
<h3 id="分部方法"><a href="#分部方法" class="headerlink" title="分部方法"></a>分部方法</h3><p>分部方法只能存在于分部类中，而且和分部类相似，主要作用是为代码生成提供方便。</p>
<p>分部方法允许声明方法而不需要实现。但如果包含了可选的实现，该实现就可放到某个姊妹分部类定义中，该定义可能在单独的文件中。</p>
<p>分部方法必须返回void。</p>
<p>分部方法使生成的代码能调用并非一定要实现的方法。此外，如果没有为分部方法提供实现，CIL中不会出现分部方法的任何踪迹。这样在保持代码规模尽量小的同时，还保证了高的灵活性。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>利用类的继承关系建立类层次结构。</p>
<p>单继承</p>
<h2 id="派生、"><a href="#派生、" class="headerlink" title="派生、"></a>派生、</h2><p>经常需要扩展现有类型来添加功能（行为和数据）。继承正是为了该目的而设计的。</p>
<p>所有类都隐式派生自object。</p>
<h3 id="转型"><a href="#转型" class="headerlink" title="转型"></a>转型</h3><ul>
<li><p>可以将派生类型的值直接赋给基类型的变量。隐式转型</p>
</li>
<li><p>类型转换为派生类型要求执行显式转型，而显式转型在运行时可能失败。</p>
</li>
<li><p>自定义转换: <code>ublic态 implicit operator 目标类(本类)&#123;&#125;</code></p>
<ul>
<li>将implicit替换成explicit就是显式转换</li>
</ul>
</li>
</ul>
<h3 id="private访问修饰符"><a href="#private访问修饰符" class="headerlink" title="private访问修饰符"></a>private访问修饰符</h3><p>派生类继承除构造函数和析构器之外的所有基类成员。但继承并不意味着一定能访问。</p>
<p>根据封装原则，派生类不能访问基类的private成员</p>
<h3 id="protected访问修饰符"><a href="#protected访问修饰符" class="headerlink" title="protected访问修饰符"></a>protected访问修饰符</h3><p>可在基类中定义只有派生类才能访问的成员</p>
<p>基类的受保护成员只能从基类及其派生链的其他类中访问。</p>
<h3 id="扩展方法-1"><a href="#扩展方法-1" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>扩展方法从技术上说不是类型的成员，所以不可继承。但因为每个派生类都可作为它的任何基类的实例使用，所以对一个类型进行扩展的方法也可扩展它的任何派生类型。</p>
<p>但和所有扩展方法一样，实例方法有更高的优先级。如果继承链中出现一个兼容的签名，那么它将优先于扩展方法。</p>
<h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p>为正确设计类，使其他人能通过派生来扩展功能，需对它进行全面测试，验证派生能成功进行.<br><code>seal</code>避免非预期的派生，并避免因此而出现的问题。</p>
<p>string类型就是用sealed修饰符禁止派生的例子。</p>
<h2 id="重写基类"><a href="#重写基类" class="headerlink" title="重写基类"></a>重写基类</h2><p>基类除构造函数和析构器之外的所有成员都会在派生类中继承。但某些情况下，一个成员可能在基类中没有得到最佳的实现。<br>因此，需要一种机制在派生类中使用自定义的实现来重写（override，覆盖或覆写）基类中的实现</p>
<h3 id="virtaul修饰符"><a href="#virtaul修饰符" class="headerlink" title="virtaul修饰符"></a>virtaul修饰符</h3><p>支持重写实例方法和属性，但不支持字段和任何静态成员的重写。</p>
<ul>
<li><code>override</code>进行重写。<ul>
<li>基类调用时调用实例的方法.<blockquote>
<p>用override修饰的任何方法自动为虚。只有基类的虚方法才能重写，所以重写后的方法还是虚方法。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="new修饰符"><a href="#new修饰符" class="headerlink" title="new修饰符"></a>new修饰符</h3><p>如果重写方法没有使用override关键字，编译器会生成警告消息，可使用new修饰符.</p>
<p>它在基类面前隐藏了派生类重新声明的成员。搜索继承链，找到使用new修饰符的那个成员之前的、派生得最远的成员，然后调用该成员。如继承链仅包含两个类，就使用基类的成员，就像是派生类没有声明那个成员（如派生的实现重写了基类成员）。</p>
<h3 id="sealed修饰符"><a href="#sealed修饰符" class="headerlink" title="sealed修饰符"></a>sealed修饰符</h3><p>禁止子类重写基类的虚成员</p>
<blockquote>
<p>除非有很好的理由，一般很少将整个类标记为密封。事实上，人们越来越倾向于将类设置成非密封类，因为单元测试需要创建仿制对象来代替真正的实现。有时对单独虚成员进行密封的代价过高，还不如将整个类密封。但一般都倾向于对单独成员进行有针对性的密封（例如，可能需要依赖基类的实现来获得正确的行为）。</p>
</blockquote>
<h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><p>调用其基类版本的成员(包括构造方法)</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><code>abstract</code><br>抽象类是仅供派生的类，无法实例化抽象类，只能实例化从它派生的类。不抽象、可直接实例化的类称为具体类。</p>
<blockquote>
<p>接口（interface）已经实现了抽象类所拥有的全部功能，甚至还有更多新特性。</p>
</blockquote>
<p>抽象类代表抽象实体。其抽象成员定义了从抽象实体派生的对象应包含什么，但这种成员不包含实现。抽象类的大多数功能通常都没有实现。一个类要从抽象类成功地派生，必须为抽象基类中的抽象方法提供具体的实现。</p>
<p>抽象类的主要特点在于它包含抽象成员。抽象成员是没有实现的方法或属性，作用是强制所有派生类提供实现。</p>
<p>抽象成员不能声明为私有，否则派生类看不见它们。</p>
<ul>
<li><p>抽象成员必须被重写，所以自动为虚，但不能用virtual关键字显式声明。</p>
</li>
<li><p>多态性</p>
<ul>
<li>同一个签名可以有多个实现。<ul>
<li>一个签名不能在一个类中多次使用，所以该签名的每个实现必然包含在不同类中。</li>
</ul>
</li>
<li>只有对象自己才知道如何最好地执行特定操作，通过规定调用这些操作的通用方式，多态性还促进了代码重用，因为通用的东西不必重复编码。</li>
</ul>
</li>
</ul>
<h2 id="所有类都从System-Object派生"><a href="#所有类都从System-Object派生" class="headerlink" title="所有类都从System.Object派生"></a>所有类都从System.Object派生</h2><p>所有类都直接或间接从object派生。</p>
<p>即使字面值也支持object的方法</p>
<h2 id="使用is进行模式匹配"><a href="#使用is进行模式匹配" class="headerlink" title="使用is进行模式匹配"></a>使用is进行模式匹配</h2><p>C#用is操作符判断基础类型</p>
<p>is操作符除了用于类型检查，也可以用于声明变量并且赋值。</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668868466779.png" srcset="/img/loading.gif" lazyload><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668868502811.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="元组模式匹配"><a href="#元组模式匹配" class="headerlink" title="元组模式匹配"></a>元组模式匹配</h3><p>可以将一批常量放在一个元组中，并使用is操作符进行元组模式匹配，并且也可以对元组中的变量进行类型模式匹配和赋值。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668868608466.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="顺序模式匹配"><a href="#顺序模式匹配" class="headerlink" title="顺序模式匹配"></a>顺序模式匹配</h3><p>由于解构函数可以隐含的构造一个元组实例，因此一个具有解构函数的类可以完美匹配元组模式匹配的语法。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668868691124.png" srcset="/img/loading.gif" lazyload><br>在顺序模式匹配中，也可以匹配常量</p>
<h3 id="属性模式匹配"><a href="#属性模式匹配" class="headerlink" title="属性模式匹配"></a>属性模式匹配</h3><p>允许在对一个对象进行模式匹配时，不仅指定属性值，而且指定属性名称。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668868739604.png" srcset="/img/loading.gif" lazyload><br>顺序不重要</p>
<h3 id="递归模式匹配"><a href="#递归模式匹配" class="headerlink" title="递归模式匹配"></a>递归模式匹配</h3><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668869367636.png" srcset="/img/loading.gif" lazyload><br>is操作符的属性模式匹配的优势在于其可以用属性名来直接选取希望匹配的元素或字段</p>
<p>is操作符的属性模式匹配不支持判定性表达式</p>
<blockquote>
<p>读性也差</p>
</blockquote>
<h2 id="switch中的匹配模式"><a href="#switch中的匹配模式" class="headerlink" title="switch中的匹配模式"></a>switch中的匹配模式</h2><p>可读性更高的if<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668926790555.png" srcset="/img/loading.gif" lazyload><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668926805959.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><p>将时间进一步限定为将来某时刻。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668926871291.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>避免对多态类对象使用模式匹配</p>
</blockquote>
<ul>
<li>使用as操作符进行转换，避免了可能因为转型而造成的异常</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口实现关系是一种“能做”（can do）关系：类型“能做”接口所规定的事情。</p>
<p>遵循的条款</p>
<p>能完全隔离实现细节和提供的服务.</p>
<p>接口声明的成员描述了在实现该接口的类型中必须能访问的成员。而所有非公共成员的目的都是阻止其他代码访问成员。所以，C#不允许为接口成员使用访问修饰符。所有成员都自动公共。</p>
<p>接口为多态性而生</p>
<h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><p>类可实现多个接口，但只能从一个基类直接派生</p>
<p>实现接口时，接口的所有抽象成员都必须实现。</p>
<p>在抽象类中可将接口方法映射成自己的抽象方法，将真正的实现留给子类去完成。也可拿掉abstract关键字并添加方法主体。</p>
<p>接口的重点在于永远不能实例化，即不能用new创建接口。因此接口没有构造函数或终结器。只有实例化实现了接口的类型，才能使用接口实例。</p>
<h3 id="显式成员实现"><a href="#显式成员实现" class="headerlink" title="显式成员实现"></a>显式成员实现</h3><p>显式实现的方法只能通过接口本身调用，最典型的做法是将对象转型为接口</p>
<p>在接口成员名称前附加接口名称前缀来显式实现接口成员<code>接口名.</code>。</p>
<p>由于显式接口实现直接和接口关联，所以没必要使用virtual、override或者public来修饰它们。事实上，这些修饰符是不被允许的。这些成员不被视为类的公共成员，标注public有误导之嫌。</p>
<blockquote>
<p>注意，在派生类中实现接口方法时，不允许使用override（重写）关键字。不过，在派生类中实现接口方法时，我们仍然会称之为“重写”。</p>
</blockquote>
<h3 id="隐式成员实现"><a href="#隐式成员实现" class="headerlink" title="隐式成员实现"></a>隐式成员实现</h3><p>要隐式实现成员，只要求成员是公共的，且签名与接口成员签名相符。</p>
<p>显式实现不允许的许多修饰符对于隐式实现都是必须或可选的</p>
<blockquote>
<p>类层次结构是建立在属于(is a)关系上，这些是“语义”（semantic）关系。<br>接口与语义无关，只在实现”机制”关系的细节。不属于”可比较”的机制,但仍可实现IComparable接口<br>显式接口实现的目的就是将机制问题和模型问题分开.要求调用者先将对象转换为接口（比如IComparable），然后才能认为对象“可比较”，从而显式区分你想在什么时候和模型沟通，以及在什么时候处理实现机制。</p>
</blockquote>
<blockquote>
<p>可通过回答以下问题来决定显式还是隐式实现：</p>
</blockquote>
<ol>
<li>成员是不是核心的类功能？</li>
<li>接口成员名称作为类成员名称是否恰当？避免歧义，方法名的功能不能显而易见</li>
<li>是否已经有相同签名的类成员？<br>因此较稳妥的做法是全部显式实现接口成员，使它们以后能安全地变成隐式。</li>
</ol>
<h2 id="接口和实现类的转换"><a href="#接口和实现类的转换" class="headerlink" title="接口和实现类的转换"></a>接口和实现类的转换</h2><p>实现类向接口隐式；<br>接口向实现类显式。</p>
<h2 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h2><p>一个接口可以从另一个接口派生，派生的接口将继承“基接口”的所有成员。</p>
<p>显式实现接口成员时，必须在完全限定的接口成员名称中引用最初声明它的接口的名称。</p>
<p>最后要说的是，虽然“继承”这个词用得没错，但更准确的说法是接口代表契约，一份契约可指定另一份契约也必须”遵守”的条款。</p>
<h2 id="接口上的扩展方法"><a href="#接口上的扩展方法" class="headerlink" title="接口上的扩展方法"></a>接口上的扩展方法</h2><p>扩展方法的一个重要特点是除了能作用于类，还能作用于接口。所使用的语法和用于类时的语法一样。</p>
<h2 id="版本升级"><a href="#版本升级" class="headerlink" title="版本升级"></a>版本升级</h2><p>和类不同，在接口中添加成员也可能造成代码无法编译——除非进行额外的修改。问题在于，实现接口的任何类都必须完整地实现，必须提供针对所有成员的实现。添加新接口成员后，编译器会要求开发者在实现接口的类中添加新的接口成员。</p>
<p>C# 8.0允许在接口中为方法提供默认实现。这样一来，虽然仍然不可以在已经发布的接口中修改或删除现有的方法，但是可以添加新方法，并通过提供默认实现，来避免破坏基于该接口开发的现有程序。</p>
<blockquote>
<p>不要为已发布的接口添加成员，除非提供默认实现。</p>
</blockquote>
<h3 id="默认接口方法"><a href="#默认接口方法" class="headerlink" title="默认接口方法"></a>默认接口方法</h3><p>许为现有接口增加新方法时，同时提供默认实现代码</p>
<p>没有影响之前的多态性</p>
<h3 id="接口其他新特性"><a href="#接口其他新特性" class="headerlink" title="接口其他新特性"></a>接口其他新特性</h3><p>可声明</p>
<ul>
<li>静态成员:字段，构造函数，方法，甚至包括Main方法</li>
<li>实例属性和方法:不支持实例字段所以没有自动实现<ul>
<li>访问默认接口属性或方法，必须将变量转换为接口</li>
</ul>
</li>
<li>public修饰符，更清晰</li>
<li>protected修饰符</li>
<li>private修饰符。接口成员为私有时(如果是方法需要有默认实现)只能从默认方法访问</li>
<li>internal</li>
<li>protected internal</li>
<li>private protected</li>
<li>virtual修饰符，更清晰</li>
<li>sealed修饰符,方法不可被重写</li>
<li>abstract修饰符，只能用于没有默认实现的接口方法，能用但是没啥用</li>
<li>partial接口和方法。方法均自动私有访问</li>
</ul>
<ol>
<li>如果希望提供属性存取方法的默认接口实现，则不可以使用编译器自动实现。这是因为接口中不允许声明实例字段（非静态字段），因此编译器无法找到对应的字段来自动实现属性存取方法。</li>
<li>请注意静态成员和实例成员（非静态成员）的默认访问权限不同。静态成员默认为私有访问，而实例成员则默认为公共访问，这是因为接口中的静态方法必须有默认实现，而静态字段也有相应的实体，这样它们就与普通类中的静态方法和字段非常接近。而类中的静态成员就默认为私有访问，因此接口中的静态成员在访问权限上也与类保持一致。与之对应，接口实例成员（方法和属性）的主要用途是为了实现多态，因此其默认访问权限也要尽量接近C# 8.0之前的一贯风格。</li>
</ol>
<h2 id="扩展方法与默认接口成员"><a href="#扩展方法与默认接口成员" class="headerlink" title="扩展方法与默认接口成员"></a>扩展方法与默认接口成员</h2><ul>
<li>这些方法都可以实现基于相同方法签名的重写</li>
<li>扩展方法可以在任何程序集里面实现，并不局限于接口所在的程序集。</li>
<li>虽然允许为属性的存取添加默认接口方法，但由于接口中不允许添加实例字段，因此如果属性的存取方法需要实现复杂一些的计算，则无法在默认接口方法中实现</li>
<li>也可以利用扩展方法为字段实现类似于属性的“存取方法”（如GetData()），以便在其中实现复杂一些的计算。这样就不必局限于C# 8.0和.NET Core 3.0框架了。</li>
<li>从旧接口派生出新接口，便可以在其中自由地添加新功能。这样既不用担心向上兼容问题，也不用局限于新版本的C#和.NET框架。</li>
<li>派生出新接口的方法需要通过修改实现类来实现新接口。</li>
<li>默认接口方法需要通过该接口来调用，而不能通过接口的实现类的实例来调用[1]。即便在接口的实现类中，若要调用默认接口方法，也必须通过接口来调用。</li>
<li>接口中的protected成员只能被当前接口及其派生接口访问，实现类并不能访问这种成员。</li>
<li>默认接口方法可以被实现类重写，这使得不同的实现类可以为特定方法提供不同的实现。然而扩展方法不能够被类重写，对它的调用在编译时就已经确定了。</li>
</ul>
<p>总之，当要添加新的属性方法时，如果需要支持比C# 8.0和.NET Core 3.0更早期的框架，则派生新接口是唯一选择，否则可以考虑利用默认接口方法来添加新属性。而如果只是要添加新方法而不是属性，则也可以考虑扩展方法。</p>
<blockquote>
<p>若需对已经发布的接口添加新方法，优先考虑扩展方法或者派生新接口<br>如果无法控制接口所允许的多态性，则采用扩展方法更加稳妥<br>如果要添加新的属性方法，而且既要支持多态性，又要支持早期C#和.NET，则只能派生新接口。</p>
</blockquote>
<h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><p>接口引入了另一个类别的数据类型（是少数不扩展System.Object的类型之一）<br>    - 此外还有指针类型和类型参数类型。但每个接口类型都可转换为System.Object，并允许在接口的任何实例上调用System.Object的方法，所以这个区别或许有点儿吹毛求疵。</p>
<p>C# 8.0的接口几乎成为抽象类的功能超集。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668931300122.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>如果一个类已经有父类，若要再为它添加父类，考虑定义接口</p>
</blockquote>
<h2 id="接口和特性"><a href="#接口和特性" class="headerlink" title="接口和特性"></a>接口和特性</h2><p>有时用无任何成员的接口（不管是不是继承的）来描述关于类型的信息。例如，有人会创建名为IObsolete的标记接口（marker interface）指出某类型已被另一类型取代。</p>
<p>一般认为这是对接口机制的“滥用”：接口应表示类型能执行的功能，而非陈述关于类型的事实。所以这时不要使用标记接口，改为使用特性</p>
<blockquote>
<p>避免使用无成员的标记接口，改为使用特性</p>
</blockquote>
<h1 id="值类型-1"><a href="#值类型-1" class="headerlink" title="值类型"></a>值类型</h1><blockquote>
<p>避免创建消耗内存大于16字节的值类型</p>
</blockquote>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><code>struct</code><br>除string和object是引用类型，其他所有C#内建类型（比如bool和int）都是值类型。</p>
<p>可<code>readonly</code>本身和成员</p>
<blockquote>
<p>要创建不可变的值类型（元组例外）</p>
</blockquote>
<h3 id="初始化结构"><a href="#初始化结构" class="headerlink" title="初始化结构"></a>初始化结构</h3><p>除了属性和字段，结构还可包含方法和构造函数，但不可包含用户自定义的默认（无参）构造函数。<br>相反，C#编译器自动生成默认构造函数将所有字段初始化为默认值。</p>
<p>结构中的每个构造函数都必须初始化结构的所有字段（和只读自动实现属性）</p>
<p>如果不用new操作符来调用构造函数从而显式实例化结构，结构中的所有数据都隐式初始化为对应数据类型的默认值。<br>为满足结构初始化要求，所有显式声明的字段都必须初始化。这种初始化必须直接进行。</p>
<ul>
<li>在结构声明中初始化字段会报错，需要在构造函数中初始化</li>
</ul>
<blockquote>
<p>要确保结构的默认值有效。封装并不能阻止访问默认的“全零”值。</p>
</blockquote>
<ul>
<li>为引用类型使用new操作符，“运行时”会在托管堆上创建对象的新实例，将所有字段初始化为默认值，再调用构造函数，将对实例的引用以this的形式传递。new操作符最后返回对实例的引用，该引用被拷贝到和变量关联的内存位置。</li>
<li>为值类型使用new操作符，“运行时”会在临时存储池中创建对象的新实例，将所有字段初始化为默认值，调用构造函数，将临时存储位置作为ref变量以this的形式传递。结果是值被存储到临时存储位置，然后可将该值拷贝到和变量关联的内存位置。</li>
</ul>
<h3 id="继承和接口"><a href="#继承和接口" class="headerlink" title="继承和接口"></a>继承和接口</h3><p>所有值类型都隐式密封。派生自System.ValueType</p>
<p>值类型也能实现接口。</p>
<blockquote>
<p>如需比较相等性，要在值类型上重写相等性操作符（Equals()，&#x3D;&#x3D;和!&#x3D;）并考虑实现IEquatable<T>接口。</p>
</blockquote>
<h2 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h2><p>值类型的变量（直接引用其数据）转换为引用类型（引用堆上的一个位置）</p>
<p>对一个存储位置的引用。该位置表面上包含引用类型的实例，但实际包含值类型的值。这种转换称为装箱</p>
<ol>
<li>堆上分配内存.它将用于存放值类型的数据以及少许额外开销（SyncBlockIndex和方法表指针）</li>
<li>拷贝内存数据</li>
<li>转换结果是对堆上的新存储位置的引用</li>
</ol>
<p>相反的过程称为拆箱（unboxing）。具体是核实已装箱值的类型兼容于要拆箱成的值的类型，再拷贝堆中存储的值，结果是堆上存储的值的拷贝。</p>
<blockquote>
<p>装箱和拆箱都影响性能和行为,频繁需避免</p>
</blockquote>
<ul>
<li>lock语句中的值类型<br>值类型的问题在于装箱，所以每次调用Enter()或Exit()都会在堆上创建新值。将一个拷贝的引用同另一个拷贝的引用比较总是返回false。所以，无法将Enter()与对应的Exit()钩到一起。因此，不允许在lock()语句中使用值类型。</li>
</ul>
<blockquote>
<p>避免可变值类型.因为往往修改的是值的拷贝，而不是真正想要修改的存储位置。</p>
</blockquote>
<ul>
<li>方法调用上避免装箱:<br>任何时候在值类型上调用方法，接收调用的值类型（在方法主体中用this表示）必须是变量而不是值，因为方法可能尝试修改接收者。显然，它必须修改接收者的存储位置，而不是修改接收者的值的拷贝再丢弃该拷贝。</li>
</ul>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><code>enum</code><br>关键特征是在编译时声明了一组具名常量值，这使代码更易读。</p>
<p>枚举值实际作为整数常量实现。默认第一个枚举值是0，后续每一项都递增1。但可以显式地为枚举赋值</p>
<p>枚举总是具有一个基础类型，可以是除char之外的任意整型。</p>
<p>枚举不过是基础类型上的一组名称，对于枚举类型的变量，它的值并不限于声明中命名的值。优点在于可在未来的API版本中为枚举添加新值，同时不会破坏早期版本。</p>
<blockquote>
<p>考虑在现有枚举中添加新成员，但要注意兼容性风险。<br>避免创建代表“不完整”值（如版本号）集合的枚举。<br>避免在枚举中创建“保留给将来使用”的值。<br>避免包含单个值的枚举。<br>要为简单枚举提供值0来代表无。注意若不显式初始化，0就是默认值。</p>
</blockquote>
<h3 id="枚举之间的类型兼容性"><a href="#枚举之间的类型兼容性" class="headerlink" title="枚举之间的类型兼容性"></a>枚举之间的类型兼容性</h3><p>C#不支持不同枚举数组之间的直接转型。但CLR允许，前提是两个枚举具有相同的基础类型。为避开C#的限制，技巧是先转型为System.Array</p>
<p>慎用</p>
<h3 id="在枚举和字符串之间转换"><a href="#在枚举和字符串之间转换" class="headerlink" title="在枚举和字符串之间转换"></a>在枚举和字符串之间转换</h3><p>枚举的一个好处是ToString()方法（通过System.Console.WriteLine()这样的方法来调用）会输出枚举值标识符</p>
<p>使用<code>Enum.TryParse&lt;T&gt;()</code>将字符串转换成枚举</p>
<h3 id="枚举作为标志使用"><a href="#枚举作为标志使用" class="headerlink" title="枚举作为标志使用"></a>枚举作为标志使用</h3><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668940984249.png" srcset="/img/loading.gif" lazyload><br>然后使用<code>&amp; | ! ^</code>等位操作</p>
<blockquote>
<p>要用FlagsAttribute标记包含标志的枚举<br>要为所有标志枚举提供等于0的None值<br>避免将标志枚举中的零值设定为“所有标志都未设置”之外的其他意思。<br>考虑为常用标志组合提供特殊值<br>不要包含“哨兵”值（如Maximum），这种值会使用户困惑<br>要用2的乘方确保所有标志组合都不重复。</p>
</blockquote>
<ul>
<li>FlagsAttribute<br>如决定使用位标志枚举，枚举的声明应该用FlagsAttribute来标记。该特性应包含在一对方括号中，并放在枚举声明之前<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668941268855.png" srcset="/img/loading.gif" lazyload>该特性指出枚举值可以组合。</li>
</ul>
<h1 id="合式类型"><a href="#合式类型" class="headerlink" title="合式类型"></a>合式类型</h1><p>本章将讨论如何完善类型定义</p>
<h2 id="重写object的成员"><a href="#重写object的成员" class="headerlink" title="重写object的成员"></a>重写object的成员</h2><h3 id="ToString"><a href="#ToString" class="headerlink" title="ToString()"></a>ToString()</h3><p>在对象上调用ToString()默认返回类的完全限定名称</p>
<blockquote>
<p>如需返回有用的、面向开发者的诊断字符串，就要重写ToString()。<br>考虑尽量使ToString()返回的字符串简短。<br>不要从ToString()返回空字符串来代表“空”（null）。<br>不要从ToString()抛出异常或造成可观察到的副作用（改变对象状态）。<br>如果返回值与语言文化相关或要求格式化（例如DateTime），就要重载ToString (string format)或实现IFormattable。<br>考虑从ToString()返回独一无二的字符串以标识对象实例</p>
</blockquote>
<h3 id="GetHashCode"><a href="#GetHashCode" class="headerlink" title="GetHashCode()"></a>GetHashCode()</h3><p>底线是重写Equals()就要重写GetHashCode()，否则编译器会显示警告</p>
<p>哈希码（hash code）作用是生成和对象值对应的数字，从而高效地平衡哈希表</p>
<p>·必须：相等的对象必然有相等的哈希码（若a.Equals(b)，则a.GetHashCode()&#x3D;&#x3D;b.GetHashCode()）<br>必须：在特定对象的生存期内，即使对象的数据发生了改变，GetHashCode()也应始终返回相同的值。通常可以将对象的哈希码保存在某个恰当的位置（后文将简称为“缓存”），并让GetHashCode()返回缓存值，从而确保其返回值不变。但是，不要通过对比哈希码来判断两个对象是否相等，因为数据相等的两个对象可能有不相等的哈希码，反之，数据不相等的两个对象，也可能有相等的哈希码。<br>必须：GetHashCode()不应引发任何异常；GetHashCode()总是成功返回一个值。<br>性能：哈希码应尽可能唯一。但由于哈希码只是返回一个int，所以只要一种对象包含的值比一个int能够容纳得多（这就几乎涵盖所有类型了），那么哈希码肯定存在重复。一个很容易想到的例子是long，因为long的取值范围大于int，所以假如规定每个int值都只能标识一个不同的long值，那么肯定剩下大量long值没法标识。<br>性能：可能的哈希码值应当在int的范围内平均分布。例如，创建哈希码时如果没有考虑到字符串在拉丁语言中的分布主要集中在初始的128个ASCII字符上，就会造成字符串值的分布非常不平均，所以不能算是好的GetHashCode()算法。<br>性能：GetHashCode()的性能应该优化。GetHashCode()通常在Equals()实现中用于“短路”一次完整的相等性比较（哈希码都不同，自然没必要进行完整的相等性比较了）。所以，当类型作为字典集合中的键类型使用时，会频繁调用该方法<br>性能：两个对象的细微差异应造成哈希值的极大差异。理想情况下，1位的差异应造成哈希码平均16位的差异。这有助于确保不管哈希表如何对哈希值进行“装桶”（bucketing），也能保持良好的平衡性<br>安全性：攻击者应难以伪造具有特定哈希码的对象。攻击手法是向哈希表中填写大量哈希为同一个值的数据。然后，哈希表的实现会变得效率低下，导致DOS（拒绝服务）攻击。</p>
<p>当然，许多原则是相互对立的。很难有一种哈希算法既快又满足所有这些要求。和任何设计问题一样，好的解决方案必然是综合考虑的结果。</p>
<ul>
<li>System.HashCode的Combine()方法获得对象哈希码</li>
</ul>
<h4 id="Equals"><a href="#Equals" class="headerlink" title="Equals()"></a>Equals()</h4><ol>
<li>对象同一性和相等的对象值<br> 针对引用来说.<blockquote>
<p>为值类型调用ReferenceEquals()总是返回false</p>
</blockquote>
</li>
<li>实现Equals()<br> 两个对象要相等，其标识数据（identifying data）必须相等<blockquote>
<p>object.Equals()的实现只是简单调用了一下ReferenceEquals()</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>要一起实现GetHashCode()、Equals()、&#x3D;&#x3D;操作符和!&#x3D;操作符，缺一不可<br>要用相同算法实现Equals()、&#x3D;&#x3D;和!&#x3D;。<br>避免在可变引用类型上重载相等性操作符（如重载的实现速度过慢，也不要重载）。<br>要在实现IEquitable时实现与相等性相关的所有方法</p>
</blockquote>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951426905.png" srcset="/img/loading.gif" lazyload><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951469783.png" srcset="/img/loading.gif" lazyload><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951481621.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="用元组重写GetHashCode-和Equals"><a href="#用元组重写GetHashCode-和Equals" class="headerlink" title="用元组重写GetHashCode()和Equals()"></a>用元组重写GetHashCode()和Equals()</h3><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951532360.png" srcset="/img/loading.gif" lazyload><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951558334.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>除x.y、f(x)、new、typeof、default、checked、unchecked、delegate、is、as、&#x3D;和&#x3D;&gt;之外，其他所有操作符都支持</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951727721.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>避免在&#x3D;&#x3D;操作符的重载实现中使用该操作符</p>
</blockquote>
<blockquote>
<p>从技术上说，实现显式和隐式转换操作符并不是重载转型操作符（()）。但由于效果一样，所以一般都将“实现显式或隐式转换”说成“定义转型操作符”。<br>定义转换操作符在形式上类似于定义其他操作符，只是“operator”成了转换的结果类型。另外，operator要放在表示隐式或显式转换的implicit或explicit关键字后面<br>不要为有损转换提供隐式转换操作符<br>不要从隐式转换中抛出异常</p>
</blockquote>
<h2 id="引用其他程序集"><a href="#引用其他程序集" class="headerlink" title="引用其他程序集"></a>引用其他程序集</h2><p>不需要将所有代码都放到单独一个二进制文件中，C#和底层CLI框架允许将代码分散到多个程序集中。这样就可在多个可执行文件中重用程序集</p>
<ul>
<li>类库dll  开发者可将程序的不同部分转移到单独的编译单元中，这些单元称为类库(classlib)</li>
</ul>
<h3 id="引用类库"><a href="#引用类库" class="headerlink" title="引用类库"></a>引用类库</h3><ul>
<li>引用库项目文件（*.csproj），指出库的源代码在哪个项目中，并在两个项目之间建立依赖关系</li>
<li>引用程序集文件本身。换言之，引用编译好的库（*.dll）而不是项目。如果库和程序分开编译，比如由企业内的另一个团队编译，这种方式就非常合理。</li>
<li>引用NuGet包</li>
</ul>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951980039.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="NuGet打包"><a href="#NuGet打包" class="headerlink" title="NuGet打包"></a>NuGet打包</h3><p>NuGet不仅包含一个清单来标识作者、公司、依赖项等，还在NuGet.org提供了一个默认包提供者以便上传、更新、索引和下载包</p>
<p>可在项目中引用一个NuGet包（*.nupkg），从你事先配置好的NuGet提供者URL处自动安装。NuGet包提供了一个清单文件（*.nuspec），其中列出了包中所含的所有附加元数据。还提供了你可能想要的所有附加资源，包括本地化文件、配置文件、内容文件等等。最后，NuGet包将所有单独的资源合并成单个ZIP文件（虽然使用.nupkg扩展名）。所以，用*.zip扩展名重命名文件，就可用任何常规压缩工具打开并检查文件内容。</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668952069186.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="类型封装"><a href="#类型封装" class="headerlink" title="类型封装"></a>类型封装</h2><p>类封装行为和数据，而程序集封装一组类型。开发者可将一个系统分解成多个程序集，在多个应用程序之间共享，或将它们与第三方提供的程序集集成。</p>
<p>不添加任何访问修饰符的类或结构体会被默认声明为内部访问（等同于使用关键字internal来声明），而嵌套类型（即声明在类中的类）则默认被声明为私有访问。</p>
<p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668952176122.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h2><p>namespace<br>组织所有类型，用命名空间对它们进行逻辑分组</p>
<blockquote>
<p>不要使用容易变化的名称（组织层次结构、短期品牌等）<br>要为命名空间附加公司名前缀，防止不同公司使用同一个名称<br>要为命名空间二级名称使用稳定的、不随版本升级而变化的产品名称<br>不要定义没有明确放到一个命名空间中的类型<br>考虑创建和命名空间层次结构匹配的文件夹结构</p>
</blockquote>
<blockquote>
<p>CLR中没有“命名空间”这种东西。类型名称必然完全限定</p>
</blockquote>
<h2 id="XML注释"><a href="#XML注释" class="headerlink" title="XML注释"></a>XML注释</h2><p>这种提示能为大型应用程序的开发提供重要帮助，尤其是多个开发者需要共享代码的时候</p>
<p>由于XML注释旨在提供API文档，所以一般只和C#声明配合使用</p>
<blockquote>
<p>如果签名不能完全说明问题，要为公共API提供XML文档，其中包括成员说明、参数说明和API调用示例。</p>
</blockquote>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收是“运行时”的核心功能，旨在回收不再被引用的对象所占用的内存<br>    垃圾回收器只回收内存，不处理其他资源，比如数据库连接、句柄（文件、窗口等）、网络端口以及硬件设备（比如串口</p>
<h3 id="NET中的垃圾回收"><a href="#NET中的垃圾回收" class="headerlink" title=".NET中的垃圾回收"></a>.NET中的垃圾回收</h3><p>.NET的垃圾回收器采用mark-and-compact算法[1]。一次垃圾回收周期开始时，它识别对象的所有根引用。根引用是来自静态变量、CPU寄存器以及局部变量或参数实例（以及本节稍后会讲到的f-reachable对象）的任何引用。基于该列表，垃圾回收器可遍历每个根引用所标识的树形结构，并递归确定所有根引用指向的对象。这样，垃圾回收器就可识别出所有可达对象。<br>执行垃圾回收时，垃圾回收器不是枚举所有访问不到的对象；相反，它将所有可达对象紧挨着放到一起，从而覆盖不可访问的对象（也就是垃圾，或者不可达对象）<br>为定位和移动所有可达对象，系统要在垃圾回收器运行期间维持状态的一致性。为此，进程中的所有托管线程都会在垃圾回收期间暂停。这显然会造成应用程序出现短暂的停顿。不过，除非某次垃圾回收耗时特别长或者垃圾回收过于频繁，否则这个停顿是不太引人注意的。为尽量避免在不恰当的时间执行垃圾回收，System.GC对象包含一个Collect()方法。可在执行关键代码之前调用它（执行这些代码时不希望GC运行）。这样做不会阻止垃圾回收器运行，但会显著减小它运行的可能性——前提是关键代码执行期间不会发生内存被大量消耗的情况。<br>.NET垃圾回收的特别之处在于，并非所有垃圾都一定会在一个垃圾回收周期中清除。研究对象的生存期会发现：相较于长期存在的对象，最近创建的对象更有可能需要垃圾回收。为此，.NET垃圾回收器支持“代”（generation）的概念，它会以更快的频率尝试清除生存时间较短的对象（新生对象）。而那些已在一次垃圾回收中“存活”下来的对象（老对象）会以较低的频率清除。具体地说，共有3代对象。一个对象每次在一个垃圾回收周期中存活下来，它都会移动到下一代，直至最终移动到第二代（从第零代开始）。相较于第二代对象，垃圾回收器会以更快的频率对第零代的对象执行垃圾回收。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用不阻止对对象进行垃圾回收，但会维持一个引用。这样，对象在被垃圾回收器清除之前可以重用。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953179806.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="资源清理"><a href="#资源清理" class="headerlink" title="资源清理"></a>资源清理</h2><p>垃圾回收是“运行时”的重要职责。但要注意，垃圾回收旨在提高内存利用率，而非清理文件句柄、数据库连接字符串、端口或其他有限的资源。</p>
<h3 id="终结器"><a href="#终结器" class="headerlink" title="终结器"></a>终结器</h3><p>类名之前<code>~</code><br>允许程序员写代码来清理类的资源，无法显式调用.负责释放像数据库连接和文件句柄这样的资源，这些资源需通过一次显式的行动来进行清理，而垃圾回收器不知道具体如何采取这些行动。</p>
<p>唯一确定的是终结器会在对象最后一次使用之后，并“通常”在应用程序正常关闭前的某个时间运行。这里“通常”一词是为了强调事实上终结器有可能不会被调用。尤其当程序被强行关闭时。例如，计算机关机，或者程序被调试器强行终止，终结器都很有可能不会被调用。</p>
<h3 id="使用using语句进行确定性终结"><a href="#使用using语句进行确定性终结" class="headerlink" title="使用using语句进行确定性终结"></a>使用using语句进行确定性终结</h3><ul>
<li><p>IDisposable接口用名为Dispose()<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953458810.png" srcset="/img/loading.gif" lazyload><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953473415.png" srcset="/img/loading.gif" lazyload><br>即使开发者忘记显式调用Close()，终结器也会调用它。虽然终结器运行得会晚一些（相较于显式调用Close()），但该方法肯定会得到调用。</p>
</li>
<li><p>实例化TemporaryFileStream后，调用Dispose()前，有可能发生一个异常。这造成Dispose()得不到调用，资源清理不得不依赖于终结器。为避免这个问题，调用者需要实现一个try&#x2F;finally块。但开发者不需要显式地写一个这样的块。因为C#为此提供了using语句。<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953552863.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>using语句只是提供了try&#x2F;finally块的语法快捷方式。</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收、终结和IDisposable"><a href="#垃圾回收、终结和IDisposable" class="headerlink" title="垃圾回收、终结和IDisposable"></a>垃圾回收、终结和IDisposable</h3><ol>
<li>IDisposable.Dispose()方法包含对System.GC.SuppressFinalize()的调用，作用是从终结（f-reachable）队列中移除TemporaryFileStream类实例。这是因为所有清理都在Dispose()方法中完成了，而不是等着终结器执行。<ul>
<li>该队列中的对象已差不多准备好了进行垃圾回收，只是它们还有终结方法没有运行。这种对象只有在其终结方法被调用之后，才能由“运行时”进行垃圾回收。但垃圾回收器本身不调用终结方法。相反，对这种对象的引用会添加到f-reachable队列中，并由一个额外的线程根据执行上下文，挑选合适的时间进行处理。讽刺的是，这造成了托管资源的垃圾回收时间的推迟——而许多这样的资源本应更早一些被清理。推迟是因为f-reachable队列是“引用”列表。所以，对象只有在它的终结方法得到调用，而且对象引用从f-reachable队列中删除之后，才会真正变成“垃圾”.正是由于这个原因，Dispose()才调用System.GC.SuppressFinalize，告诉“运行时”不要将该对象添加到f-reachable队列，而是允许垃圾回收器在对象没有任何引用（包括任何f-reachable引用）时清除对象。</li>
</ul>
</li>
<li>Dispose()调用了Dispose(bool disposing)方法，并传递实参true。结果是为Stream调用Dispose()方法（清理它的资源并阻止终结）。接着，临时文件在调用Dispose()后立即删除。这个重要的调用避免了一定要等待终结队列处理完毕才能清理资源的限制</li>
<li>终结器现在不是调用Close()，而是调用Dispose(bool disposing)，并传递实参false。结果是即使文件被删除，Stream也不会关闭（disposed）。原因是从终结器中调用Dispose(bool disposing)时，Stream实例本身还在等待终结（或者已经终结，系统会以任意顺序终结对象）。所以，在执行终结器时，拥有托管资源的对象不应清理，那应该是终结队列的职责。</li>
<li>同时创建Close()和Dispose()方法需谨慎。只看API并不知道Close()会调用Dispose()。所以开发者搞不清楚是否需要显式调用Close()和Dispose()。</li>
<li>若要提高终结器在程序结束之前被调用的可能性，可以将终结器中的代码实现并注册到AppDomain.CurrentDomain.ProcessExit事件处理器中。这个方法即便在.NET Core中也有效。只要程序没有异常终止，可以保证代码被执行。（下一节将具体介绍）</li>
</ol>
<blockquote>
<p>避免为自己拥有的、带终结器的对象调用Dispose()。相反，依赖终结队列清理实例。·避免在终结方法中引用未被终结的其他对象。·要在重写Dispose()时调用基类的实现。·考虑在调用Dispose()后将对象状态设为不可用。对象被dispose之后，调用除Dispose()之外的方法应引发ObjectDisposedException异常。（Dispose()应该能多次调用。）·要为含有可dispose字段（或属性）的类型实现IDisposable接口，并dispose这些字段引用的对象。·要在派生类的Dispose()中调用基类的Dispose()。·要重构终结器方法来调用与IDisposable相同的代码，可能就是调用一下Dispose()方法。·不要在终结器方法中抛出异常。·若要提高终结器在程序结束之前被调用的可能性，考虑将终结器中的代码实现在事件处理器里并注册到AppDomain.CurrentDomain.ProcessExitevent中。·如果一个类同时注册了AppDomain.CurrentDomain.ProcessExitevent事件，又实现了Dispose()，一定要在Dispose()方法中解除注册的事件。·要从Dispose()中调用System.GC.SuppressFinalize()，以使垃圾回收更快地发生，并避免重复性的资源清理。·要保证Dispose()可以重入（可被多次调用）。·要保持Dispose()的简单性，把重点放在终结所要求的资源清理上。·要只为使用了稀缺或昂贵资源的对象实现终结器方法，即使终结会推迟垃圾回收。·要为有终结器的类实现IDisposable接口以支持确定性终结。·只有当类包含必须释放的资源，而该资源自己又没有终结器的时候，才要在类中实现终结器。</p>
</blockquote>
<blockquote>
<p>从.NET Core开始，程序结束时终结器不一定会被调用。若要提高终结器被调用的可能性，需要为相应的代码进行注册程序退出事件处理器</p>
</blockquote>
<blockquote>
<p>即使有异常从构造函数传播出来，对象仍会实例化，只是没有新实例从new操作符返回。如类型定义了终结器，对象一旦准备好进行垃圾回收，就会运行该方法（即使只构造了一部分的对象，终结方法也会运行）。另外要注意，如构造函数过早共享它的this引用，即使构造函数抛出异常，也能访问该引用。不要让这种情况发生。</p>
</blockquote>
<blockquote>
<p>调用对象的终结方法时，对该对象的引用都已消失。垃圾回收前唯一剩下的步骤就是运行终结代码。但完全可能无意中重新引用一个待终结的对象。这样，被重新引用的对象就不再是不可访问的，所以不能当作垃圾被回收掉。但假如对象的终结方法已经运行，那么除非显式标记为要进行终结（使用GC.ReRegisterFinalize()方法），否则终结方法不一定会再次运行。显然，像这样的对象复活是非常罕见的，而且通常应该避免发生。终结代码应该简单，只清理它引用的资源。</p>
</blockquote>
<h2 id="推迟初始化"><a href="#推迟初始化" class="headerlink" title="推迟初始化"></a>推迟初始化</h2><p>使用推迟初始化，可在需要时才创建（或获取）对象，而不是提前创建好——尤其是它们永远都不使用的前提下。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953911587.png" srcset="/img/loading.gif" lazyload alt="推迟加载属性"></p>
<h3 id="为泛型和Lambda表达式使用推迟加载"><a href="#为泛型和Lambda表达式使用推迟加载" class="headerlink" title="为泛型和Lambda表达式使用推迟加载"></a>为泛型和Lambda表达式使用推迟加载</h3><p>从C# 4.0和Microsoft .NET Framework 4.0开始，CLR添加了一个新类来帮助进行推迟初始化，这个类就是System.Lazy<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953951386.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><hr>
<p>学习资料:<br><a target="_blank" rel="noopener" href="https://weread.qq.com/web/reader/16d32eb07297616a16d8f40k81232fb025f812b4ba28a23">c#8.0本质论</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0/" class="category-chain-item">学习</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/c/" class="category-chain-item">c#</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>c#学习</div>
      <div>http://tupi00.github.io/2022/11/06/技术/csharp/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>tupi</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年11月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/11/06/%E5%AD%A6%E6%A0%A1/java/" title="java作业">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">java作业</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/06/%E6%8A%80%E6%9C%AF/unity/" title="unity的学习">
                        <span class="hidden-mobile">unity的学习</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    

  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

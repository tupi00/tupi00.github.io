<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图</title>
      <link href="/2022/11/12/skill/tu/"/>
      <url>/2022/11/12/skill/tu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/B38A17D34E9DADE17DDC9A880ABC3F2C.jpg"></p><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><ul><li>类 三格 上层类名，中层属性，下层方法<ul><li><code>+</code>公有,<code>-</code>私有,<code>#</code>受保护的</li><li><code>访问权限 名(名 类型):类型</code></li><li>接口<code>《interface》</code></li><li>抽象<code>《abstract》</code></li></ul></li><li>关系:<ul><li>关联:拥有数据成员或者使用类.<ul><li>单向:箭头</li><li>双向:线</li><li>自关:指向自己的箭头</li></ul></li><li>聚合:整体包含部分,可分的数据成员。机车和发动机。空心方块+箭头.</li><li>组合:部分不可离开整体的数据成员。人头和嘴。实心方块+箭头</li><li>依赖:数据成员的方法签名:</li></ul></li><li>继承:实线空三角</li><li>实现:虚线空三角<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/IMG20221112213833.jpg"><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1.jpg"></li></ul><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><ul><li>圆开始接受</li><li>方处理</li><li>菱形判断</li><li>不规则的文档:文件输入&#x2F;输出</li><li>箭头流向.<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/IMG20221112213816.jpg"></li></ul><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>要素:</p><ul><li>角色(主体),</li><li>对象(客体)<ul><li>生命线。对象消亡的时间</li><li>控制焦点(方块)，对象操作时间</li></ul></li><li>消息<ul><li>同步:黑三角</li><li>异步:箭头</li><li>返回:虚箭头</li><li>可自关联</li></ul></li><li>组合片段<ul><li>Opt—if</li><li>Alt—ifelse</li><li>Loop<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/IMG20221112213757.jpg"><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/IMG20221112213801.jpg"></li></ul></li></ul><hr><p>渡易水歌</p><p><a href="https://so.gushiwen.cn/authorv_2128926194cd.aspx">佚名</a>  <a href="https://so.gushiwen.cn/shiwens/default.aspx?cstr=%E5%85%88%E7%A7%A6">〔先秦〕</a></p><p>风萧萧兮易水寒，壮士一去兮不复还。<br>探虎穴兮入蛟宫，仰天呼气兮成白虹。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法练习</title>
      <link href="/2022/11/12/skill/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
      <url>/2022/11/12/skill/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/B38A17D34E9DADE1279EB10AF815CD90.jpg"></p><h1 id="算法练习"><a href="#算法练习" class="headerlink" title="算法练习"></a>算法练习</h1><p><a href="https://tupi00.github.io/2022/11/06/csharp/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">数据结构和算法的学习 - tupi的博客 (tupi00.github.io)</a></p><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">/*</span><br><span class="hljs-comment">设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1)</span><br><span class="hljs-comment">2022年11月12日14:27:58-2022年11月12日14:29:31</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">int</span>[] array1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-built_in">int</span>[] array2 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>Console.WriteLine(Reverse(array1));<br>Console.WriteLine(Reverse(array2));<br><span class="hljs-function"><span class="hljs-built_in">int</span>[] <span class="hljs-title">Reverse</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data</span>)</span><br>&#123;<br><span class="hljs-built_in">int</span>[] array=data;<br><span class="hljs-built_in">int</span> length=array.Length;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;length /<span class="hljs-number">2</span>; i++)<br>&#123;<br><span class="hljs-built_in">int</span> temp=array[i];<br>array[i]=array[length<span class="hljs-number">-1</span>-i];<br>array[length<span class="hljs-number">-1</span>-i]=temp;<br>&#125;<br><span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">/*</span><br><span class="hljs-comment">对于长度为n的顺序表L，编写一个时间复杂度为O(n)，空间复杂度为O(1)的算法，该算法删除线性表中所有值为x的数据元素。</span><br><span class="hljs-comment">2022年11月12日14:30:23-2022年11月12日14:35:27</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">int</span>[] array = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>&#125;;<br>Console.WriteLine(DeleteByValue(array,<span class="hljs-number">3</span>));<br><span class="hljs-function"><span class="hljs-built_in">int</span>[] <span class="hljs-title">DeleteByValue</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data,<span class="hljs-built_in">int</span> data2</span>)</span><br>&#123;<br><span class="hljs-keyword">var</span> array=data;<br><span class="hljs-keyword">var</span> length=data.Length;<br><span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span>=data2;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;length; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(array[i]==<span class="hljs-keyword">value</span>)<br>array[i]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">/*</span><br><span class="hljs-comment">从顺序表中删除值在s和t之间的所有元素，如果s和t不合理，显示错误信息并退出。</span><br><span class="hljs-comment">2022年11月12日14:36:04-2022年11月12日14:43:19</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">int</span>[] array1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br><span class="hljs-built_in">int</span>[] array2 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br><br>Console.WriteLine(DeleteByRange(array1,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));<br>Console.WriteLine(DeleteByRange(array2,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>));<br><br><span class="hljs-function"><span class="hljs-built_in">int</span>[] <span class="hljs-title">DeleteByRange</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data, <span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>&#123;<br><span class="hljs-keyword">var</span> array = data;<br><span class="hljs-keyword">var</span> length = data.Length;<br><span class="hljs-keyword">var</span> start = x;<br><span class="hljs-keyword">var</span> end = y;<br><br><span class="hljs-keyword">if</span> (start &gt; end)<br>&#123;<br>Console.WriteLine(<span class="hljs-string">&quot;error&quot;</span>);<br><span class="hljs-keyword">return</span> array;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>&#123;<br><span class="hljs-keyword">var</span> now=array[i];<br><span class="hljs-keyword">if</span>(now&gt;=start&amp;&amp;now&lt;=end)<br>array[i]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">/*</span><br><span class="hljs-comment">从有序的顺序表中删除所有的重复的元素，使得顺序表的元素不重复</span><br><span class="hljs-comment">2022年11月12日14:43:31-2022年11月12日14:52:33</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">int</span>[] array = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>&#125;;<br><br>Console.WriteLine(Deduplication(array));<br><br><span class="hljs-function"><span class="hljs-built_in">int</span>[] <span class="hljs-title">Deduplication</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] data</span>)</span><br>&#123;<br><span class="hljs-keyword">var</span> array=data;<br><span class="hljs-keyword">var</span> length=data.Length;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>&#123;<br><span class="hljs-keyword">var</span> now = array[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i+<span class="hljs-number">1</span>; j &lt; length; j++)<br>&#123;<br><span class="hljs-keyword">if</span>(array[j]==now)<br>array[j]=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">/*</span><br><span class="hljs-comment">将两个有序表合并成一个有序表</span><br><span class="hljs-comment">2022年11月12日14:52:472022年11月12日15:40:44</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">int</span>[] array1 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br><span class="hljs-built_in">int</span>[] array2 = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><br>Console.WriteLine(Combined(array1,array2));<br><br><span class="hljs-function"><span class="hljs-built_in">int</span>[] <span class="hljs-title">Combined</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] x,<span class="hljs-built_in">int</span>[]y</span>)</span><br>&#123;<br><span class="hljs-built_in">int</span>[] array1 =x;<br><span class="hljs-keyword">var</span> length1=x.Length;<br><span class="hljs-built_in">int</span>[] array2 =y;<br><span class="hljs-keyword">var</span> length2=y.Length;<br><br><span class="hljs-keyword">var</span> length=length1+length2;<br><span class="hljs-built_in">int</span>[] array=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[length];<br><span class="hljs-built_in">int</span> index1=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> index2=<span class="hljs-number">0</span>;<br> <br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;length; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (index1&gt;length1<span class="hljs-number">-1</span>)<br>&#123;<br>array[i]=array2[index2];<br>index2++;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (index2&gt;length2<span class="hljs-number">-1</span>)<br>&#123;<br>array[i] = array1[index1];<br>index1++;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (array1[index1] &lt;= array2[index2])<br>&#123;<br>array[i]=array1[index1];<br>index1++;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>array[i]=array2[index2];<br>index2++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">/*</span><br><span class="hljs-comment">已知在一维数组A[m+n]中依次存放两个线性表（a1,a2…,am）和（b1,b2…,bn），</span><br><span class="hljs-comment">编写算法将两个线性表位置对换成（b1,b2,…bn,a1,a2,…am）</span><br><span class="hljs-comment">2022年11月12日15:41:16-2022年11月12日16:20:20</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">int</span>[] array = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br>Console.WriteLine(Exchange(array,<span class="hljs-number">2</span>));<span class="hljs-comment">//34512</span><br><br><span class="hljs-function"><span class="hljs-built_in">int</span>[] <span class="hljs-title">Exchange</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] x,<span class="hljs-built_in">int</span> m</span>)</span><br>&#123;<br><br><span class="hljs-keyword">var</span> array=x;<br><span class="hljs-keyword">var</span> length=x.Length;<br><br><span class="hljs-built_in">int</span> index=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span>[] temp=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[m];<br><span class="hljs-built_in">int</span> indexOfTemp=<span class="hljs-number">0</span>;<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<span class="hljs-comment">//2</span><br>&#123;<br>temp[i]=array[i];<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = m; i &lt;((length+<span class="hljs-number">2</span>)-m); i++)<span class="hljs-comment">//3</span><br>&#123;<br>array[index]=array[i];<br>Console.WriteLine(i);<br>index++;<span class="hljs-comment">//3</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = index; i &lt; length; i++)<span class="hljs-comment">//2</span><br>&#123;<br>array[i]=temp[indexOfTemp];<br>indexOfTemp++;<br>&#125;<br><br><span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><a href="https://so.gushiwen.cn/shiwenv_1da16040c5e0.aspx"><strong>鹧鸪天·代人赋</strong></a></p><p><a href="https://so.gushiwen.cn/authorv.aspx?name=%E8%BE%9B%E5%BC%83%E7%96%BE">辛弃疾</a><a href="https://so.gushiwen.cn/shiwens/default.aspx?cstr=%E5%AE%8B%E4%BB%A3">〔宋代〕</a></p><p>晚日寒鸦一片愁。柳塘新绿却温柔。若教眼底无离恨，不信人间有白头。<br>肠已断，泪难收。相思重上小红楼。情知已被山遮断，频倚阑干不自由。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
          <category> 作品 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习路线</title>
      <link href="/2022/11/09/skill/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2022/11/09/skill/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/v2-2199a29dfca7a04270fafb715f221ac2_720w.webp"><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/aspnetcore-developer-roadmap.zh-Hans.png" alt="参考"><br><img src="http://assets.processon.com/chart_image/636f5d801e085317c6a93f24.png" alt="我的学习路线"><br><a href="https://www.processon.com/view/link/636f67ce7d9c0806b8a4e87f#map">详情地址</a></p><hr><p>侠客行</p><p><a href="https://so.gushiwen.cn/authorv_b90660e3e492.aspx">李白</a>  <a href="https://so.gushiwen.cn/shiwens/default.aspx?cstr=%E5%94%90%E4%BB%A3">〔唐代〕</a></p><p>赵客缦胡缨，吴钩霜雪明。<br>银鞍照白马，飒沓如流星。<br>十步杀一人，千里不留行。<br>事了拂衣去，深藏身与名。<br>闲过信陵饮，脱剑膝前横。<br>将炙啖朱亥，持觞劝侯嬴。<br>三杯吐然诺，五岳倒为轻。<br>眼花耳热后，意气素霓生。<br>救赵挥金槌，邯郸先震惊。<br>千秋二壮士，烜赫大梁城。<br>纵死侠骨香，不惭世上英。<br>谁能书阁下，白首太玄经</p><hr>]]></content>
      
      
      <categories>
          
          <category> c# </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2022/11/07/skill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/11/07/skill/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/B38A17D34E9DADE19A1E9B8FDFDBD27A.jpg"></p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><h3 id="高内聚-低耦合"><a href="#高内聚-低耦合" class="headerlink" title="高内聚,低耦合"></a>高内聚,低耦合</h3><p>总体要求:</p><ol><li>每个成员方法只完成一件事</li><li>减少成员方法的互相调用</li><li>减少类的互相调用<br>实现方式:</li></ol><ul><li>减少类的继承,多用接口隐藏实现细节</li><li>模块的功能划分尽可能单一</li><li>一个定义只在一个地方出现</li><li>少用全局变量</li><li>多用设计模式</li><li>减少硬编码</li><li>对外只暴露接口</li><li>除非是接口，修改不得影响其他模块</li><li>避免直接调用其他模块.<ul><li>如果必须耦合:尽量值传递,少作为开关,访问入口单一.<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/IMG20221112214916.jpg"></li></ul></li></ul><h3 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h3><ul><li>S 个方法只一件事(一个接口尽可能只有一个功能)</li><li>O 扩展开放,对修改关闭</li><li>L 类能出现的地方子类都能出现.输入参数可以放大,输出参数可以缩小</li><li>I 个对象对其他对象最少了解.君子之交.</li><li>I 类与类间的依赖在最小接口上</li><li>D 向接口编程。每个类都有接口&#x2F;抽象类，不从具体派生，补充协议基类方法.<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/IMG20221112214922.jpg"></li></ul><h2 id="常用模式"><a href="#常用模式" class="headerlink" title="常用模式"></a>常用模式</h2><h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><h4 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h4><ul><li>简单工厂:一个用于建对象的类<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/IMG20221112215202.jpg"></li><li>工厂方法:一个用于创建对象的接口&#x2F;抽象类,派生类决定实例化的类型<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/IMG20221112215207.jpg"></li><li>抽象工厂方法:有多个抽象的产品<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/IMG20221112215213.jpg"></li></ul><h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><p>保证一个类只有一个实例,而且自动实例化并且向整个系统提供这一个实例.(同一个对象)<br>构造方法私有化.</p><ul><li>饿汉式:类加载时立即初始化,创建实例.<ul><li>静态字段+静态方法</li><li>静态字段+静态代码块</li></ul></li><li>懒汉式<ol><li>静态字段&#x3D;null;</li><li>静态的getInstance<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/IMG20221112215218.jpg"><br>许多开发者将单例模式视为一种反模式。 因此它在 C# 代码中的使用频率正在逐步减少。</li></ol></li></ul><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>复制原有的对象，又无需要使代码依赖他们的类.<br>(在表面不用new)</p><ul><li>仅有克隆方法的接口</li><li>类实现接口<ul><li>构造函数接受本类型.并对所需要的数据成员赋值</li><li>Clone方法返回接口，参数为接口<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/IMG20221116171644.jpg"><blockquote><p>c#实现:<code>Object.MemberwiseClone()</code>就是当前 Object 的浅表副本。克隆方法返回即可.</p></blockquote></li></ul></li></ul><h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>用树性结构在组合对象.<br>盒子&#x3D;(盒子(盒子+产品)+产品).操作时对所有</p><ol><li>通用接口有一个总方法</li><li>叶节点实现方法</li><li>组合类<ul><li>有个通用接口的数组子元素</li><li>实现方法大部分工作交由子元素完成.<ul><li>遍历子元素，执行接口方法</li></ul></li><li>对子元素的增删查.<br>确定:对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/IMG20221116162404.jpg"></li></ul></li></ol><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><hr><p>沁园春·雪</p><p><a href="https://so.gushiwen.cn/authorv_22550138288c.aspx">毛泽东</a>  <a href="https://so.gushiwen.cn/shiwens/default.aspx?cstr=%E8%BF%91%E7%8E%B0%E4%BB%A3">〔近现代〕</a></p><p>北国风光，千里冰封，万里雪飘。<br>望长城内外，惟余莽莽；大河上下，顿失滔滔。<br>山舞银蛇，原驰蜡象，欲与天公试比高。<br>须晴日，看红装素裹，分外妖娆。<br>江山如此多娇，引无数英雄竞折腰。<br>惜秦皇汉武，略输文采；唐宗宋祖，稍逊风骚。<br>一代天骄，成吉思汗，只识弯弓射大雕。<br>俱往矣，数风流人物，还看今朝。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>写在前面</title>
      <link href="/2022/11/06/webabout/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
      <url>/2022/11/06/webabout/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/OIP-C%20(1).jpg"></p><h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><hr><p>蜀道难</p><p><a href="https://so.gushiwen.cn/authorv_b90660e3e492.aspx">李白</a>  <a href="https://so.gushiwen.cn/shiwens/default.aspx?cstr=%E5%94%90%E4%BB%A3">〔唐代〕</a></p><p>噫吁嚱，危乎高哉！<br>蜀道之难，难于上青天！<br>蚕丛及鱼凫，开国何茫然！<br>尔来四万八千岁，不与秦塞通人烟。<br>西当太白有鸟道，可以横绝峨眉巅。<br>地崩山摧壮士死，然后天梯石栈相钩连。<br>上有六龙回日之高标，下有冲波逆折之回川。<br>黄鹤之飞尚不得过，猿猱欲度愁攀援。<br>青泥何盘盘，百步九折萦岩峦。<br>扪参历井仰胁息，以手抚膺坐长叹。<br>问君西游何时还？畏途巉岩不可攀。<br>但见悲鸟号古木，雄飞雌从绕林间。<br>又闻子规啼夜月，愁空山。<br>蜀道之难，难于上青天，使人听此凋朱颜！<br>连峰去天不盈尺，枯松倒挂倚绝壁。<br>飞湍瀑流争喧豗，砯崖转石万壑雷。<br>其险也如此，嗟尔远道之人胡为乎来哉！<br>剑阁峥嵘而崔嵬，一夫当关，万夫莫开。<br>所守或匪亲，化为狼与豺。<br>朝避猛虎，夕避长蛇，磨牙吮血，杀人如麻。<br>锦城虽云乐，不如早还家。<br>蜀道之难，难于上青天，侧身西望长咨嗟！</p><hr>]]></content>
      
      
      <categories>
          
          <category> 本站 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java作业</title>
      <link href="/2022/11/06/school/java/"/>
      <url>/2022/11/06/school/java/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/114456914.jpg"><br>学习java以作毕设使用，感谢学校老师指导</p><h2 id="好用工具"><a href="#好用工具" class="headerlink" title="好用工具"></a>好用工具</h2><ol><li>UML图插件:PlantUML Integration和Sequence Diagram插件<ul><li>Sequence Diagram 自动生成<ul><li>对方法右键SD生成调用关系 <ul><li>配置层数,一般5层</li><li>可对代码单独查看</li></ul></li><li>创建文件的方式也可以</li><li>生成UML配合插件</li></ul></li><li>PlantUML Integration 手动编辑，创建文件<ul><li>没成功:Graphviz安装<a href="https://graphviz.org/download/">Download | Graphviz</a></li></ul></li></ul></li><li>Debug:<ol><li>断点打在接口方法上，当运行时进入接口的实现类（如果接口实现类太多的时候很好用）  </li><li>异常断点，添加异常断点，运行时如果会抛异常，那么会自动停在抛异常的代码上  </li><li>属性断点，断点加在字段上，当属性的值发生改变时，会自动停住</li></ol></li><li>代码生成插件:EasyCode<a href="https://www.bilibili.com/video/BV1YY41187fY/?spm_id_from=333.788.recommend_more_video.17&vd_source=91f53763fb9a775417e4fbe107927eb5">【IDEA】IDEA代码全自动生成，国产插件就是牛！_哔哩哔哩_bilibili</a><ol><li>MapperScan dao层</li><li>配置数据库连接信息及Mybatis的mapper-locations</li><li><code>SpringboottexampleApplication</code>类启动项目</li><li>在controller层测试运行接口</li></ol></li><li>idea上的postman:Restful Fast Request插件<ul><li>配置:项目名，地址。添加个测试环境</li><li>小火箭-&gt;小飞机</li></ul></li><li>Mybatis sql语句日志: Mybatis Log Free<ul><li>在工具中显示</li><li>在applicationContext.xml中配置:  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl<br></code></pre></td></tr></table></figure></li></ul></li></ol><ul><li>log4j<br>  log4j.properties  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Global logging configuration</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置日志输出级别以及输出目的地，可以设置多个输出目的地，开发环境下，日志级别要设置成DEBUG或者ERROR</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">前面写日志级别，逗号后面写输出目的地：我自己下面设置的目的地相对应，以逗号分开</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">log4j.rootLogger = [level],appenderName1,appenderName2</span><br>log4j.rootLogger=DEBUG,CONSOLE,LOGFILE<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">### 控制台输出 ####</span></span><br>log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出到控制台</span><br>log4j.appender.CONSOLE.Target = System.out<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定控制台输出日志级别</span><br>log4j.appender.CONSOLE.Threshold = DEBUG<br><span class="hljs-meta prompt_"># </span><span class="language-bash">默认值是 <span class="hljs-literal">true</span>, 表示是否立即输出</span><br>log4j.appender.CONSOLE.ImmediateFlush = true<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置编码方式</span><br>log4j.appender.CONSOLE.Encoding = UTF-8<br><span class="hljs-meta prompt_"># </span><span class="language-bash">日志输出布局</span><br>log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果日志输出布局为PatternLayout 自定义级别，需要使用ConversionPattern指定输出格式</span><br>log4j.appender.CONSOLE.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %5p (%c:%L) - %m%n<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">### 输出错误信息到文件 ####</span></span><br>log4j.appender.LOGFILE=org.apache.log4j.FileAppender<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定输出文件路径</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">log4j.appender.LOGFILE.File =F://Intellij idea/logs/error.log</span> <br>log4j.appender.LOGFILE.File =./logs/error.log <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">日志输出到文件，默认为<span class="hljs-literal">true</span></span><br>log4j.appender.LOGFILE.Append = true<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定输出日志级别</span><br>log4j.appender.LOGFILE.Threshold = ERROR<br><span class="hljs-meta prompt_"># </span><span class="language-bash">是否立即输出，默认值是 <span class="hljs-literal">true</span>,</span><br>log4j.appender.LOGFILE.ImmediateFlush = true<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置编码方式</span><br>log4j.appender.LOGFILE.Encoding = UTF-8<br><span class="hljs-meta prompt_"># </span><span class="language-bash">日志输出布局</span><br>log4j.appender.LOGFILE.layout = org.apache.log4j.PatternLayout<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果日志输出布局为PatternLayout 自定义级别，需要使用ConversionPattern指定输出格式</span><br>log4j.appender.LOGFILE.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n<br></code></pre></td></tr></table></figure></li></ul><ol start="6"><li><p>日志配置</p><ul><li>项目启动日志:启动appliction配置-&gt;modify-&gt;log-&gt;save…<br>  填写log，文件所在目录，文件名</li></ul><ul><li>代码日志:<br>  在打开的设置页面进行设置：选择你需要输出日志的服务，然后点击logs，保存到本地（注意一定要先把这个日志输出的文件创建出来，不然你会看不到你的日志）</li></ul></li><li><p>Lombok</p></li><li><p>tomcat中文乱码<br> 打开tomcat的&#x2F;conf&#x2F;server.xml</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> <span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p> 打开tomcat的\conf\logging.properties</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">java.util.logging.ConsoleHandler.Level=FINE<br>java.util.logging.ConsoleHandler.formatter=org.apache.juli.OnLLineFormatter<br>java.util.logging.ConsoleHandler.encoding=GBK<br></code></pre></td></tr></table></figure></li><li><p>Maven Helper帮助依赖</p></li><li><p>阿里的仓库:D:\Program Files\JetBrains\IntelliJ IDEA 2021.3.3\plugins\maven\lib\maven3\conf\setting.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>aliyunmaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿里云公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li></ol><ul><li>maven-search 快速查找依赖</li></ul><h2 id="SSM整体架构"><a href="#SSM整体架构" class="headerlink" title="SSM整体架构"></a>SSM整体架构</h2><p>任务:完成RESTful5接口 post,put,get,delete<br>流程:</p><ol><li>建立和连接sql</li><li>建立工程结构<ul><li>使用easy code-&gt;controller,dao,entity,service.mapper.xml</li><li>easycode的spring-data模式不生产mapper.xml，而且内置了CRUD实现</li></ul></li><li>添加依赖<ul><li><code>&lt;packaging&gt;war&lt;/packaging&gt;</code></li><li>可配合maven-search更多查找</li><li>主要依赖:<ul><li>mybatis:mybatis,mybatis-spring</li><li>mysql:mysql-connector-java,druid</li><li>spring&#x2F;springmvc:spring-webmvc,spring-jdbc</li><li>servlet&#x2F;jsp:javax.servlet-api,jsp-api</li><li>json:jackson-databind,fastjson</li><li>lombok:lombok</li><li>log4j:log4j,commons-logging</li><li>测试:spring-test,junit</li></ul></li></ul><ol start="4"><li>配置tomcat</li><li>更改为注解开发</li><li>填充业务逻辑</li></ol></li></ol><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><blockquote><p>导入sql:<br>mysql -uroot -p mybatis &lt; 路径<br>导出sql:<br>mysqldump -uroot -p mybatis &gt; 路径</p></blockquote><h3 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h3><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li>无法解析 org.springframework:spring:5.3.15 清理损坏的工件数据（.lastUpdated 文件）并重新加载项目。<br>解决:<br>更改setting.xml,修改maven路径<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml.">&lt;!-- localRepository<br>| The path to the local repository maven will use to store artifacts.<br>|<br>| Default: $&#123;user.home&#125;/.m2/repository<br>–&gt;<br>&lt;localRepository&gt;D:\maven&lt;/localRepository&gt;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>在config搜索maven进行配置tomcat</p></blockquote><ul><li><p>No goals have been specified for this build. You must specify a valid lifecycle phase or a goal in the format <plugin-prefix>:<goal> or <plugin-group-id>:<plugin-artifact-id>[:<plugin-version>]:<goal>.</p><ul><li><pre><code class="hljs">添加build`&lt;defaultGoal&gt;compile&lt;/defaultGoal&gt;`</code></pre></li></ul></li><li><p>Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!</p><ul><li>pom的properties:<code>&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</code></li></ul></li><li><ul><li>添加依赖  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.plexus<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>plexus-utils<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.plexus<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>plexus-interpolation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.shared<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-filtering<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean wit</p><ul><li>核心配置类<code>@mapperscan</code></li></ul></li><li><p>Failed to load class”org.slf4j.impl.StaticLoggerBinder”.</p><ul><li>添加slf4j-simple依赖</li></ul></li><li><p>HTTP状态 404 - 未找到</p></li><li><p>org.thymeleaf.exceptions.TemplateInputException: Error resolving template</p><ul><li>删除target目录</li></ul></li><li><p>中文乱码</p><ul><li>tomcat的logging.properties<ul><li>&#96;&#96;&#96;shell<br>  java.util.logging.ConsoleHandler.level &#x3D; FINE<br>  java.util.logging.ConsoleHandler.formatter &#x3D;java.util.logging.SimpleFormatter<br>  java.util.logging.ConsoleHandler.encoding &#x3D; GBK  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- <br><br><br><br><br><br><br><br>### junit<br>### 日期<br><br>###  日志<br>```<span class="hljs-type">xml</span><br>&lt;dependency&gt;  <br>&lt;groupId&gt;org.slf4j&lt;/groupId&gt;  <br>&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;  <br>&lt;<span class="hljs-keyword">version</span>&gt;<span class="hljs-number">2.0</span><span class="hljs-number">.3</span>&lt;/<span class="hljs-keyword">version</span>&gt;  <br>&lt;/dependency&gt;<br>```  <br>然后在resources下增加 log4j.properties文件，内容如下  <br>```shell<br>#将等级为<span class="hljs-keyword">DEBUG</span>的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码<br>log4j.rootLogger=<span class="hljs-keyword">DEBUG</span>,console,file<br><br>#控制台输出的相关设置<br>log4j.appender.console = org.apache.log4j.ConsoleAppender<br>log4j.appender.console.Target = <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span><br>log4j.appender.console.Threshold=<span class="hljs-keyword">DEBUG</span><br>log4j.appender.console.layout = org.apache.log4j.PatternLayout<br>log4j.appender.console.layout.ConversionPattern=[%c]-%m%n<br><br>#文件输出的相关设置<br>log4j.appender.file = org.apache.log4j.RollingFileAppender<br>log4j.appender.file.File=./<span class="hljs-keyword">log</span>/logFile.<span class="hljs-keyword">log</span><br>log4j.appender.file.MaxFileSize=<span class="hljs-number">10</span>mb<br>log4j.appender.file.Threshold=<span class="hljs-keyword">DEBUG</span><br>log4j.appender.file.layout=org.apache.log4j.PatternLayout<br>log4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n<br><br>#日志输出级别<br>log4j.logger.org.mybatis=<span class="hljs-keyword">DEBUG</span><br>log4j.logger.java.<span class="hljs-keyword">sql</span>=<span class="hljs-keyword">DEBUG</span><br>log4j.logger.java.<span class="hljs-keyword">sql</span>.<span class="hljs-keyword">Statement</span>=<span class="hljs-keyword">DEBUG</span><br>log4j.logger.java.<span class="hljs-keyword">sql</span>.ResultSet=<span class="hljs-keyword">DEBUG</span><br>log4j.logger.java.<span class="hljs-keyword">sql</span>.PreparedStatement=<span class="hljs-keyword">DEBUG</span><br><br></code></pre></td></tr></table></figure>在类中:<code>static final Logger log= LoggerFactory.getLogger(UserController.class);</code><br>在方法中调用:<code>log.info(&quot;获取全部user&quot;);</code></li></ul></li></ul></li></ul><hr><p><a href="https://so.gushiwen.cn/shiwenv_6a23fa2dab40.aspx"><strong>劝学</strong></a></p><p><a href="https://so.gushiwen.cn/authorv.aspx?name=%E9%A2%9C%E7%9C%9F%E5%8D%BF">颜真卿</a><a href="https://so.gushiwen.cn/shiwens/default.aspx?cstr=%E5%94%90%E4%BB%A3">〔唐代〕</a></p><p>三更灯火五更鸡，正是男儿读书时。<br>黑发不知勤学早，白首方悔读书迟。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c#学习</title>
      <link href="/2022/11/06/skill/csharp/"/>
      <url>/2022/11/06/skill/csharp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/8f43d3cb984565983b69724a9a4f1917.jpg"><br>行路难·其一<br>[李白]<br>金樽清酒斗十千，玉盘珍羞直万钱。<br>停杯投箸不能食，拔剑四顾心茫然。<br>欲渡黄河冰塞川，将登太行雪满山。<br>闲来垂钓碧溪上，忽复乘舟梦日边。<br>行路难，行路难，多歧路，今安在？<br>长风破浪会有时，直挂云帆济沧海<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/c%23%E5%9F%BA%E7%A1%80.png" alt="知识结构"><br><a href="https://www.zhixi.com/view/2d765ec3">详情地址</a></p><hr><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>移动设备、游戏主机、Web应用、物联网、微服务以及桌面应用.</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello,World"></a>Hello,World</h2><p>C#从C和C++继承了基本的语法<br>文件名不用匹配类名<br>vscode,linqpad,vs2022</p><h3 id="dotnet-CLI"><a href="#dotnet-CLI" class="headerlink" title="dotnet CLI"></a>dotnet CLI</h3><p>dotnet.exe是dotnet命令行接口（或称dotnet CLI)</p><ul><li>使用<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir ./HelloWorld<br>cd ./HelloWorld<br>dotnet new console<br></code></pre></td></tr></table></figure>会创建默认Programs.cs<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dotnet run<br></code></pre></td></tr></table></figure></li><li>编译<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">donet build <br></code></pre></td></tr></table></figure>生成dll文件在.&#x2F;bing&#x2F;Debug&#x2F;xxx&#x2F;里</li><li>发布可执行文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dotnet public -runtime<br></code></pre></td></tr></table></figure></li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>编译器根据关键字的固有语法来解释程序员写的表达式.<br>在HelloWorld程序中，class、static和void均是关键字。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668641936821.png"><br>*这些是上下文关键字，括号中的数字（n）代表加入该上下文关键字的C#版本。</p><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>标识程序员编码的构造。<br>HelloWorld和Main均为标识符。<br><a href="https://learn.microsoft.com/zh-cn/dotnet/standard/design-guidelines/">标识符设计框架准则</a></p><ul><li>可以<code>@</code>前缀关键字为标识符</li></ul><h3 id="定义类型"><a href="#定义类型" class="headerlink" title="定义类型"></a>定义类型</h3><ul><li>类定义 class 标识符{…}<ul><li>要用名词或名词短语命名类。</li><li>要为所有类名使用PascalCase大小写风格</li></ul></li></ul><h3 id="Main方法"><a href="#Main方法" class="headerlink" title="Main方法"></a>Main方法</h3><p>C#方法是已命名代码块.提供了结构化和组织代码的一种方式，使之更易读。更重要的是，方法可以重用.</p><p>C#程序从Main方法开始执行。该方法以static void Main()开头。</p><p>Main返回的int是状态码.非0意味着错误.</p><p>Main方法支持<code>async/await</code></p><h3 id="语句和分隔符"><a href="#语句和分隔符" class="headerlink" title="语句和分隔符"></a>语句和分隔符</h3><p>代码块本身就被视为语句.</p><p>允许一条语句跨越多行，根据<code>;</code>判断结束位置</p><h3 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h3><p>分号使C#编译器能忽略代码中的空白</p><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>声明局部变量。变量声明后可以赋值，可将值替换成新值，并可在计算和输出等操作中使用。但变量一经声明，数据类型就不能改变。</p><blockquote><p>声明局部变量。变量声明后可以赋值，可将值替换成新值，并可在计算和输出等操作中使用。但变量一经声明，数据类型就不能改变。</p></blockquote><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型（或对象类型）是具有相似特征和行为的个体的分类。</p><ul><li><code>string</code></li><li><code>int</code>32位整型</li><li><code>char</code>字符</li></ul><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>局部变量使用驼峰法命名.</p><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>C#要求局部变量在读取前“明确赋值”。</p><p>此外，赋值作为一种操作会返回一个值。</p><blockquote><p>所有string类型的数据，不管是不是字符串字面值,都是不可变的.只能重新赋值</p></blockquote><h3 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h3><h2 id="控制台输入和输出"><a href="#控制台输入和输出" class="headerlink" title="控制台输入和输出"></a>控制台输入和输出</h2><ul><li><code>System.Console.ReadLine()</code><ul><li><code>System.Console.Read()</code>返回的是整数</li><li><code>System.Console.ReadKey()</code>单次输入</li></ul></li><li><code>System.Console.WriteLine()</code><ul><li><code>System.Console.Write()</code></li></ul></li></ul><blockquote><p>字符串插值功能<code>$&quot;xxx&#123;Name&#125;xxx&quot;</code></p><p>字符串复合格式化<code>&quot;xxx&#123;0&#125;xx&#123;1&#125;,Name,Age&quot;</code></p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li>单行注释<code>//</code></li><li>多行注释<code>/**/</code><ul><li>还能插入语句中</li></ul></li><li>XML注释</li></ul><blockquote><p>写注释来重复代码本来就讲得清的事情，只会使代码变得臃肿并降低可读性，还容易过时，因为将来代码可能更改了但注释却没有来得及更新。</p><p>没有注释但可读性好的代码，比需要注释才能说清楚的代码更有价值</p><p>不要使用注释，除非代码本身“一言难尽”。要尽量写清楚的代码而不是通过注释澄清复杂的算法。</p></blockquote><h2 id="托管执行和CLI"><a href="#托管执行和CLI" class="headerlink" title="托管执行和CLI"></a>托管执行和CLI</h2><p>处理器不能直接解释程序集。程序集用的是另一种语言，即公共中间语言IL&#x2F;CIL</p><p>C#编译器将C#源代码文件转换成中间语言。为了将CIL代码转换成处理器能理解的机器码，还要完成一个额外的步骤（通常在运行时进行）。</p><p>该步骤涉及C#程序执行的一个重要元素：VES(虚拟执行系统)运行时.它根据需要编译CIL代码，这个过程称为即时编译或JIT编译.这种代理方式就是托管代码</p><p>运行时管理着诸如内存分配、安全性和JIT编译等方面，从而控制了主要的程序行为。</p><blockquote><p>执行时”表示“程序执行的时候”</p><p>用“运行时”表示负责管理C#程序执行的代理</p></blockquote><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p>Common Language Infrastructure，公共语言基础结构.</p><p>是一个规范:</p><ul><li>运行时</li><li>CIL</li><li>支持语言互操作性的类型系统，称为CTS</li><li>编写通过CLI兼容语言访问的库的指导原则</li><li>使各种服务能被CLI识别的元数据（包括程序集的布局或文件格式规范）</li></ul><p>通过复合规范就可以使用服务:语言互操作，类型安全，代码访问安全性，垃圾回收，平台可移植，BCL(基类库)</p><blockquote><p>ILDASM反汇编</p></blockquote><h2 id="多个-NET框架"><a href="#多个-NET框架" class="headerlink" title="多个.NET框架"></a>多个.NET框架</h2><ul><li><p>.NET Core</p></li><li><p>Xamarin</p></li><li><p>Unity</p></li></ul><p>API:应用编程接口，定义软件和其他组件交互方式.</p><p>.NET框架”一词指代.NET Core或Microsoft .NET Framework的所有程序集公开的API。API通常包含一组接口和协议（或指令），帮助你使用一系列组件进行编程。</p><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>预定义类型(基元类型),几种类型非常简单，是其他所有类型的基础.</p><ul><li>八种整数</li><li>两种浮点数</li><li>一种十进制浮点数</li><li>一种布尔</li><li>一种字符类型</li></ul><p>基元数据类型的完整名称提供了短名称,建议使用短名称</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668675357118.png"></p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>将浮点变量设为0.1，很容易表示成0.099999 999 999 999 999或者0.100 000 000 000000 000 1</p><p>浮点数精度由有效数位的个数决定.double型浮点数可以表示的有效数字最多为17位，float型为最多9位</p><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668675382293.png"></p><blockquote><p>采用二进制浮点数来存储数值.用十进制和二进制所表示的实数都存在舍入误差问题.</p><blockquote><p>99.9的二进制表示：1100011.111001100110011001100110011001100110011001101。现在我们需要将小数点左移6位，对应的指数值为+6。此时小数点右侧的位数为51位，这些将会被存放在尾数部分，如果使用double类型可以将数据全部记录，但是如果使用float类型，由于尾数部分只有23位，所有只能记录部分的数据，误差也就产生了！整理一下，符号位为0，指数部分为6+127&#x3D;133，尾数部分直接丢进去，能装多少装多少，以float为例。最终表示为：0 10000101 10001111100110011001100  </p></blockquote></blockquote><h3 id="decimal"><a href="#decimal" class="headerlink" title="decimal"></a>decimal</h3><p>128位精度的十进制浮点类型</p><p>decimal类型保证范围内的所有十进制数都是精确的。而不是近似值.</p><p>范围小，速度慢，但是精确.</p><blockquote><p>内部是使用科学计数法来存储</p></blockquote><h3 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h3><p>表示源代码中的固定值。如<code>12,12.5,&#39;x&#39;,&quot;abc&quot;&#39;</code></p><blockquote><p>直接将值放到源代码中称为硬编码.难维护</p><p>可以考虑从一个外部来源获取值，比如从一个配置文件中。这样以后需要修改值的时候，就不需要重新编译代码了。</p></blockquote><p>可以使用<code>F</code>和<code>D</code>作为后缀，将字面值分别显式声明为float或者double.<code>U</code>-&gt;uint,ulong.<code>L</code>-&gt;long,ulong</p><ul><li>数字分隔符<code>_</code></li><li>指数计数法<code>E</code>中缀</li><li>十六进制<code>0x</code>前缀</li><li>二进制<code>0b</code>前缀</li></ul><blockquote><p>数字格式化16进制:<code>$&quot;0x&#123;42:X&#125;&quot;</code></p></blockquote><blockquote><p>round-trip格式来防止丢弃最后文本<code>string.Format(&quot;&#123;0:R&#125;</code></p></blockquote><h2 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h2><p>条件语句和表达式中表示真或假,值为<code>true/false</code></p><p>bool实际大小是一个字节</p><h2 id="char"><a href="#char" class="headerlink" title="char"></a>char</h2><p>字符类型char表示16位字符,表示Unicode字符集，注意取值范围不是0~65535</p><p>转义序列:</p><ul><li><code>\n</code></li><li><code>\\</code></li><li><code>\t</code></li><li><code>\b</code></li><li><code>\&#39;</code> <code>\&quot;</code></li><li><code>\0</code>null</li></ul><p>使用<code>\uxxx</code>表示16位Unicode字符</p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>零或多个字符的<strong>不可变</strong>有限序列</p><p><code>@</code>前缀取消转义(“”除外)</p><p>插值是<code>string.Format()</code>的语法糖</p><p>常见方法:</p><ul><li>静态方法<ul><li>Format()</li><li>Concat()</li><li>Compare()默认区分大小写，第三个参数<code>true</code>不区分</li></ul></li><li>实例方法<ul><li>StatWith(),EndWith()</li><li>ToLower(),ToUpper()</li><li>Trim()</li><li>Replace()</li></ul></li></ul><blockquote><p>using static指令避免使用类名,可以直接使用静态方法</p></blockquote><p>格式化:组合格式化</p><p>长度:Length</p><blockquote><p>可变字符串:<code>System.Text.StringBuilder</code></p></blockquote><h3 id="null和void"><a href="#null和void" class="headerlink" title="null和void"></a>null和void</h3><ul><li><p>null值表明变量不引用任何有效的对象</p><ul><li>可做文本表示未知。<ul><li><code>&quot;&quot;</code>表示空白内容</li></ul></li></ul><blockquote><ul><li>可空修饰符<code>?</code>，声明变量名称后，使值类型也可以为空.<ul><li>可空引用类型:当这一概念被启用时，将没有可空修饰符的变量设置为null将会产生警告信息。启用“可空引用类型”的概念<code>#nullable enable</code><ul><li><code>string?homeNumber=null;</code>方可使用</li></ul></li></ul></li></ul><p></p></blockquote></li><li><p>void表示无类型，或者没有任何值。</p></li></ul><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><ul><li><code>()</code></li></ul><blockquote><p>checked:将数据溢出引发异常，而不是二进制+1</p><p>unchecked阻止异常</p></blockquote><p>不能数值型到bool的转换</p><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>int-&gt;long不会丢失数据，而且不会抛出异常都可以隐式转换</p><h3 id="Parse和Convert"><a href="#Parse和Convert" class="headerlink" title="Parse和Convert"></a>Parse和Convert</h3><p>每个数值数据类型都包含一个Parse()方法，允许将字符串转换成对应的数值类型</p><p>System.Convert只支持少量类型，且不可扩展</p><blockquote><p>TryParse()返回false代替抛出异常.</p></blockquote><h1 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>一个类型要么是值类型，要么是引用类型。区别在于拷贝方式：值类型的数据总是拷贝值；而引用类型的数据总是拷贝引用</p><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>值类型直接包含值，变量引用的位置就是内存中实际存储值的位置</p><p>除了string,所有的预定义类型都是值类型.</p><p>复制时，修改其中任何一个值都不会影响另一个值.</p><blockquote><p>由于值类型需要创建内存拷贝，因此定义时不要让它们占用太多内存（通常应该小于16字节）</p></blockquote><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>变量存储对数据存储位置的引用，而不是直接存储数据.</p><p>运行时”要先从变量中读取内存位置，再“跳转”到包含数据的内存位置。(解引用)</p><p>为引用类型的变量分配实际数据的内存区域称为堆</p><p>拷贝的是对数据的引用.</p><h2 id="可空变量"><a href="#可空变量" class="headerlink" title="可空变量"></a>可空变量</h2><ul><li>对于值类型:int? number&#x3D;null将声明一个可空的int型变量，并将其值初始化为null<ul><li>在实际中，当我们调用一个值类型变量的方法或者访问其属性时，仍然认为是在对该值类型变量进行解引用<blockquote><p>对可空值类型的操作实际是对<code>Nullable&lt;T&gt;</code></p></blockquote></li></ul></li><li>对于引用类型则会出现空引用异常<ul><li>启用引用类型的可空性特性:<code>#nullable enable</code>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta">#nullable enable</span><br><span class="hljs-built_in">string</span>? str=<span class="hljs-literal">null</span>;<br>Console.WriteLine(str?.Length);<br></code></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>空检查:.<br>方式1:is判断<br>方式2:<strong>null值条件操作符</strong><code>?.</code></p></blockquote><h2 id="隐式类型的局部变量"><a href="#隐式类型的局部变量" class="headerlink" title="隐式类型的局部变量"></a>隐式类型的局部变量</h2><p><code>var</code>无需显式声明变量的数据类型，由编译器推断</p><blockquote><p>匿名类型:在方法内部动态声明的数据类型，而不是通过显式的类定义来声明<br>    <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> v=<span class="hljs-keyword">new</span>&#123;Age=<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><br>但自从C# 7.0引入元组语法后，匿名类型几乎就用不着了。</p></blockquote><h2 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h2><p>合并数据元素。<br>允许在一条语句中完成对所有变量的赋值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">(<span class="hljs-built_in">string</span> country,<span class="hljs-built_in">double</span> gdp) t=(<span class="hljs-string">&quot;China&quot;</span>,<span class="hljs-number">249310E8</span>);<br></code></pre></td></tr></table></figure><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668677224639.png" alt="元组语法"><br>左侧仍然是单独的变量，只是用元组语法一起赋值.虽然右侧的值合并成元组，但在向左侧赋值的过程中，元组已被解构为它的组成部分.使用的是元祖语法，而不是元祖。</p><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668677243397.png" alt="元组"><br>左侧声明一个元组，将右侧的元组赋给它。注意元组含具名项，随后可引用这些名称来获取右侧元组中的值。这正是能在System.Console.WriteLine语句中使用countryInfo.Name、countryInfo.Capital和countryInfo.GdpPerCapita语法的原因。在左侧声明元组造成多个变量组合到单个元组变量（countryInfo）中</p><blockquote><p>要为元组语法的变量声明使用camelCase大小写规范。</br>考虑为所有元组项名称使用PascalCase大小写风格。</p></blockquote><p>元组是在对象中封装数据的轻量级方案</p><p>元组项数量也是在编译时硬编码好的。最后，不能为元组添加自定义行为（扩展方法不在此列）<br>如果需要和封装数据关联的行为，则应使用面向对象编程并定义一个类</p><blockquote><p>底层实现:<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668677798083.png"><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668677818702.png"></p></blockquote><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>可在单个变量中存储同一种类型的多个数据项。使用从零开始的索引进行单独访问数据。固定长度，在声明时确定(可在运行时)。</p><p>index from end:<code>^1</code>将访问数组中最后一个元素</p><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668678006063.png"><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668678026733.png"></p><p>分配数组但不指定初始值，“运行时”会将每个数组元素初始化为它们的默认值</p><p><code>^</code>操作符后面不局限于使用字面量数字，也可以使用任何返回正整数的表达式</p><ul><li><code>Length</code>属性</li></ul><blockquote><p>访问数组之前应当检查数组变量是否为null，而不应该假设数组变量总是指向一个有效的数组。<br>访问数组时，应当从Length属性获得数组长度，而不应该使用假设的长度。<br>应当用^1来访问末尾元素，而不必再使用Length-1</p></blockquote><p><code>System.Index</code>和<code>System.Range</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">System.Index index=^<span class="hljs-number">42</span>;<span class="hljs-comment">//Value和IsFromEnd属性</span><br>System.Range range=..^<span class="hljs-number">0</span>;<span class="hljs-comment">//index类型的Start和End属性</span><br>range=..;<br></code></pre></td></tr></table></figure><p>常用静态方法<code>Array</code>:<code>Sort() BinarySearch()/*先排序在查找*/ Reverse() Clear()/*不是删除元素或Length设为0，而是把元素设为默认值*/</code></p><p>实例方法:<code>GetLength() Rank/*维数*/ Clone()/*浅克隆*/</code></p><blockquote><p>大多数程序现在都用泛型集合类型而非数组来存储数据集合</p></blockquote><h3 id="字符串作为数组"><a href="#字符串作为数组" class="headerlink" title="字符串作为数组"></a>字符串作为数组</h3><p>访问string类型的变量类似于访问字符数组</p><p>由于字符串不可变，所以不能向字符串中的特定位置赋值</p><ul><li><code>ToCharArray()</code></li></ul><h1 id="操作符和流程控制"><a href="#操作符和流程控制" class="headerlink" title="操作符和流程控制"></a>操作符和流程控制</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="一元正负操作符"><a href="#一元正负操作符" class="headerlink" title="一元正负操作符"></a>一元正负操作符</h3><h3 id="二元算数操作符"><a href="#二元算数操作符" class="headerlink" title="二元算数操作符"></a>二元算数操作符</h3><ul><li>&#96;+-*&#x2F; %</li><li><code>()</code></li></ul><blockquote><p>避免将二进制浮点类型用于相等性条件式。要么判断两个值之差是否在容差范围之内，要么使用decimal类型</p></blockquote><h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><ul><li><code>+= -=</code></li></ul><h3 id="递增递减操作符"><a href="#递增递减操作符" class="headerlink" title="递增递减操作符"></a>递增递减操作符</h3><ul><li><code>++ --</code><br>在前先运算，在后先赋值</li></ul><h3 id="常量表达式"><a href="#常量表达式" class="headerlink" title="常量表达式"></a>常量表达式</h3><p>常量表达式是C#编译器能在编译时求值的表达式（而不是在运行时才能求值）因为其完全由常量操作数构成</p><blockquote><p>不要用常量表示将来可能改变的任何值。π和金原子的质子数是常量。金价、公司名和程序版本号则应该是变量</p></blockquote><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668838771522.png"><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668838804383.png"></p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><ul><li>if</li><li>嵌套if</li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><blockquote><p>除非是最简单的单行if语句，否则避免省略大括号</p></blockquote><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>具名事物的作用域是源代码的一个区域。可在该区域使用非限定名称（前面不加限定前缀的名称）引用该事物。局部变量的作用域就是封闭它的代码块</p><h2 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h2><p>if语句中包含在圆括号内的部分是布尔表达式，称为条件</p><h3 id="关系操作符和相等操作符"><a href="#关系操作符和相等操作符" class="headerlink" title="关系操作符和相等操作符"></a>关系操作符和相等操作符</h3><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668839059108.png"></p><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p><code>&amp;&amp; || !</code>短路效应</p><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p><code>?:</code></p><blockquote><p>考虑使用if&#x2F;else语句而不是过于复杂的条件表达式</p></blockquote><h2 id="null编程"><a href="#null编程" class="headerlink" title="null编程"></a>null编程</h2><h3 id="检查null值"><a href="#检查null值" class="headerlink" title="检查null值"></a>检查null值</h3><ul><li><code>==</code></li><li><code>ReferenceEquals()</code></li><li><code>is null</code> 比较好用</li><li><code>is&#123;&#125;</code></li></ul><h3 id="空合并操作符"><a href="#空合并操作符" class="headerlink" title="空合并操作符"></a>空合并操作符</h3><ul><li><code>??</code>空则使用另一个值。支持短路。</li></ul><h3 id="空条件操作符"><a href="#空条件操作符" class="headerlink" title="空条件操作符"></a>空条件操作符</h3><ul><li><code>?</code>不空才访问<ul><li><code>?.</code></li><li><code>?[]</code><blockquote><p>用于委托更优雅</p></blockquote></li></ul></li></ul><h3 id="空包容操作符"><a href="#空包容操作符" class="headerlink" title="空包容操作符"></a>空包容操作符</h3><p><code>!</code>该操作符告诉编译器程序员可以保证某个变量一定不为null值，从而在编译时，编译器会相信程序员的保证而不再产生警告信息。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">uri=<span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&#x27;/&#x27;</span>,segments!);<br></code></pre></td></tr></table></figure><p>由于Join()方法要求第二个参数不为空，因此如果直接将未赋值的可空型变量segments作为参数，则会产生编译器警告。在C# 8.0中可以使用空包容操作符(!)来避免该警告。</p><h2 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符"></a>按位操作符</h2><ul><li><code>&gt;&gt; &lt;&lt;</code>位移</li><li>&#96;&amp; | ^逻辑</li><li><code>~</code>求反</li></ul><blockquote><p>虽然传说x &lt;&lt; 2比x*4快，但不要将移位操作符用于乘除法,现代微处理器都对算术运算进行了完美的优化</p></blockquote><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p>控制流程语句在运行时求值条件表达式</p><h3 id="while和do-while"><a href="#while和do-while" class="headerlink" title="while和do-while"></a>while和do-while</h3><p>常见于死循环</p><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>有一套内建的语法规定了如何初始化、递增以及测试一个计数器的值。该计数器称为循环变量。由于循环语法中专门有一个位置是为递增&#x2F;递减操作保留的，所以递增&#x2F;递减操作符经常作为for循环的一部分使用。</p><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>foreach循环的特点是每一项只迭代一次：不会像其他循环那样出现计数错误，也不可能越过集合边界</p><p>foreach循环期间禁止修改循环变量</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>将一个值和多个常量值比较时，switch比if语句更易理解</p><blockquote><p>不要使用continue作为跳转语句退出switch小节。尽管switch在循环中时这样写合法，但很容易对之后的switch小节中出现的break产生困惑</p></blockquote><ul><li>任何小节的switch语句会产生编译器警告，但语句仍能通过编译</li><li>各小节可为任意顺序，default小节不一定要出现在switch语句最后，甚至可以省略</li><li>要求每个switch小节（包括最后一个小节）的结束点“不可到达”。这意味着switch小节通常以break、return、throw或goto结尾</li></ul><h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><ul><li>break</li><li>continue</li><li>goto<blockquote><p>避免使用goto</p></blockquote></li></ul><h2 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h2><p>处理器在编译时调用。预处理器指令告诉C#编译器要编译哪些代码，并指出如何处理代码中的特定错误和警告。C#预处理器指令还可告诉C#编译器有关代码组织的信<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668840622931.png"></p><blockquote><p>编译器选项生成define<code>dotnet.exe -definr:CSHA Test.cs</code></p></blockquote><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEST</span><br><span class="hljs-meta"># <span class="hljs-keyword">if</span> TEST</span><br>...<br><span class="hljs-meta"># <span class="hljs-keyword">elif</span> NOT TEST</span><br>...<br><span class="hljs-meta"># <span class="hljs-keyword">else</span></span><br>...<br><span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="启用可空"><a href="#启用可空" class="headerlink" title="启用可空"></a>启用可空</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta">#nullable enable</span><br><span class="hljs-meta">#nullable disable//关闭</span><br><span class="hljs-meta">#nullable restore//将可空引用类型的可用状态恢复为整个工程的全局设置状态</span><br></code></pre></td></tr></table></figure><h1 id="方法和参数"><a href="#方法和参数" class="headerlink" title="方法和参数"></a>方法和参数</h1><p>随着程序变得越来越复杂，需要新的思维模式来管理这种复杂性。“过程式”或“结构化”编程的基本思路就是提供对语句分组来构成单元的构造。此外，可通过结构化编程将数据传给一个语句分组，在这些语句执行完毕后返回结果<br>方法组合一系列语句以执行特定操作或计算特定结果。它能为构成程序的语句提供更好的结构和组织。</p><blockquote><p>要为方法名使用动词或动词短语</p></blockquote><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>一个类中的所有方法都必须有唯一签名，C#依据方法名、参数数据类型或参数数量的差异来定义唯一性。</p><h3 id="命名空间。"><a href="#命名空间。" class="headerlink" title="命名空间。"></a>命名空间。</h3><p>命名空间是一种分类机制，用于分组功能相关的所有类型。</p><p>命名空间主要用于按功能领域组织类型，以便查找和理解这些类型。此外，命名空间还有助于防范类型名称冲突</p><h3 id="类型名称"><a href="#类型名称" class="headerlink" title="类型名称"></a>类型名称</h3><p>调用静态方法时，不需要类型名称，是因为编译器能够根据调用位置推断类型。显然，如果编译器无法进行这样的推断，就必须将类型名称作为方法调用的一部分</p><p>类型本质上是对方法及其相关数据进行分组的一种方式</p><h3 id="方法名称"><a href="#方法名称" class="headerlink" title="方法名称"></a>方法名称</h3><p>每个方法调用都要指定一个方法名称。如前所述，它可能用也可能不用命名空间和类型名称加以限定。方法名称之后是圆括号中的实参列表，每个实参以逗号分隔，对应于声明方法时指定的形参。</p><h3 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h3><p>方法可获取任意数量的形参，每个形参都具有特定的数据类型。调用者为形参提供的值称为实参，每个实参都要和一个形参对应。</p><h3 id="方法返回值"><a href="#方法返回值" class="headerlink" title="方法返回值"></a>方法返回值</h3><p>void或者数据类型</p><h2 id="方法的声明"><a href="#方法的声明" class="headerlink" title="方法的声明"></a>方法的声明</h2><blockquote><p>将一组语句转移到一个方法中，而不是把它们留在一个较大的方法中，这是一种重构形式</p></blockquote><h3 id="参数声明"><a href="#参数声明" class="headerlink" title="参数声明"></a>参数声明</h3><p>可在方法声明的圆括号中添加参数列表</p><p>列表中的每个参数都包含参数类型和参数名称，每个参数以逗号分隔</p><h3 id="方法返回类型声明"><a href="#方法返回类型声明" class="headerlink" title="方法返回类型声明"></a>方法返回类型声明</h3><ul><li>return<ul><li>返回元祖类型.多个值可通过C#元组语法打包成元组返回</li></ul></li></ul><blockquote><p>虽然C#允许提前返回，但为了增强代码的可读性，并使代码更易维护，应尽量确定单一的退出位置，而不是在方法的多个代码路径中散布多个return语句。</p></blockquote><ul><li>指定void作为返回类型表示该方法没有返回值。所以，这种方法不支持向变量赋值，也无法在调用位置作为参数传递。void调用只能作为语句使用.可选的return</li></ul><h3 id="表达式主体方法"><a href="#表达式主体方法" class="headerlink" title="表达式主体方法"></a>表达式主体方法</h3><p>用表达式代替完整方法主体</p><p>表达式主体方法不是用大括号定义方法主体，而是用&#x3D;&gt;操作符</p><p>虽然没有显式的return语句，但表达式本身的返回类型必须与方法声明的返回类型匹配</p><h2 id="using指令"><a href="#using指令" class="headerlink" title="using指令"></a>using指令</h2><ul><li>显示导入命名空间</li><li><code>using static</code>，使用静态方法</li><li>嵌套:在命名空间内部使用</li><li>别名:<code>using T=Test</code></li></ul><h2 id="Main-的返回值和参数"><a href="#Main-的返回值和参数" class="headerlink" title="Main()的返回值和参数"></a>Main()的返回值和参数</h2><p>假如一个程序的两个类都有Main()方法，可以选取其中一个类作为程序的入口点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dotnet build /p:StartupObject=Test.Program<br></code></pre></td></tr></table></figure><h2 id="高级方法参数"><a href="#高级方法参数" class="headerlink" title="高级方法参数"></a>高级方法参数</h2><h3 id="值参数"><a href="#值参数" class="headerlink" title="值参数"></a>值参数</h3><p>参数默认采用传值方式。换言之，参数值会拷贝到目标参数中。</p><p>调用栈在一次调用的末尾“展开”的时候，拷贝的数据会被丢弃。</p><blockquote><p>如<strong>引用类型的变量</strong>以传值方式传给方法，拷贝的就是引用（地址）本身。这样虽然在被调用的方法中还是更改不了引用（地址）本身，但可以更改地址处的数据。相反，对于<strong>值类型的参数</strong>，参数获得的是值的拷贝，所以被调用的方法怎么都改变不了调用者的变量。</p></blockquote><h3 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h3><p><code>ref</code>，这使参数以传引用的方式传递，被调用的方法可用新值更新调用者的变量</p><p>如果被调用的方法将参数指定为ref，调用者调用该方法时提供的实参应该是附加了ref前缀的变量</p><p>事实上，ref参数只是传递的变量的别名。换言之，引用参数的作用只是为现有变量分配参数名，而非创建新变量并将实参的值拷贝给它。</p><h3 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h3><p>方法经常要获取一个变量引用，并向变量写入而不读取。这时更安全的做法是以传引用的方式传入一个未初始化的局部变量</p><ul><li><code>out</code>参数功能上与ref参数完全一致.唯一区别是C#语言对别名变量的读写有不同的规定。如参数被标记为out，编译器会核实在方法所有正常返回的代码路径中，是否都对该参数进行了赋值<ul><li>调用时<code>_</code>放弃</li><li>返回两个或更多值应首选元组语法</li></ul></li></ul><h3 id="只读传引用"><a href="#只读传引用" class="headerlink" title="只读传引用"></a>只读传引用</h3><p><code>in</code>以传引用的方式传入只读值类型。该特性以传引用的方式传入值类型参数，并且让该参数不能被方法修改。这样不仅避免了每次调用方法都创建值类型的拷贝，而且不用担心值类型参数被修改</p><p>换言之，其作用是在传值时减少拷贝量，同时把它标识为只读，从而增强性能。该语法要为参数添加in修饰符</p><h3 id="返回引用"><a href="#返回引用" class="headerlink" title="返回引用"></a>返回引用</h3><ul><li><code>return ref xxx</code><ul><li>返回类型前加ref</li><li>变量引用返回值值时,双方前加ref</li></ul></li></ul><p>返回引用有两个重要的限制，两者都和对象生存期有关：</p><ol><li>对象仍被引用时不应被垃圾回收；</li><li>对象的所有引用都消失之后，不应再占用内存。</li></ol><p>为符合这些限制，从方法返回引用时只能返回：</p><ul><li>对字段或数组元素的引用</li><li>其他返回引用的属性或方法</li><li>作为参数传给“返回引用的方法”的引用</li></ul><p>ref局部变量被初始化为引用一个特定变量，以后不能修改为引用其他变量</p><ul><li>声明引用局部变量的同时必须初始化它。为此需要将方法返回的引用赋给它，或将一个变量引用赋给它</li><li>允许声明ref局部变量，但不允许声明ref字段</li><li>自动实现的属性不能声明为引用类型</li><li>允许返回引用的属性</li><li>引用局部变量不能用值（比如null或常量）来初始化.必须将返回引用的成员赋给它，或者将局部变量、字段或数组赋给它</li></ul><h3 id="参数数组"><a href="#参数数组" class="headerlink" title="参数数组"></a>参数数组</h3><p><code>params 数组参数</code>放在最后.</p><ul><li>参数数组是类型安全的——实参类型必须兼容参数数组的类型</li><li>调用者可传递一个实际的数组，而不是传递以逗号分隔的实参列表</li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>事实上，递归通常都是最简单的编码模式，尤其是在和文件系统这样的层次化数据打交道的时候。不过，虽然可读性不错，但一般不是最快的实现。如果必须关注性能，开发者应该为递归实现寻求一种替代方案。至于具体如何选择，通常取决于如何在可读性与性能之间取得平衡。</p><blockquote><p>栈溢出</p></blockquote><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>方法的唯一性取决于方法名、参数数据类型或参数数量的差异。</p><p>方法重载是一种操作性多态</p><p>重载就是同名不同参数数据类型或参数数量</p><p>假定有两个适用的方法，每个都要求将实参隐式转换成形参的类型，最终选择的是形参类型更具体（派生程度更大）的方法.如果有多个适用的方法，但无法从中挑选出最具唯一性的，编译器就会报错，指明调用存在歧义</p><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>方法声明时，在参数列表给参数赋默认值</p><blockquote><p>要尽量为所有参数提供好的默认值<br>要提供简单的方法重载，必需参数的数量要少<br>考虑从最简单到最复杂的组织重载</p></blockquote><h3 id="具名参数"><a href="#具名参数" class="headerlink" title="具名参数"></a>具名参数</h3><p>在方法调用时，指定参数赋值<code>age:18</code></p><h2 id="基本异常处理"><a href="#基本异常处理" class="headerlink" title="基本异常处理"></a>基本异常处理</h2><ul><li><code>try-catch-finally</code></li><li><code>throw</code></li></ul><blockquote><p>避免从finally块显式抛出异常（因方法调用而隐式抛出的异常可以接受）<br>要在抛出的异常中描述异常为什么发生。如果可能，顺带说明如何防范更佳<br>要在捕捉并重新抛出异常时使用空的throw语句，以便保留调用栈<br>不要让公共成员将异常作为返回值或者out参数。抛出异常来指明错误，不要把它们作为返回值来指明错误。</p></blockquote><p>避免使用异常处理来处理预料之中的情况<br><code>TryParse()</code></p><blockquote><p>不要用异常处理正常的、预期的情况，用它们处理异常的、非预期的情况</p></blockquote><h3 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h3><p>所有的异常都派生自此类.</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>面向对象编程中，之前学过的所有结构化的、基于控制流的编程构造仍然适用。但将那些构造封装在类中，可以创建更大、更有条理以及更容易维护的程序。从结构化的、基于控制流程的程序转向面向对象的程序，是因为面向对象编程提供了一个额外的组织层次。结果是较小的程序在某种程度上得到了简化。但更重要的是，现在更容易创建较大的程序，因为程序中的代码得到了更好的组织。</p><p>面向对象编程的一个关键优势是不必从头创建新程序，而是可以将现有的一系列对象组装到一起，用新功能扩展类，或添加更多的类</p><p>类是面向对象编程的三个主要特征——封装、继承和多态性——的基础。</p><ul><li>封装:1.将方法和数据装入对象 2.在隐藏细节。<ul><li>所有类成员（类的数据和方法）的一个分组，使它们不再需要单独处理</li><li>方法封装语句</li></ul></li><li>继承:允许在这些相似但又不同的物件之间建立“属于”（is a）关系。类层次结构<ul><li>更具体的类型称为派生类型或子类型。更常规的类型称为基类型或者超类型.子”毕竟不是一种“父”</li><li>继承最关键的一点是所有派生类型都继承了基类型的成员</li></ul></li><li>多态:一个方法或类型可具有多种形式的实现<ul><li>使不同类型能自己处理一个方法的实现细节，因为多个派生类型都包含了该方法，每个派生类型都共享同一个基类型（或接口），后者也包含了相同的方法签名。</li></ul></li></ul><h2 id="类的声明和实例化"><a href="#类的声明和实例化" class="headerlink" title="类的声明和实例化"></a>类的声明和实例化</h2><ul><li>声明类首先指定关键字class，后跟一个标识符</li></ul><p>该类的所有代码放到类声明之后的大括号中。虽然并非必须，但一般应该将每个类都放到它自己的文件中，用类名对文件进行命名。这样可以更容易地寻找定义了一个特定类的代码。</p><blockquote><p>不要在一个源代码文件中放多个类<br>要用所含公共类型的名称命名源代码文件</p></blockquote><ul><li>类和对象<ul><li>类是模板，定义了对象在实例化时看起来像什么样子</li><li>对象是类的实例</li><li>从类创建对象的过程称为实例化</li></ul></li><li>实例化:new关键字实例化对象<br>  -要用new操作符指示“运行时”为对象分配内存、初始化对象，并返回对实例的引用<ul><li>对象回收由GC自动完成</li></ul></li></ul><h2 id="实例字段"><a href="#实例字段" class="headerlink" title="实例字段"></a>实例字段</h2><p>在类中存储数据的变量称为成员变量,更成为字段，是与包容类型关联的具名存储单元.</p><p>实例字段是在类的级别上声明的变量，用于存储与对象（实例）关联的数据。</p><h3 id="声明实例字段"><a href="#声明实例字段" class="headerlink" title="声明实例字段"></a>声明实例字段</h3><p>和局部变量声明一样，字段声明包含字段所引用的数据类型。此外，还可在声明的.指示访问等级(默认私有)</p><h3 id="访问实例字段"><a href="#访问实例字段" class="headerlink" title="访问实例字段"></a>访问实例字段</h3><p>可设置和获取字段中的数据。注意字段不包含static修饰符，这意味着它是实例字段。</p><p>只能从其包容类的实例（对象）中访问实例字段，无法直接从类中访问（换言之，不创建实例就不能访问）。</p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>必须先获得类的实例才能调用实例成员——无论该实例成员是方法还是字段。</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>此关键字可在类的实例成员内部获取对该类的引用</p><p>关键字this显式指出当前访问的字段或方法是包容类的实例成员。调用任何实例成员时this都是隐含的，它返回</p><blockquote><p>this关键字只在必要时才应使用</p></blockquote><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>控制封装的访问级别</p><ul><li>public访问不受限制。接口方法默认</li><li>private访问限于包含类。类成员默认私有.</li><li>protected访问限于包含类或派生自包含类的类型</li><li>internal访问限于当前程序集。类默认</li><li>protected internal访问限于当前程序集或派生自包含类的类型。</li><li>private protected访问限于包含类或当前程序集中派生自包含类的类型</li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li>私有字段,公开属性</li></ul><p>属性的关键在于，它提供了从编程角度看类似于字段的API。但事实上并不存在这样的字段。</p><p>属性声明看起来和字段声明一样，但跟随在属性名之后的是一对大括号，要在其中添加属性的实现。</p><p>get和set</p><blockquote><p>一般原则是方法代表行动，而属性代表数据。属性旨在简化对简单数据的访问(只进行简单计算)。调用属性的成本不应比访问字段高出太多。</p></blockquote><blockquote><p>避免从属性取值方法抛出异常<br>要在属性抛出异常时保留原始属性值<br>如果不需要额外逻辑，要优先使用自动实现的属性，而不是属性加简单支持字段<br>无论私有字段使用哪一种命名方案，属性都要使用PascalCase大小写规范<br>为支持字段附加“_”前缀<br>要使用名词、名词短语或形容词命名属性<br>考虑让某个属性和它的类型同名<br>如果有意义的话，要为Boolean属性附加“Is”“Can”或“Has”前缀<br>要优先使用自动实现的属性而不是字段</p></blockquote><p>拦截赋值，并通过字段风格的API对参数进行验证，这是属性的优点之一。</p><p>一个好的实践是只从属性的实现中访问属性的支持字段。换言之，要一直使用属性，不要直接调用字段</p><h3 id="nameof"><a href="#nameof" class="headerlink" title="nameof"></a>nameof</h3><p>属性验证时如判断新赋值无效，就需要抛出ArgumentException()或Argument-NullException()类型的异常。两个异常都获取string类型的实参paramName来标识无效参数的名称</p><p>可用nameof操作符来改进。该操作符获取一个标识符（比如value变量）作为参数，返回该名称的字符串形式<code>nameof(value)</code></p><p>nameof操作符的优点在于，以后若标识符名称发生改变，重构工具能自动修改nameof的实参</p><h3 id="只读和只写属性"><a href="#只读和只写属性" class="headerlink" title="只读和只写属性"></a>只读和只写属性</h3><p>通过移除属性的取值方法或赋值方法，可以改变属性的可访问性。只有赋值方法的属性是只写属性，这种情况较罕见。类似地，只提供取值方法会得到只读属性，任何赋值企图都会造成编译错误。</p><h3 id="自动实现的属性"><a href="#自动实现的属性" class="headerlink" title="自动实现的属性"></a>自动实现的属性</h3><p>属性默认值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>[,,] Cells&#123;<span class="hljs-keyword">get</span>;&#125;=<span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><blockquote><p>如属性值不变，要创建只读自动实现</p></blockquote><h3 id="属性作为虚字段"><a href="#属性作为虚字段" class="headerlink" title="属性作为虚字段"></a>属性作为虚字段</h3><p>可以看出属性的行为与虚字段相似。有时甚至根本不需要支持字段.相反，可让属性的取值方法返回计算好的值，而让赋值方法解析值，并将值持久存储到其他成员字段中。</p><h3 id="属性和方法调用不允许作为ref或out参数值"><a href="#属性和方法调用不允许作为ref或out参数值" class="headerlink" title="属性和方法调用不允许作为ref或out参数值"></a>属性和方法调用不允许作为ref或out参数值</h3><p>C#允许属性像字段那样使用，只是不允许作为ref或out参数值传递。ref和out参数内部要将内存地址传给目标方法。但由于属性可能是无支持字段的虚字段，也有可能只读或只写，所以不可能传递存储地址。同样的道理也适用于方法调用。如需将属性或方法调用作为ref或out参数值传递，首先必须将值拷贝到变量再传递该变量。方法调用结束后，再将变量的值赋回属性。</p><h3 id="属性的内部工作原理"><a href="#属性的内部工作原理" class="headerlink" title="属性的内部工作原理"></a>属性的内部工作原理</h3><p>除了外观与普通方法无异，注意属性在CIL中也是一种显式的构造.因此，语言和编译器并非总是依据一个惯例来解释属性。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>数据的有效性,即使忘了初始化，有构造函数来警告</p><h3 id="声明构造函数"><a href="#声明构造函数" class="headerlink" title="声明构造函数"></a>声明构造函数</h3><p>声明构造函数需创建一个无返回类型的方法，方法名必须和类名完全一样。构造函数是“运行时”用来初始化对象实例的方法。</p><p>构造函数会覆盖声明字段&#x2F;属性的初始值</p><blockquote><p>new操作符的实现细节<br>new操作符内部和构造函数是像下面这样交互的。new操作符从内存管理器获取“空白”内存，调用指定构造函数，将对“空白”内存的引用作为隐式的this参数传给构造函数。构造函数链剩余的部分开始执行，在构造函数之间传递引用。这些构造函数都没有返回类型（行为都像是返回void）。构造函数链上的执行结束后，new操作符返回内存引用。现在，该引用指向的内存处于完成初始化的形式。</p></blockquote><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>如果类没有显式定义的构造函数，C#编译器会在编译时自动添加一个。该构造函数不获取参数，称为默认构造函数<br>一旦为类显式添加了构造函数，C#编译器就不再自动提供默认构造函数。</p><blockquote><p>没必要依赖编译器提供的默认构造函数。程序员任何时候都可显式定义默认构造函</p></blockquote><h3 id="对象初始化器"><a href="#对象初始化器" class="headerlink" title="对象初始化器"></a>对象初始化器</h3><p><code>&#123;&#125;</code>可访问字段和属性进行赋值</p><p>这实际只是一种语法糖，最终生成的CIL代码和创建对象实例后单独用语句对字段及属性进行赋值无异.<br>代码中的成员初始化顺序决定了在CIL中调用构造函数后的属性和字段赋值顺序</p><blockquote><p>要为所有属性提供有意义的默认值，确保默认值不会造成安全漏洞或造成代码执行效率大幅下降<br>要允许属性以任意顺序设置，即使这会造成对象暂时处于无效状态</p></blockquote><ul><li>集合初始化器<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668847210926.png"></li><li>终结器:终结器是在对象被判定“不可到达”之后的不确定时间内执行</li></ul><h3 id="重载构造函数"><a href="#重载构造函数" class="headerlink" title="重载构造函数"></a>重载构造函数</h3><blockquote><p>如果构造函数的参数只是用于设置属性，那么构造函数参数（camelCase）要使用和属性（PascalCase）相同的名称，区别仅仅是首字母的大小写<br>要为构造函数提供可选参数，并且提供便利的重载构造函数，用好的默认值初始化属性<br>要允许以任何顺序设置属性，即使这会导致暂时无效的对象状态</p></blockquote><h3 id="构造函数链"><a href="#构造函数链" class="headerlink" title="构造函数链"></a>构造函数链</h3><p>使用this调用另一个构造函数</p><blockquote><p>可设计个<code>Initialize()</code>集中初始化.获取全部的属性并赋值</p></blockquote><h2 id="不可空引用类型属性与构造函数"><a href="#不可空引用类型属性与构造函数" class="headerlink" title="不可空引用类型属性与构造函数"></a>不可空引用类型属性与构造函数</h2><p>在一个类中，如果定义了不可空引用类型的字段或者默认实现的属性，则在其宿主类完成实例化之前，这些字段和属性的值需要先被初始化，否则，它们只能拥有默认的null值，而这显然与“不可空”相悖。<br>有时候这类字段和属性可能已经被间接地初始化了，超出了构造函数的直接作用域，因此超出了编译器代码分析的作用域，即便通过构造函数调用的方法或属性能够初始化也是如此</p><p>在大部分情况下，不可空引用型字段和自动实现的不可空属性的初始化，都通过构造函数调用属性或方法间接完成。遗憾的是，C#编译器无法识别对不可空引用型字段或属性的间接赋值，即便该间接赋值发生在构造函数里</p><h3 id="可读写的引用型不可空属性"><a href="#可读写的引用型不可空属性" class="headerlink" title="可读写的引用型不可空属性"></a>可读写的引用型不可空属性</h3><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668847837700.png"><br>既使用可读写的引用型不可空属性，又避免产生不可空属性未初始化的编译器警告。这样做的最终效果是在编译器看来该属性&#x2F;字段为可空（因此不会产生警告），而在调用者看来该属性&#x2F;字段不允许被设置为空。</p><p>虽然将不应该为空的字段声明为可空看起来不太正确，但是由于编译器无法识别对不可空字段的间接赋值，因此有时确实需要这样做。好在程序员可以通过字段的私有性，以及精细设</p><h3 id="自动实现的只读引用型属性"><a href="#自动实现的只读引用型属性" class="headerlink" title="自动实现的只读引用型属性"></a>自动实现的只读引用型属性</h3><p>如果一个不可空的引用型字段有自动实现的属性，则该属性应该为只读，从而避免该字段被意外设置为null值。但是即便做到了这一点，在构造函数里为该字段进行赋值时，仍然需要检查null值<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668847978636.png"></p><blockquote><p>当类的不可空引用型字段需要对应的属性时，要将该字段声明为可空，并且要编写完整实现的属性方法，而不要采用自动实现的方式。在赋值方法中要做好null值检查，在取值方法中要使用空包容操作符。<br>不可空的引用型字段要在构造函数内完成赋值<br>如果一定要为不可空的引用型字段使用自动实现的属性，要将属性声明为只读<br>在操作任何引用型字段或属性时，都要检查null值</p></blockquote><h2 id="可空特性"><a href="#可空特性" class="headerlink" title="可空特性"></a>可空特性</h2><p>明确告诉编译器你需要处理空值，并需要为此添加一些防护措施，比笼统地关闭空值功能或者关闭空值警告更有意义<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668861767573.png"><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668861810817.png"></p><blockquote><p>可空泛型<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668861898144.png"></p></blockquote><h2 id="解构函数"><a href="#解构函数" class="headerlink" title="解构函数"></a>解构函数</h2><p>把一个对象封装好的项拆分为它的各个组成部分。</p><ul><li>方法名必须是Deconstruct，其签名是返回void并接收两个或更多out参数</li></ul><p>和元祖配合更优雅<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668862193683.png"><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668862160314.png"><br>也可将对象实例赋给元祖，隐式调用Deconstruct()，和out参数匹配</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">(_,firstName,lastName,salary)=employee;<br></code></pre></td></tr></table></figure><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p><code>static</code></p><h3 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h3><p>使用static关键字定义能由多个实例共享的数据</p><p>和实例字段（非静态字段）一样，静态字段也可在声明时初始化<br>和实例字段不同，未初始化的静态字段将获得默认值</p><p>每创建一个对象实例，非静态字段（实例字段）都要占用一个新的存储位置。静态字段从属于类而非实例。因此，我们使用类名从类外部访问静态字段。</p><blockquote><p>设计对象时，程序员要考虑字段和方法应声明为静态还是基于实例。一般应将不需要访问任何实例数据的方法声明为静态方法，将需要访问实例数据的方法（实例不作为参数传递）声明为实例方法。静态字段主要存储对应于类的数据，比如新实例的默认值或者已创建实例的个数。而实例字段主要存储和对象关联的数据。</p></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>和静态字段一样，直接在类名后访问静态方法</p><h3 id="静态构造方法"><a href="#静态构造方法" class="headerlink" title="静态构造方法"></a>静态构造方法</h3><p>“运行时”在首次访问类时自动调用静态构造函数。“首次访问类”可能发生在调用普通构造函数时，也可能发生在访问类的静态方法或字段时。由于静态构造函数不能显式调用，所以不允许任何参数。</p><p>静态构造函数的作用是将类中的静态数据初始化成特定值，尤其是在无法通过声明时的一次简单赋值来获得初始值的时候</p><blockquote><p>最好在声明时进行静态初始化（而不要使用静态构造函数）</p></blockquote><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>使用静态属性几乎肯定比使用公共静态字段好，因为公共静态字段在任何地方都能调用，而静态属性至少提供了一定程度的封装。</p><h3 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h3><p>该类不包含任何实例字段（或方法），创建能实例化的类没有意义</p><ol><li>它防止程序员写代码来实例化SimpleMath类。</li><li>防止在类的内部声明任何实例字段或方法</li><li>不可扩展</li></ol><h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><p>能模拟为其他类创建实例方法。</p><p>只需更改静态方法的签名，使第一个参数成为要扩展的类型，并在类型名称前附加this关键字</p><p>查看CIL代码，会发现扩展方法是作为普通静态方法调用的。</p><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668863172652.png"></p><blockquote><p>避免随便定义扩展方法，尤其是不要为自己无所有权的类型定义。</p></blockquote><h2 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const字段（称为常量字段）包含在编译时确定的值，运行时不可修改。</p><ul><li><p>自动成为静态字段.</p><ul><li>但将常量字段显式声明为static会造成编译错误</li><li>常量字段通常只声明为有字面值的类型<blockquote><p>要为永远不变的值使用常量字段<br>避免为将来会发生变化的值使用常量字段</p></blockquote></li></ul></li><li><p>public常量应该是恒定值.将来可能更改的值应该指定为readonly</p></li></ul><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>readonly修饰符只能用于字段（不能用于局部变量），它指出字段值只能从构造函数中更改，或在声明时通过初始化器指定。</p><p>由于readonly字段必须通过构造函数或初始化器来设置，所以编译器要求这种字段能从其属性外部访问。但除此之外，不要从属性外部访问属性的支持字段</p><blockquote><p>一般都是不用readonly字段，而是设为只读(无set)属性.<br>要优先选择只读自动实现的属性而不是只读字段</p></blockquote><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>假如一个类在它的包容类外部没有多大意义，就适合设计成嵌套类。</p><p>嵌套类的独特之处是可以为类自身指定private访问修饰符。.使用private访问修饰符可限定类的作用域，防止从类的外部访问。只有嵌套类才能这样做。</p><p>嵌套类另一个有趣的地方在于它能访问包容类的任何成员，其中包括私有成员。反之则不然，包容类不能访问嵌套类的私有成员。</p><blockquote><p>避免声明公共嵌套类型。少数高级自定义场景才需考虑</p></blockquote><h2 id="分部类"><a href="#分部类" class="headerlink" title="分部类"></a>分部类</h2><p>分部类是一个类的多个部分，编译器可把它们合并成一个完整的类。</p><ul><li><code>partial</code><br>除了用于代码生成器，分部类另一个常见的应用是将每个嵌套类都放到它们自己的文件中。</li></ul><h3 id="分部方法"><a href="#分部方法" class="headerlink" title="分部方法"></a>分部方法</h3><p>分部方法只能存在于分部类中，而且和分部类相似，主要作用是为代码生成提供方便。</p><p>分部方法允许声明方法而不需要实现。但如果包含了可选的实现，该实现就可放到某个姊妹分部类定义中，该定义可能在单独的文件中。</p><p>分部方法必须返回void。</p><p>分部方法使生成的代码能调用并非一定要实现的方法。此外，如果没有为分部方法提供实现，CIL中不会出现分部方法的任何踪迹。这样在保持代码规模尽量小的同时，还保证了高的灵活性。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>利用类的继承关系建立类层次结构。</p><p>单继承</p><h2 id="派生、"><a href="#派生、" class="headerlink" title="派生、"></a>派生、</h2><p>经常需要扩展现有类型来添加功能（行为和数据）。继承正是为了该目的而设计的。</p><p>所有类都隐式派生自object。</p><h3 id="转型"><a href="#转型" class="headerlink" title="转型"></a>转型</h3><ul><li><p>可以将派生类型的值直接赋给基类型的变量。隐式转型</p></li><li><p>类型转换为派生类型要求执行显式转型，而显式转型在运行时可能失败。</p></li><li><p>自定义转换: <code>ublic态 implicit operator 目标类(本类)&#123;&#125;</code></p><ul><li>将implicit替换成explicit就是显式转换</li></ul></li></ul><h3 id="private访问修饰符"><a href="#private访问修饰符" class="headerlink" title="private访问修饰符"></a>private访问修饰符</h3><p>派生类继承除构造函数和析构器之外的所有基类成员。但继承并不意味着一定能访问。</p><p>根据封装原则，派生类不能访问基类的private成员</p><h3 id="protected访问修饰符"><a href="#protected访问修饰符" class="headerlink" title="protected访问修饰符"></a>protected访问修饰符</h3><p>可在基类中定义只有派生类才能访问的成员</p><p>基类的受保护成员只能从基类及其派生链的其他类中访问。</p><h3 id="扩展方法-1"><a href="#扩展方法-1" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>扩展方法从技术上说不是类型的成员，所以不可继承。但因为每个派生类都可作为它的任何基类的实例使用，所以对一个类型进行扩展的方法也可扩展它的任何派生类型。</p><p>但和所有扩展方法一样，实例方法有更高的优先级。如果继承链中出现一个兼容的签名，那么它将优先于扩展方法。</p><h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p>为正确设计类，使其他人能通过派生来扩展功能，需对它进行全面测试，验证派生能成功进行.<br><code>seal</code>避免非预期的派生，并避免因此而出现的问题。</p><p>string类型就是用sealed修饰符禁止派生的例子。</p><h2 id="重写基类"><a href="#重写基类" class="headerlink" title="重写基类"></a>重写基类</h2><p>基类除构造函数和析构器之外的所有成员都会在派生类中继承。但某些情况下，一个成员可能在基类中没有得到最佳的实现。<br>因此，需要一种机制在派生类中使用自定义的实现来重写（override，覆盖或覆写）基类中的实现</p><h3 id="virtaul修饰符"><a href="#virtaul修饰符" class="headerlink" title="virtaul修饰符"></a>virtaul修饰符</h3><p>支持重写实例方法和属性，但不支持字段和任何静态成员的重写。</p><ul><li><code>override</code>进行重写。<ul><li>基类调用时调用实例的方法.<blockquote><p>用override修饰的任何方法自动为虚。只有基类的虚方法才能重写，所以重写后的方法还是虚方法。</p></blockquote></li></ul></li></ul><h3 id="new修饰符"><a href="#new修饰符" class="headerlink" title="new修饰符"></a>new修饰符</h3><p>如果重写方法没有使用override关键字，编译器会生成警告消息，可使用new修饰符.</p><p>它在基类面前隐藏了派生类重新声明的成员。搜索继承链，找到使用new修饰符的那个成员之前的、派生得最远的成员，然后调用该成员。如继承链仅包含两个类，就使用基类的成员，就像是派生类没有声明那个成员（如派生的实现重写了基类成员）。</p><h3 id="sealed修饰符"><a href="#sealed修饰符" class="headerlink" title="sealed修饰符"></a>sealed修饰符</h3><p>禁止子类重写基类的虚成员</p><blockquote><p>除非有很好的理由，一般很少将整个类标记为密封。事实上，人们越来越倾向于将类设置成非密封类，因为单元测试需要创建仿制对象来代替真正的实现。有时对单独虚成员进行密封的代价过高，还不如将整个类密封。但一般都倾向于对单独成员进行有针对性的密封（例如，可能需要依赖基类的实现来获得正确的行为）。</p></blockquote><h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><p>调用其基类版本的成员(包括构造方法)</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><code>abstract</code><br>抽象类是仅供派生的类，无法实例化抽象类，只能实例化从它派生的类。不抽象、可直接实例化的类称为具体类。</p><blockquote><p>接口（interface）已经实现了抽象类所拥有的全部功能，甚至还有更多新特性。</p></blockquote><p>抽象类代表抽象实体。其抽象成员定义了从抽象实体派生的对象应包含什么，但这种成员不包含实现。抽象类的大多数功能通常都没有实现。一个类要从抽象类成功地派生，必须为抽象基类中的抽象方法提供具体的实现。</p><p>抽象类的主要特点在于它包含抽象成员。抽象成员是没有实现的方法或属性，作用是强制所有派生类提供实现。</p><p>抽象成员不能声明为私有，否则派生类看不见它们。</p><ul><li><p>抽象成员必须被重写，所以自动为虚，但不能用virtual关键字显式声明。</p></li><li><p>多态性</p><ul><li>同一个签名可以有多个实现。<ul><li>一个签名不能在一个类中多次使用，所以该签名的每个实现必然包含在不同类中。</li></ul></li><li>只有对象自己才知道如何最好地执行特定操作，通过规定调用这些操作的通用方式，多态性还促进了代码重用，因为通用的东西不必重复编码。</li></ul></li></ul><h2 id="所有类都从System-Object派生"><a href="#所有类都从System-Object派生" class="headerlink" title="所有类都从System.Object派生"></a>所有类都从System.Object派生</h2><p>所有类都直接或间接从object派生。</p><p>即使字面值也支持object的方法</p><h2 id="使用is进行模式匹配"><a href="#使用is进行模式匹配" class="headerlink" title="使用is进行模式匹配"></a>使用is进行模式匹配</h2><p>C#用is操作符判断基础类型</p><p>is操作符除了用于类型检查，也可以用于声明变量并且赋值。</p><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668868466779.png"><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668868502811.png"></p><h3 id="元组模式匹配"><a href="#元组模式匹配" class="headerlink" title="元组模式匹配"></a>元组模式匹配</h3><p>可以将一批常量放在一个元组中，并使用is操作符进行元组模式匹配，并且也可以对元组中的变量进行类型模式匹配和赋值。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668868608466.png"></p><h3 id="顺序模式匹配"><a href="#顺序模式匹配" class="headerlink" title="顺序模式匹配"></a>顺序模式匹配</h3><p>由于解构函数可以隐含的构造一个元组实例，因此一个具有解构函数的类可以完美匹配元组模式匹配的语法。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668868691124.png"><br>在顺序模式匹配中，也可以匹配常量</p><h3 id="属性模式匹配"><a href="#属性模式匹配" class="headerlink" title="属性模式匹配"></a>属性模式匹配</h3><p>允许在对一个对象进行模式匹配时，不仅指定属性值，而且指定属性名称。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668868739604.png"><br>顺序不重要</p><h3 id="递归模式匹配"><a href="#递归模式匹配" class="headerlink" title="递归模式匹配"></a>递归模式匹配</h3><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668869367636.png"><br>is操作符的属性模式匹配的优势在于其可以用属性名来直接选取希望匹配的元素或字段</p><p>is操作符的属性模式匹配不支持判定性表达式</p><blockquote><p>读性也差</p></blockquote><h2 id="switch中的匹配模式"><a href="#switch中的匹配模式" class="headerlink" title="switch中的匹配模式"></a>switch中的匹配模式</h2><p>可读性更高的if<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668926790555.png"><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668926805959.png"></p><h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><p>将时间进一步限定为将来某时刻。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668926871291.png"></p><blockquote><p>避免对多态类对象使用模式匹配</p></blockquote><ul><li>使用as操作符进行转换，避免了可能因为转型而造成的异常</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口实现关系是一种“能做”（can do）关系：类型“能做”接口所规定的事情。</p><p>遵循的条款</p><p>能完全隔离实现细节和提供的服务.</p><p>接口声明的成员描述了在实现该接口的类型中必须能访问的成员。而所有非公共成员的目的都是阻止其他代码访问成员。所以，C#不允许为接口成员使用访问修饰符。所有成员都自动公共。</p><p>接口为多态性而生</p><h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><p>类可实现多个接口，但只能从一个基类直接派生</p><p>实现接口时，接口的所有抽象成员都必须实现。</p><p>在抽象类中可将接口方法映射成自己的抽象方法，将真正的实现留给子类去完成。也可拿掉abstract关键字并添加方法主体。</p><p>接口的重点在于永远不能实例化，即不能用new创建接口。因此接口没有构造函数或终结器。只有实例化实现了接口的类型，才能使用接口实例。</p><h3 id="显式成员实现"><a href="#显式成员实现" class="headerlink" title="显式成员实现"></a>显式成员实现</h3><p>显式实现的方法只能通过接口本身调用，最典型的做法是将对象转型为接口</p><p>在接口成员名称前附加接口名称前缀来显式实现接口成员<code>接口名.</code>。</p><p>由于显式接口实现直接和接口关联，所以没必要使用virtual、override或者public来修饰它们。事实上，这些修饰符是不被允许的。这些成员不被视为类的公共成员，标注public有误导之嫌。</p><blockquote><p>注意，在派生类中实现接口方法时，不允许使用override（重写）关键字。不过，在派生类中实现接口方法时，我们仍然会称之为“重写”。</p></blockquote><h3 id="隐式成员实现"><a href="#隐式成员实现" class="headerlink" title="隐式成员实现"></a>隐式成员实现</h3><p>要隐式实现成员，只要求成员是公共的，且签名与接口成员签名相符。</p><p>显式实现不允许的许多修饰符对于隐式实现都是必须或可选的</p><blockquote><p>类层次结构是建立在属于(is a)关系上，这些是“语义”（semantic）关系。<br>接口与语义无关，只在实现”机制”关系的细节。不属于”可比较”的机制,但仍可实现IComparable接口<br>显式接口实现的目的就是将机制问题和模型问题分开.要求调用者先将对象转换为接口（比如IComparable），然后才能认为对象“可比较”，从而显式区分你想在什么时候和模型沟通，以及在什么时候处理实现机制。</p></blockquote><blockquote><p>可通过回答以下问题来决定显式还是隐式实现：</p></blockquote><ol><li>成员是不是核心的类功能？</li><li>接口成员名称作为类成员名称是否恰当？避免歧义，方法名的功能不能显而易见</li><li>是否已经有相同签名的类成员？<br>因此较稳妥的做法是全部显式实现接口成员，使它们以后能安全地变成隐式。</li></ol><h2 id="接口和实现类的转换"><a href="#接口和实现类的转换" class="headerlink" title="接口和实现类的转换"></a>接口和实现类的转换</h2><p>实现类向接口隐式；<br>接口向实现类显式。</p><h2 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h2><p>一个接口可以从另一个接口派生，派生的接口将继承“基接口”的所有成员。</p><p>显式实现接口成员时，必须在完全限定的接口成员名称中引用最初声明它的接口的名称。</p><p>最后要说的是，虽然“继承”这个词用得没错，但更准确的说法是接口代表契约，一份契约可指定另一份契约也必须”遵守”的条款。</p><h2 id="接口上的扩展方法"><a href="#接口上的扩展方法" class="headerlink" title="接口上的扩展方法"></a>接口上的扩展方法</h2><p>扩展方法的一个重要特点是除了能作用于类，还能作用于接口。所使用的语法和用于类时的语法一样。</p><h2 id="版本升级"><a href="#版本升级" class="headerlink" title="版本升级"></a>版本升级</h2><p>和类不同，在接口中添加成员也可能造成代码无法编译——除非进行额外的修改。问题在于，实现接口的任何类都必须完整地实现，必须提供针对所有成员的实现。添加新接口成员后，编译器会要求开发者在实现接口的类中添加新的接口成员。</p><p>C# 8.0允许在接口中为方法提供默认实现。这样一来，虽然仍然不可以在已经发布的接口中修改或删除现有的方法，但是可以添加新方法，并通过提供默认实现，来避免破坏基于该接口开发的现有程序。</p><blockquote><p>不要为已发布的接口添加成员，除非提供默认实现。</p></blockquote><h3 id="默认接口方法"><a href="#默认接口方法" class="headerlink" title="默认接口方法"></a>默认接口方法</h3><p>许为现有接口增加新方法时，同时提供默认实现代码</p><p>没有影响之前的多态性</p><h3 id="接口其他新特性"><a href="#接口其他新特性" class="headerlink" title="接口其他新特性"></a>接口其他新特性</h3><p>可声明</p><ul><li>静态成员:字段，构造函数，方法，甚至包括Main方法</li><li>实例属性和方法:不支持实例字段所以没有自动实现<ul><li>访问默认接口属性或方法，必须将变量转换为接口</li></ul></li><li>public修饰符，更清晰</li><li>protected修饰符</li><li>private修饰符。接口成员为私有时(如果是方法需要有默认实现)只能从默认方法访问</li><li>internal</li><li>protected internal</li><li>private protected</li><li>virtual修饰符，更清晰</li><li>sealed修饰符,方法不可被重写</li><li>abstract修饰符，只能用于没有默认实现的接口方法，能用但是没啥用</li><li>partial接口和方法。方法均自动私有访问</li></ul><ol><li>如果希望提供属性存取方法的默认接口实现，则不可以使用编译器自动实现。这是因为接口中不允许声明实例字段（非静态字段），因此编译器无法找到对应的字段来自动实现属性存取方法。</li><li>请注意静态成员和实例成员（非静态成员）的默认访问权限不同。静态成员默认为私有访问，而实例成员则默认为公共访问，这是因为接口中的静态方法必须有默认实现，而静态字段也有相应的实体，这样它们就与普通类中的静态方法和字段非常接近。而类中的静态成员就默认为私有访问，因此接口中的静态成员在访问权限上也与类保持一致。与之对应，接口实例成员（方法和属性）的主要用途是为了实现多态，因此其默认访问权限也要尽量接近C# 8.0之前的一贯风格。</li></ol><h2 id="扩展方法与默认接口成员"><a href="#扩展方法与默认接口成员" class="headerlink" title="扩展方法与默认接口成员"></a>扩展方法与默认接口成员</h2><ul><li>这些方法都可以实现基于相同方法签名的重写</li><li>扩展方法可以在任何程序集里面实现，并不局限于接口所在的程序集。</li><li>虽然允许为属性的存取添加默认接口方法，但由于接口中不允许添加实例字段，因此如果属性的存取方法需要实现复杂一些的计算，则无法在默认接口方法中实现</li><li>也可以利用扩展方法为字段实现类似于属性的“存取方法”（如GetData()），以便在其中实现复杂一些的计算。这样就不必局限于C# 8.0和.NET Core 3.0框架了。</li><li>从旧接口派生出新接口，便可以在其中自由地添加新功能。这样既不用担心向上兼容问题，也不用局限于新版本的C#和.NET框架。</li><li>派生出新接口的方法需要通过修改实现类来实现新接口。</li><li>默认接口方法需要通过该接口来调用，而不能通过接口的实现类的实例来调用[1]。即便在接口的实现类中，若要调用默认接口方法，也必须通过接口来调用。</li><li>接口中的protected成员只能被当前接口及其派生接口访问，实现类并不能访问这种成员。</li><li>默认接口方法可以被实现类重写，这使得不同的实现类可以为特定方法提供不同的实现。然而扩展方法不能够被类重写，对它的调用在编译时就已经确定了。</li></ul><p>总之，当要添加新的属性方法时，如果需要支持比C# 8.0和.NET Core 3.0更早期的框架，则派生新接口是唯一选择，否则可以考虑利用默认接口方法来添加新属性。而如果只是要添加新方法而不是属性，则也可以考虑扩展方法。</p><blockquote><p>若需对已经发布的接口添加新方法，优先考虑扩展方法或者派生新接口<br>如果无法控制接口所允许的多态性，则采用扩展方法更加稳妥<br>如果要添加新的属性方法，而且既要支持多态性，又要支持早期C#和.NET，则只能派生新接口。</p></blockquote><h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><p>接口引入了另一个类别的数据类型（是少数不扩展System.Object的类型之一）<br>    - 此外还有指针类型和类型参数类型。但每个接口类型都可转换为System.Object，并允许在接口的任何实例上调用System.Object的方法，所以这个区别或许有点儿吹毛求疵。</p><p>C# 8.0的接口几乎成为抽象类的功能超集。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668931300122.png"></p><blockquote><p>如果一个类已经有父类，若要再为它添加父类，考虑定义接口</p></blockquote><h2 id="接口和特性"><a href="#接口和特性" class="headerlink" title="接口和特性"></a>接口和特性</h2><p>有时用无任何成员的接口（不管是不是继承的）来描述关于类型的信息。例如，有人会创建名为IObsolete的标记接口（marker interface）指出某类型已被另一类型取代。</p><p>一般认为这是对接口机制的“滥用”：接口应表示类型能执行的功能，而非陈述关于类型的事实。所以这时不要使用标记接口，改为使用特性</p><blockquote><p>避免使用无成员的标记接口，改为使用特性</p></blockquote><h1 id="值类型-1"><a href="#值类型-1" class="headerlink" title="值类型"></a>值类型</h1><blockquote><p>避免创建消耗内存大于16字节的值类型</p></blockquote><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><code>struct</code><br>除string和object是引用类型，其他所有C#内建类型（比如bool和int）都是值类型。</p><p>可<code>readonly</code>本身和成员</p><blockquote><p>要创建不可变的值类型（元组例外）</p></blockquote><h3 id="初始化结构"><a href="#初始化结构" class="headerlink" title="初始化结构"></a>初始化结构</h3><p>除了属性和字段，结构还可包含方法和构造函数，但不可包含用户自定义的默认（无参）构造函数。<br>相反，C#编译器自动生成默认构造函数将所有字段初始化为默认值。</p><p>结构中的每个构造函数都必须初始化结构的所有字段（和只读自动实现属性）</p><p>如果不用new操作符来调用构造函数从而显式实例化结构，结构中的所有数据都隐式初始化为对应数据类型的默认值。<br>为满足结构初始化要求，所有显式声明的字段都必须初始化。这种初始化必须直接进行。</p><ul><li>在结构声明中初始化字段会报错，需要在构造函数中初始化</li></ul><blockquote><p>要确保结构的默认值有效。封装并不能阻止访问默认的“全零”值。</p></blockquote><ul><li>为引用类型使用new操作符，“运行时”会在托管堆上创建对象的新实例，将所有字段初始化为默认值，再调用构造函数，将对实例的引用以this的形式传递。new操作符最后返回对实例的引用，该引用被拷贝到和变量关联的内存位置。</li><li>为值类型使用new操作符，“运行时”会在临时存储池中创建对象的新实例，将所有字段初始化为默认值，调用构造函数，将临时存储位置作为ref变量以this的形式传递。结果是值被存储到临时存储位置，然后可将该值拷贝到和变量关联的内存位置。</li></ul><h3 id="继承和接口"><a href="#继承和接口" class="headerlink" title="继承和接口"></a>继承和接口</h3><p>所有值类型都隐式密封。派生自System.ValueType</p><p>值类型也能实现接口。</p><blockquote><p>如需比较相等性，要在值类型上重写相等性操作符（Equals()，&#x3D;&#x3D;和!&#x3D;）并考虑实现IEquatable<T>接口。</p></blockquote><h2 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h2><p>值类型的变量（直接引用其数据）转换为引用类型（引用堆上的一个位置）</p><p>对一个存储位置的引用。该位置表面上包含引用类型的实例，但实际包含值类型的值。这种转换称为装箱</p><ol><li>堆上分配内存.它将用于存放值类型的数据以及少许额外开销（SyncBlockIndex和方法表指针）</li><li>拷贝内存数据</li><li>转换结果是对堆上的新存储位置的引用</li></ol><p>相反的过程称为拆箱（unboxing）。具体是核实已装箱值的类型兼容于要拆箱成的值的类型，再拷贝堆中存储的值，结果是堆上存储的值的拷贝。</p><blockquote><p>装箱和拆箱都影响性能和行为,频繁需避免</p></blockquote><ul><li>lock语句中的值类型<br>值类型的问题在于装箱，所以每次调用Enter()或Exit()都会在堆上创建新值。将一个拷贝的引用同另一个拷贝的引用比较总是返回false。所以，无法将Enter()与对应的Exit()钩到一起。因此，不允许在lock()语句中使用值类型。</li></ul><blockquote><p>避免可变值类型.因为往往修改的是值的拷贝，而不是真正想要修改的存储位置。</p></blockquote><ul><li>方法调用上避免装箱:<br>任何时候在值类型上调用方法，接收调用的值类型（在方法主体中用this表示）必须是变量而不是值，因为方法可能尝试修改接收者。显然，它必须修改接收者的存储位置，而不是修改接收者的值的拷贝再丢弃该拷贝。</li></ul><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><code>enum</code><br>关键特征是在编译时声明了一组具名常量值，这使代码更易读。</p><p>枚举值实际作为整数常量实现。默认第一个枚举值是0，后续每一项都递增1。但可以显式地为枚举赋值</p><p>枚举总是具有一个基础类型，可以是除char之外的任意整型。</p><p>枚举不过是基础类型上的一组名称，对于枚举类型的变量，它的值并不限于声明中命名的值。优点在于可在未来的API版本中为枚举添加新值，同时不会破坏早期版本。</p><blockquote><p>考虑在现有枚举中添加新成员，但要注意兼容性风险。<br>避免创建代表“不完整”值（如版本号）集合的枚举。<br>避免在枚举中创建“保留给将来使用”的值。<br>避免包含单个值的枚举。<br>要为简单枚举提供值0来代表无。注意若不显式初始化，0就是默认值。</p></blockquote><h3 id="枚举之间的类型兼容性"><a href="#枚举之间的类型兼容性" class="headerlink" title="枚举之间的类型兼容性"></a>枚举之间的类型兼容性</h3><p>C#不支持不同枚举数组之间的直接转型。但CLR允许，前提是两个枚举具有相同的基础类型。为避开C#的限制，技巧是先转型为System.Array</p><p>慎用</p><h3 id="在枚举和字符串之间转换"><a href="#在枚举和字符串之间转换" class="headerlink" title="在枚举和字符串之间转换"></a>在枚举和字符串之间转换</h3><p>枚举的一个好处是ToString()方法（通过System.Console.WriteLine()这样的方法来调用）会输出枚举值标识符</p><p>使用<code>Enum.TryParse&lt;T&gt;()</code>将字符串转换成枚举</p><h3 id="枚举作为标志使用"><a href="#枚举作为标志使用" class="headerlink" title="枚举作为标志使用"></a>枚举作为标志使用</h3><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668940984249.png"><br>然后使用<code>&amp; | ! ^</code>等位操作</p><blockquote><p>要用FlagsAttribute标记包含标志的枚举<br>要为所有标志枚举提供等于0的None值<br>避免将标志枚举中的零值设定为“所有标志都未设置”之外的其他意思。<br>考虑为常用标志组合提供特殊值<br>不要包含“哨兵”值（如Maximum），这种值会使用户困惑<br>要用2的乘方确保所有标志组合都不重复。</p></blockquote><ul><li>FlagsAttribute<br>如决定使用位标志枚举，枚举的声明应该用FlagsAttribute来标记。该特性应包含在一对方括号中，并放在枚举声明之前<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668941268855.png">该特性指出枚举值可以组合。</li></ul><h1 id="合式类型"><a href="#合式类型" class="headerlink" title="合式类型"></a>合式类型</h1><p>本章将讨论如何完善类型定义</p><h2 id="重写object的成员"><a href="#重写object的成员" class="headerlink" title="重写object的成员"></a>重写object的成员</h2><h3 id="ToString"><a href="#ToString" class="headerlink" title="ToString()"></a>ToString()</h3><p>在对象上调用ToString()默认返回类的完全限定名称</p><blockquote><p>如需返回有用的、面向开发者的诊断字符串，就要重写ToString()。<br>考虑尽量使ToString()返回的字符串简短。<br>不要从ToString()返回空字符串来代表“空”（null）。<br>不要从ToString()抛出异常或造成可观察到的副作用（改变对象状态）。<br>如果返回值与语言文化相关或要求格式化（例如DateTime），就要重载ToString (string format)或实现IFormattable。<br>考虑从ToString()返回独一无二的字符串以标识对象实例</p></blockquote><h3 id="GetHashCode"><a href="#GetHashCode" class="headerlink" title="GetHashCode()"></a>GetHashCode()</h3><p>底线是重写Equals()就要重写GetHashCode()，否则编译器会显示警告</p><p>哈希码（hash code）作用是生成和对象值对应的数字，从而高效地平衡哈希表</p><p>·必须：相等的对象必然有相等的哈希码（若a.Equals(b)，则a.GetHashCode()&#x3D;&#x3D;b.GetHashCode()）<br>必须：在特定对象的生存期内，即使对象的数据发生了改变，GetHashCode()也应始终返回相同的值。通常可以将对象的哈希码保存在某个恰当的位置（后文将简称为“缓存”），并让GetHashCode()返回缓存值，从而确保其返回值不变。但是，不要通过对比哈希码来判断两个对象是否相等，因为数据相等的两个对象可能有不相等的哈希码，反之，数据不相等的两个对象，也可能有相等的哈希码。<br>必须：GetHashCode()不应引发任何异常；GetHashCode()总是成功返回一个值。<br>性能：哈希码应尽可能唯一。但由于哈希码只是返回一个int，所以只要一种对象包含的值比一个int能够容纳得多（这就几乎涵盖所有类型了），那么哈希码肯定存在重复。一个很容易想到的例子是long，因为long的取值范围大于int，所以假如规定每个int值都只能标识一个不同的long值，那么肯定剩下大量long值没法标识。<br>性能：可能的哈希码值应当在int的范围内平均分布。例如，创建哈希码时如果没有考虑到字符串在拉丁语言中的分布主要集中在初始的128个ASCII字符上，就会造成字符串值的分布非常不平均，所以不能算是好的GetHashCode()算法。<br>性能：GetHashCode()的性能应该优化。GetHashCode()通常在Equals()实现中用于“短路”一次完整的相等性比较（哈希码都不同，自然没必要进行完整的相等性比较了）。所以，当类型作为字典集合中的键类型使用时，会频繁调用该方法<br>性能：两个对象的细微差异应造成哈希值的极大差异。理想情况下，1位的差异应造成哈希码平均16位的差异。这有助于确保不管哈希表如何对哈希值进行“装桶”（bucketing），也能保持良好的平衡性<br>安全性：攻击者应难以伪造具有特定哈希码的对象。攻击手法是向哈希表中填写大量哈希为同一个值的数据。然后，哈希表的实现会变得效率低下，导致DOS（拒绝服务）攻击。</p><p>当然，许多原则是相互对立的。很难有一种哈希算法既快又满足所有这些要求。和任何设计问题一样，好的解决方案必然是综合考虑的结果。</p><ul><li>System.HashCode的Combine()方法获得对象哈希码</li></ul><h4 id="Equals"><a href="#Equals" class="headerlink" title="Equals()"></a>Equals()</h4><ol><li>对象同一性和相等的对象值<br> 针对引用来说.<blockquote><p>为值类型调用ReferenceEquals()总是返回false</p></blockquote></li><li>实现Equals()<br> 两个对象要相等，其标识数据（identifying data）必须相等<blockquote><p>object.Equals()的实现只是简单调用了一下ReferenceEquals()</p></blockquote></li></ol><blockquote><p>要一起实现GetHashCode()、Equals()、&#x3D;&#x3D;操作符和!&#x3D;操作符，缺一不可<br>要用相同算法实现Equals()、&#x3D;&#x3D;和!&#x3D;。<br>避免在可变引用类型上重载相等性操作符（如重载的实现速度过慢，也不要重载）。<br>要在实现IEquitable时实现与相等性相关的所有方法</p></blockquote><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951426905.png"><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951469783.png"><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951481621.png"></p><h3 id="用元组重写GetHashCode-和Equals"><a href="#用元组重写GetHashCode-和Equals" class="headerlink" title="用元组重写GetHashCode()和Equals()"></a>用元组重写GetHashCode()和Equals()</h3><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951532360.png"><br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951558334.png"></p><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><p>除x.y、f(x)、new、typeof、default、checked、unchecked、delegate、is、as、&#x3D;和&#x3D;&gt;之外，其他所有操作符都支持</p><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951727721.png"></p><blockquote><p>避免在&#x3D;&#x3D;操作符的重载实现中使用该操作符</p></blockquote><blockquote><p>从技术上说，实现显式和隐式转换操作符并不是重载转型操作符（()）。但由于效果一样，所以一般都将“实现显式或隐式转换”说成“定义转型操作符”。<br>定义转换操作符在形式上类似于定义其他操作符，只是“operator”成了转换的结果类型。另外，operator要放在表示隐式或显式转换的implicit或explicit关键字后面<br>不要为有损转换提供隐式转换操作符<br>不要从隐式转换中抛出异常</p></blockquote><h2 id="引用其他程序集"><a href="#引用其他程序集" class="headerlink" title="引用其他程序集"></a>引用其他程序集</h2><p>不需要将所有代码都放到单独一个二进制文件中，C#和底层CLI框架允许将代码分散到多个程序集中。这样就可在多个可执行文件中重用程序集</p><ul><li>类库dll  开发者可将程序的不同部分转移到单独的编译单元中，这些单元称为类库(classlib)</li></ul><h3 id="引用类库"><a href="#引用类库" class="headerlink" title="引用类库"></a>引用类库</h3><ul><li>引用库项目文件（*.csproj），指出库的源代码在哪个项目中，并在两个项目之间建立依赖关系</li><li>引用程序集文件本身。换言之，引用编译好的库（*.dll）而不是项目。如果库和程序分开编译，比如由企业内的另一个团队编译，这种方式就非常合理。</li><li>引用NuGet包</li></ul><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668951980039.png"></p><h3 id="NuGet打包"><a href="#NuGet打包" class="headerlink" title="NuGet打包"></a>NuGet打包</h3><p>NuGet不仅包含一个清单来标识作者、公司、依赖项等，还在NuGet.org提供了一个默认包提供者以便上传、更新、索引和下载包</p><p>可在项目中引用一个NuGet包（*.nupkg），从你事先配置好的NuGet提供者URL处自动安装。NuGet包提供了一个清单文件（*.nuspec），其中列出了包中所含的所有附加元数据。还提供了你可能想要的所有附加资源，包括本地化文件、配置文件、内容文件等等。最后，NuGet包将所有单独的资源合并成单个ZIP文件（虽然使用.nupkg扩展名）。所以，用*.zip扩展名重命名文件，就可用任何常规压缩工具打开并检查文件内容。</p><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668952069186.png"></p><h2 id="类型封装"><a href="#类型封装" class="headerlink" title="类型封装"></a>类型封装</h2><p>类封装行为和数据，而程序集封装一组类型。开发者可将一个系统分解成多个程序集，在多个应用程序之间共享，或将它们与第三方提供的程序集集成。</p><p>不添加任何访问修饰符的类或结构体会被默认声明为内部访问（等同于使用关键字internal来声明），而嵌套类型（即声明在类中的类）则默认被声明为私有访问。</p><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668952176122.png"></p><h2 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h2><p>namespace<br>组织所有类型，用命名空间对它们进行逻辑分组</p><blockquote><p>不要使用容易变化的名称（组织层次结构、短期品牌等）<br>要为命名空间附加公司名前缀，防止不同公司使用同一个名称<br>要为命名空间二级名称使用稳定的、不随版本升级而变化的产品名称<br>不要定义没有明确放到一个命名空间中的类型<br>考虑创建和命名空间层次结构匹配的文件夹结构</p></blockquote><blockquote><p>CLR中没有“命名空间”这种东西。类型名称必然完全限定</p></blockquote><h2 id="XML注释"><a href="#XML注释" class="headerlink" title="XML注释"></a>XML注释</h2><p>这种提示能为大型应用程序的开发提供重要帮助，尤其是多个开发者需要共享代码的时候</p><p>由于XML注释旨在提供API文档，所以一般只和C#声明配合使用</p><blockquote><p>如果签名不能完全说明问题，要为公共API提供XML文档，其中包括成员说明、参数说明和API调用示例。</p></blockquote><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收是“运行时”的核心功能，旨在回收不再被引用的对象所占用的内存<br>    垃圾回收器只回收内存，不处理其他资源，比如数据库连接、句柄（文件、窗口等）、网络端口以及硬件设备（比如串口</p><h3 id="NET中的垃圾回收"><a href="#NET中的垃圾回收" class="headerlink" title=".NET中的垃圾回收"></a>.NET中的垃圾回收</h3><p>.NET的垃圾回收器采用mark-and-compact算法[1]。一次垃圾回收周期开始时，它识别对象的所有根引用。根引用是来自静态变量、CPU寄存器以及局部变量或参数实例（以及本节稍后会讲到的f-reachable对象）的任何引用。基于该列表，垃圾回收器可遍历每个根引用所标识的树形结构，并递归确定所有根引用指向的对象。这样，垃圾回收器就可识别出所有可达对象。<br>执行垃圾回收时，垃圾回收器不是枚举所有访问不到的对象；相反，它将所有可达对象紧挨着放到一起，从而覆盖不可访问的对象（也就是垃圾，或者不可达对象）<br>为定位和移动所有可达对象，系统要在垃圾回收器运行期间维持状态的一致性。为此，进程中的所有托管线程都会在垃圾回收期间暂停。这显然会造成应用程序出现短暂的停顿。不过，除非某次垃圾回收耗时特别长或者垃圾回收过于频繁，否则这个停顿是不太引人注意的。为尽量避免在不恰当的时间执行垃圾回收，System.GC对象包含一个Collect()方法。可在执行关键代码之前调用它（执行这些代码时不希望GC运行）。这样做不会阻止垃圾回收器运行，但会显著减小它运行的可能性——前提是关键代码执行期间不会发生内存被大量消耗的情况。<br>.NET垃圾回收的特别之处在于，并非所有垃圾都一定会在一个垃圾回收周期中清除。研究对象的生存期会发现：相较于长期存在的对象，最近创建的对象更有可能需要垃圾回收。为此，.NET垃圾回收器支持“代”（generation）的概念，它会以更快的频率尝试清除生存时间较短的对象（新生对象）。而那些已在一次垃圾回收中“存活”下来的对象（老对象）会以较低的频率清除。具体地说，共有3代对象。一个对象每次在一个垃圾回收周期中存活下来，它都会移动到下一代，直至最终移动到第二代（从第零代开始）。相较于第二代对象，垃圾回收器会以更快的频率对第零代的对象执行垃圾回收。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用不阻止对对象进行垃圾回收，但会维持一个引用。这样，对象在被垃圾回收器清除之前可以重用。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953179806.png"></p><h2 id="资源清理"><a href="#资源清理" class="headerlink" title="资源清理"></a>资源清理</h2><p>垃圾回收是“运行时”的重要职责。但要注意，垃圾回收旨在提高内存利用率，而非清理文件句柄、数据库连接字符串、端口或其他有限的资源。</p><h3 id="终结器"><a href="#终结器" class="headerlink" title="终结器"></a>终结器</h3><p>类名之前<code>~</code><br>允许程序员写代码来清理类的资源，无法显式调用.负责释放像数据库连接和文件句柄这样的资源，这些资源需通过一次显式的行动来进行清理，而垃圾回收器不知道具体如何采取这些行动。</p><p>唯一确定的是终结器会在对象最后一次使用之后，并“通常”在应用程序正常关闭前的某个时间运行。这里“通常”一词是为了强调事实上终结器有可能不会被调用。尤其当程序被强行关闭时。例如，计算机关机，或者程序被调试器强行终止，终结器都很有可能不会被调用。</p><h3 id="使用using语句进行确定性终结"><a href="#使用using语句进行确定性终结" class="headerlink" title="使用using语句进行确定性终结"></a>使用using语句进行确定性终结</h3><ul><li><p>IDisposable接口用名为Dispose()<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953458810.png"><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953473415.png"><br>即使开发者忘记显式调用Close()，终结器也会调用它。虽然终结器运行得会晚一些（相较于显式调用Close()），但该方法肯定会得到调用。</p></li><li><p>实例化TemporaryFileStream后，调用Dispose()前，有可能发生一个异常。这造成Dispose()得不到调用，资源清理不得不依赖于终结器。为避免这个问题，调用者需要实现一个try&#x2F;finally块。但开发者不需要显式地写一个这样的块。因为C#为此提供了using语句。<img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953552863.png"></p><ul><li>using语句只是提供了try&#x2F;finally块的语法快捷方式。</li></ul></li></ul><h3 id="垃圾回收、终结和IDisposable"><a href="#垃圾回收、终结和IDisposable" class="headerlink" title="垃圾回收、终结和IDisposable"></a>垃圾回收、终结和IDisposable</h3><ol><li>IDisposable.Dispose()方法包含对System.GC.SuppressFinalize()的调用，作用是从终结（f-reachable）队列中移除TemporaryFileStream类实例。这是因为所有清理都在Dispose()方法中完成了，而不是等着终结器执行。<ul><li>该队列中的对象已差不多准备好了进行垃圾回收，只是它们还有终结方法没有运行。这种对象只有在其终结方法被调用之后，才能由“运行时”进行垃圾回收。但垃圾回收器本身不调用终结方法。相反，对这种对象的引用会添加到f-reachable队列中，并由一个额外的线程根据执行上下文，挑选合适的时间进行处理。讽刺的是，这造成了托管资源的垃圾回收时间的推迟——而许多这样的资源本应更早一些被清理。推迟是因为f-reachable队列是“引用”列表。所以，对象只有在它的终结方法得到调用，而且对象引用从f-reachable队列中删除之后，才会真正变成“垃圾”.正是由于这个原因，Dispose()才调用System.GC.SuppressFinalize，告诉“运行时”不要将该对象添加到f-reachable队列，而是允许垃圾回收器在对象没有任何引用（包括任何f-reachable引用）时清除对象。</li></ul></li><li>Dispose()调用了Dispose(bool disposing)方法，并传递实参true。结果是为Stream调用Dispose()方法（清理它的资源并阻止终结）。接着，临时文件在调用Dispose()后立即删除。这个重要的调用避免了一定要等待终结队列处理完毕才能清理资源的限制</li><li>终结器现在不是调用Close()，而是调用Dispose(bool disposing)，并传递实参false。结果是即使文件被删除，Stream也不会关闭（disposed）。原因是从终结器中调用Dispose(bool disposing)时，Stream实例本身还在等待终结（或者已经终结，系统会以任意顺序终结对象）。所以，在执行终结器时，拥有托管资源的对象不应清理，那应该是终结队列的职责。</li><li>同时创建Close()和Dispose()方法需谨慎。只看API并不知道Close()会调用Dispose()。所以开发者搞不清楚是否需要显式调用Close()和Dispose()。</li><li>若要提高终结器在程序结束之前被调用的可能性，可以将终结器中的代码实现并注册到AppDomain.CurrentDomain.ProcessExit事件处理器中。这个方法即便在.NET Core中也有效。只要程序没有异常终止，可以保证代码被执行。（下一节将具体介绍）</li></ol><blockquote><p>避免为自己拥有的、带终结器的对象调用Dispose()。相反，依赖终结队列清理实例。·避免在终结方法中引用未被终结的其他对象。·要在重写Dispose()时调用基类的实现。·考虑在调用Dispose()后将对象状态设为不可用。对象被dispose之后，调用除Dispose()之外的方法应引发ObjectDisposedException异常。（Dispose()应该能多次调用。）·要为含有可dispose字段（或属性）的类型实现IDisposable接口，并dispose这些字段引用的对象。·要在派生类的Dispose()中调用基类的Dispose()。·要重构终结器方法来调用与IDisposable相同的代码，可能就是调用一下Dispose()方法。·不要在终结器方法中抛出异常。·若要提高终结器在程序结束之前被调用的可能性，考虑将终结器中的代码实现在事件处理器里并注册到AppDomain.CurrentDomain.ProcessExitevent中。·如果一个类同时注册了AppDomain.CurrentDomain.ProcessExitevent事件，又实现了Dispose()，一定要在Dispose()方法中解除注册的事件。·要从Dispose()中调用System.GC.SuppressFinalize()，以使垃圾回收更快地发生，并避免重复性的资源清理。·要保证Dispose()可以重入（可被多次调用）。·要保持Dispose()的简单性，把重点放在终结所要求的资源清理上。·要只为使用了稀缺或昂贵资源的对象实现终结器方法，即使终结会推迟垃圾回收。·要为有终结器的类实现IDisposable接口以支持确定性终结。·只有当类包含必须释放的资源，而该资源自己又没有终结器的时候，才要在类中实现终结器。</p></blockquote><blockquote><p>从.NET Core开始，程序结束时终结器不一定会被调用。若要提高终结器被调用的可能性，需要为相应的代码进行注册程序退出事件处理器</p></blockquote><blockquote><p>即使有异常从构造函数传播出来，对象仍会实例化，只是没有新实例从new操作符返回。如类型定义了终结器，对象一旦准备好进行垃圾回收，就会运行该方法（即使只构造了一部分的对象，终结方法也会运行）。另外要注意，如构造函数过早共享它的this引用，即使构造函数抛出异常，也能访问该引用。不要让这种情况发生。</p></blockquote><blockquote><p>调用对象的终结方法时，对该对象的引用都已消失。垃圾回收前唯一剩下的步骤就是运行终结代码。但完全可能无意中重新引用一个待终结的对象。这样，被重新引用的对象就不再是不可访问的，所以不能当作垃圾被回收掉。但假如对象的终结方法已经运行，那么除非显式标记为要进行终结（使用GC.ReRegisterFinalize()方法），否则终结方法不一定会再次运行。显然，像这样的对象复活是非常罕见的，而且通常应该避免发生。终结代码应该简单，只清理它引用的资源。</p></blockquote><h2 id="推迟初始化"><a href="#推迟初始化" class="headerlink" title="推迟初始化"></a>推迟初始化</h2><p>使用推迟初始化，可在需要时才创建（或获取）对象，而不是提前创建好——尤其是它们永远都不使用的前提下。<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953911587.png" alt="推迟加载属性"></p><h3 id="为泛型和Lambda表达式使用推迟加载"><a href="#为泛型和Lambda表达式使用推迟加载" class="headerlink" title="为泛型和Lambda表达式使用推迟加载"></a>为泛型和Lambda表达式使用推迟加载</h3><p>从C# 4.0和Microsoft .NET Framework 4.0开始，CLR添加了一个新类来帮助进行推迟初始化，这个类就是System.Lazy<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668953951386.png"></p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><hr><p>学习资料:<br><a href="https://weread.qq.com/web/reader/16d32eb07297616a16d8f40k81232fb025f812b4ba28a23">c#8.0本质论</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> c# </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>unity的学习</title>
      <link href="/2022/11/06/skill/unity/"/>
      <url>/2022/11/06/skill/unity/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/R-C%20(1).jpg"></p><h1 id="unity"><a href="#unity" class="headerlink" title="unity"></a>unity</h1><hr><p><a href="https://so.gushiwen.cn/shiwenv_05e2f6fc757c.aspx"><strong>梦游天姥吟留别</strong></a></p><p><a href="https://so.gushiwen.cn/authorv.aspx?name=%E6%9D%8E%E7%99%BD">李白</a><a href="https://so.gushiwen.cn/shiwens/default.aspx?cstr=%E5%94%90%E4%BB%A3">〔唐代〕</a></p><p>海客谈瀛洲，烟涛微茫信难求；<br>越人语天姥，云霞明灭或可睹。<br>天姥连天向天横，势拔五岳掩赤城。<br>天台四万八千丈，对此欲倒东南倾。(四万 一作：一万)</p><p>我欲因之梦吴越，一夜飞度镜湖月。<br>湖月照我影，送我至剡溪。<br>谢公宿处今尚在，渌水荡漾清猿啼。<br>脚著谢公屐，身登青云梯。<br>半壁见海日，空中闻天鸡。<br>千岩万转路不定，迷花倚石忽已暝。<br>熊咆龙吟殷岩泉，栗深林兮惊层巅。<br>云青青兮欲雨，水澹澹兮生烟。<br>列缺霹雳，丘峦崩摧。<br>洞天石扉，訇然中开。<br>青冥浩荡不见底，日月照耀金银台。<br>霓为衣兮风为马，云之君兮纷纷而来下。<br>虎鼓瑟兮鸾回车，仙之人兮列如麻。<br>忽魂悸以魄动，恍惊起而长嗟。<br>惟觉时之枕席，失向来之烟霞。</p><p>世间行乐亦如此，古来万事东流水。<br>别君去兮何时还？且放白鹿青崖间，须行即骑访名山。<br>安能摧眉折腰事权贵，使我不得开心颜！</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> unity </category>
          
          <category> c# </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法的学习</title>
      <link href="/2022/11/06/skill/1/"/>
      <url>/2022/11/06/skill/1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/v2-4537af4143f242a63266873ccece7196_720w%20(1).webp"><br>程序员之内功</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>描述存储的结构<br>数据:计算机存储的任何东西,如图像，文字，视频…<br>数据元素:如一条学生记录<br>数据项:元素中的列，如学号，姓名.<br>数据对象:一组性质相同的数据元素的集合,如整数.<br>数据类型:如变量的类型.<br>数据结构的分类</p><ul><li>集合:数据间无关系</li><li>线性结构 先后顺序关系，只能一条</li><li>树形结构 根节点分支散页，像家谱</li><li>图 关系复杂的网状，像地图</li></ul><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>元素间有一对一的位置关系</p><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>顺序表优点:易查找；缺点:不易增删</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>判断index暂时不做</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//2022年11月7日05:53:42</span><br><span class="hljs-comment">//2.自己实现list</span><br><span class="hljs-comment">//接口IList</span><br><span class="hljs-comment">//实现方式:顺序表，单链表，双向链表，循环链表</span><br><span class="hljs-comment">//2022年11月7日05:57:26</span><br><span class="hljs-comment">//顺序表：表中的元素的内存位置是连续的，数据顺序存储.</span><br><span class="hljs-comment">//知道第一个元素的地址和大小就能算出其他元素的地址</span><br><span class="hljs-comment">//c#的数组.</span><br><span class="hljs-comment">//3.使用顺序表</span><br>SeqList&lt;<span class="hljs-built_in">string</span>&gt; seqList=<span class="hljs-keyword">new</span>();<br>seqList.Add(<span class="hljs-string">&quot;123&quot;</span>);<br>seqList.Add(<span class="hljs-string">&quot;456&quot;</span>);<br>seqList.Add(<span class="hljs-string">&quot;789&quot;</span>);<br>seqList.Add(<span class="hljs-string">&quot;0&quot;</span>);<br>SeqList&lt;<span class="hljs-built_in">string</span>&gt;.PrintfAll(seqList);<br>Console.WriteLine(seqList.GetElement(<span class="hljs-number">0</span>));<br>Console.WriteLine(seqList[<span class="hljs-number">0</span>]);<br>seqList.Insert(<span class="hljs-string">&quot;666&quot;</span>,<span class="hljs-number">1</span>);<br>SeqList&lt;<span class="hljs-built_in">string</span>&gt;.PrintfAll(seqList);<br>seqList.Delete(<span class="hljs-number">2</span>);<br>SeqList&lt;<span class="hljs-built_in">string</span>&gt;.PrintfAll(seqList);<br>seqList.Clear();<br>SeqList&lt;<span class="hljs-built_in">string</span>&gt;.PrintfAll(seqList);<br>Console.WriteLine(<span class="hljs-string">&quot;ok&quot;</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果:</span><br><span class="hljs-comment">------------------</span><br><span class="hljs-comment">123 456 789 0 </span><br><span class="hljs-comment">123</span><br><span class="hljs-comment">123</span><br><span class="hljs-comment">123 666 456 789 0 </span><br><span class="hljs-comment">123 456 789 0 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">ok</span><br><span class="hljs-comment">-------------------</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//1.IList</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">IListDS</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span>;<br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsEmpty</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params">T item,<span class="hljs-built_in">int</span> index</span>)</span>;<br><span class="hljs-function">T <span class="hljs-title">Delete</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span>;<br>T <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index] &#123;<span class="hljs-keyword">get</span>;&#125;<br><span class="hljs-function">T <span class="hljs-title">GetElement</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Locate</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">SeqList</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IListDS</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>T[] data;<span class="hljs-comment">//用来存储数据</span><br><span class="hljs-built_in">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-comment">//存储数据的个数</span><br><span class="hljs-comment">//数据扩容思想 当data满了的时候，自动创建更大的数组去承接数据</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SeqList</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> size</span>)<span class="hljs-comment">//size最大容量</span></span><br>&#123;<br>data=<span class="hljs-keyword">new</span> T[size];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SeqList</span>():<span class="hljs-title">this</span>(<span class="hljs-params"><span class="hljs-number">10</span></span>)<span class="hljs-comment">//默认构造函数，容量10</span></span><br>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> T <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index] =&gt; <br>GetElement(index);<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (count==data.Length)<span class="hljs-comment">//判断数组有没有满</span><br>&#123;<br>Console.Write(<span class="hljs-string">&quot;顺序表已满&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>data[count]=item;<span class="hljs-comment">//count此时作为计数器,最大的元素位置</span><br>count++;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span><br>&#123;<br>count=<span class="hljs-number">0</span>;<span class="hljs-comment">//因为索引是0，每次取数据就不存在</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Delete</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)<span class="hljs-comment">//和insert差不多</span></span><br>&#123;<br>T temp=data[index];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = index; i &lt; count; i++)<br>&#123;<br>data[i<span class="hljs-number">-1</span>]=data[i];<span class="hljs-comment">//数据向前移动</span><br>&#125;<br>count--;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">GetElement</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (index&gt;=<span class="hljs-number">0</span>&amp;&amp;index&lt;=count<span class="hljs-number">-1</span>)<span class="hljs-comment">//判断索引是否存在</span><br>&#123;<br><span class="hljs-keyword">return</span> data[index];<br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>Console.Write(<span class="hljs-string">&quot;索引不存在&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">default</span>(T);<span class="hljs-comment">//返回默认值</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params">T item, <span class="hljs-built_in">int</span> index</span>)</span><br>&#123;<br><span class="hljs-comment">//index的位置和后面的元素都应该向后移动一位</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = count; i &gt;=index; i--)<span class="hljs-comment">//从前向后遍历会覆盖值</span><br>&#123;<br>data[i+<span class="hljs-number">1</span>]=data[i];<br>&#125;<br>data[index]=item;<br>count++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsEmpty</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> count==<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Locate</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (data[i].Equals(<span class="hljs-keyword">value</span>))<br>&#123;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//表示经过遍历仍未找到数据.</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintfAll</span>(<span class="hljs-params">SeqList&lt;T&gt; seqList</span>)<span class="hljs-comment">//遍历打印</span></span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; seqList.GetLength(); i++)<br>&#123;<br>Console.Write(seqList[i] + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>Console.WriteLine();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="List-lt-gt"><a href="#List-lt-gt" class="headerlink" title="List&lt;&gt;"></a><code>List&lt;&gt;</code></h4><p>c#预定义List泛型<br>使用BCL的List线性表,f12查看更多方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//2022年11月7日05:29:48</span><br><br>List&lt;<span class="hljs-built_in">string</span>&gt; strList=<span class="hljs-keyword">new</span>();<br>strList.Add(<span class="hljs-string">&quot;123&quot;</span>);<span class="hljs-comment">//0</span><br>strList.Add(<span class="hljs-string">&quot;456&quot;</span>);<span class="hljs-comment">//1</span><br>strList.Add(<span class="hljs-string">&quot;789&quot;</span>);<span class="hljs-comment">//2</span><br>strList.Add(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-comment">//3</span><br>Console.WriteLine(strList[<span class="hljs-number">2</span>]);<span class="hljs-comment">//通过索引器访问元素</span><br>strList.Remove(<span class="hljs-string">&quot;789&quot;</span>);<span class="hljs-comment">//移除元素</span><br>Console.WriteLine(strList.Count);<span class="hljs-comment">//大小</span><br>strList.Clear();<span class="hljs-comment">//清空</span><br>Console.WriteLine(strList.Count);<br>/CopyTo(),IndexOf(),FindIndex(),Insert(),RemoveAll(),RemoveAt(),Sort(),<br></code></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链式表 逻辑上相邻的元素不要求物理上相邻<br>链表易增删慢查找存储<br>链表的元素:节点&#x3D;数据+指针(引用)<br>头节点无数据,尾节点空指针<br>实现:节点类 数据和引用</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//2022年11月7日10:33:58</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>T data;<span class="hljs-comment">//数据</span><br>Node&lt;T&gt; next;<span class="hljs-comment">//引用</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params">T data</span>)<span class="hljs-comment">//只传递数据</span></span><br>&#123;<br><span class="hljs-keyword">this</span>.data=data;<br>next=<span class="hljs-literal">null</span>;<span class="hljs-comment">//尾节点</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params">T data,Node&lt;T&gt; next</span>)<span class="hljs-comment">//传递数据和指针  </span></span><br>&#123;<br><span class="hljs-keyword">this</span>.data=data;<br><span class="hljs-keyword">this</span>.next=next;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params">Node&lt;T&gt; next</span>)<span class="hljs-comment">//只传入指针 </span></span><br>&#123;<br><span class="hljs-keyword">this</span>.next=next;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>() <span class="hljs-comment">//空方法</span></span><br>&#123;<br>data=<span class="hljs-literal">default</span>(T);<br>next=<span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> T Data<br>&#123;<br><span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> data; &#125;<br><span class="hljs-keyword">set</span> &#123; data = <span class="hljs-keyword">value</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> Node&lt;T&gt; Next<br>&#123;<br><span class="hljs-keyword">get</span>&#123;<span class="hljs-keyword">return</span> next;&#125;<br><span class="hljs-keyword">set</span>&#123;next=<span class="hljs-keyword">value</span>;&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//实现单链表，IList接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">LinkList</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IList</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br><span class="hljs-comment">//使用节点进行存储</span><br>Node&lt;T&gt; head;<span class="hljs-comment">//存储一个头结点</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkList</span>()<span class="hljs-comment">//构造</span></span><br>&#123;<br>head=<span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> T <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>&#123;<br><span class="hljs-keyword">get</span><br>&#123;<br>Node&lt;T&gt; temp = head;<span class="hljs-comment">//从头节点开始遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= index; i++)<br>&#123;<br>temp = temp.Next;<span class="hljs-comment">//temp向后移动</span><br>&#125;<br><span class="hljs-keyword">return</span> temp.Data;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Count</span>()</span><br>&#123;<br>Node&lt;T&gt; temp=head;<br><span class="hljs-built_in">int</span> count=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(temp.Next!=<span class="hljs-literal">null</span>)<br>&#123;<br>count++;<br>temp=temp.Next;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsReadOnly =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br><br><span class="hljs-built_in">int</span> ICollection&lt;T&gt;.Count =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br><br>T IList&lt;T&gt;.<span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index] &#123; <span class="hljs-keyword">get</span> =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); <span class="hljs-keyword">set</span> =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span><br>&#123;<br>Node&lt;T&gt; newNode=<span class="hljs-keyword">new</span> Node&lt;T&gt;(item);<span class="hljs-comment">//根据新的数据创建一个新的节点</span><br><span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)<br>&#123;<br>head=newNode;<span class="hljs-comment">//新节点成为头节点</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//把新节点放在链表的尾部</span><br><span class="hljs-comment">//访问尾结点</span><br>Node&lt;T&gt; temp=head;<span class="hljs-comment">//从头节点开始遍历</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (temp.Next != <span class="hljs-literal">null</span>)<br>&#123;<br>temp=temp.Next;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//next为空，找到了尾节点</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>temp.Next=newNode;<span class="hljs-comment">//让尾节点的next指向新节点。新节点成为了尾节点，添加成功</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span><br>&#123;<br>head=<span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Contains</span>(<span class="hljs-params">T item</span>)</span><br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CopyTo</span>(<span class="hljs-params">T[] array, <span class="hljs-built_in">int</span> arrayIndex</span>)</span><br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator&lt;T&gt; <span class="hljs-title">GetEnumerator</span>()</span><br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">IndexOf</span>(<span class="hljs-params">T item</span>)</span><br>&#123;<br>Node&lt;T&gt; temp = head;<br><span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">null</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (temp.Data.Equals(item))<br>&#123;<br><span class="hljs-keyword">return</span> index;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span>(temp.Next!=<span class="hljs-literal">null</span>)<br>&#123;<br>index++;<br>temp = temp.Next;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, T item</span>)</span><br>&#123;<br><span class="hljs-keyword">var</span> newNode=<span class="hljs-keyword">new</span> Node&lt;T&gt;(item);<span class="hljs-comment">//插入的新节点</span><br><span class="hljs-comment">//暂时不做数据判断</span><br><span class="hljs-keyword">if</span>(index==<span class="hljs-number">0</span>)<span class="hljs-comment">//插入头节点的情况</span><br>&#123;<br>newNode.Next=head;<span class="hljs-comment">//新节点指向原来的头节点</span><br>head=newNode;<span class="hljs-comment">//新节点成为了头节点</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//1.修改上一个节点的next为新节点;2.将自己的next设置为index原来的节点</span><br><span class="hljs-comment">//访问indexs所在的节点</span><br>Node&lt;T&gt; temp = head;<span class="hljs-comment">//从头节点开始遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= index<span class="hljs-number">-1</span>; i++)<span class="hljs-comment">//先访问到index-1</span><br>&#123;<br>temp=temp.Next;<span class="hljs-comment">//temp向后移动</span><br>&#125;<br>Node&lt;T&gt; preNode=temp;<span class="hljs-comment">//上一节点</span><br>Node&lt;T&gt; currentNode=temp.Next;<span class="hljs-comment">//index所在的节点</span><br><span class="hljs-comment">//插入:</span><br>preNode.Next=newNode;<br>newNode.Next=currentNode;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Remove</span>(<span class="hljs-params">T item</span>)</span><br>&#123;<br>Console.Write(<span class="hljs-string">&quot;暂时不要求&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RemoveAt</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)<span class="hljs-comment">//删除头节点</span><br>&#123;<br>head=head.Next;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//删除普通节点</span><br>&#123;<br><span class="hljs-comment">//1.修改上一个节点的next为下一个节点</span><br><span class="hljs-comment">//访问indexs所在的节点</span><br>Node&lt;T&gt; temp = head;<span class="hljs-comment">//从头节点开始遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= index - <span class="hljs-number">1</span>; i++)<span class="hljs-comment">//先访问到index-1</span><br>&#123;<br>temp = temp.Next;<span class="hljs-comment">//temp向后移动</span><br>&#125;<br>Node&lt;T&gt; preNode = temp;<span class="hljs-comment">//上一节点</span><br>Node&lt;T&gt; nextNode = temp.Next.Next;<span class="hljs-comment">//Next是要删除的节点，Next.Next下一个节点</span><br><br>preNode.Next = nextNode;<br>&#125;<br>&#125;<br><br>IEnumerator IEnumerable.GetEnumerator()<br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintfAll</span>(<span class="hljs-params">LinkList&lt;T&gt; seqList</span>)<span class="hljs-comment">//遍历打印</span></span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; seqList.Count(); i++)<br>&#123;<br>Console.Write(seqList[i] + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>Console.WriteLine();<br>&#125;<br>&#125;<br><span class="hljs-comment">//测试</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br>LinkList&lt;<span class="hljs-built_in">string</span>&gt; list=<span class="hljs-keyword">new</span>();<br><br>list.Add(<span class="hljs-string">&quot;123&quot;</span>);<br>list.Add(<span class="hljs-string">&quot;456&quot;</span>);<br>list.Add(<span class="hljs-string">&quot;789&quot;</span>);<br>list.Add(<span class="hljs-string">&quot;0&quot;</span>);<br><br>LinkList&lt;<span class="hljs-built_in">string</span>&gt;.PrintfAll(list);<br>list.Insert(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;666&quot;</span>);<br>LinkList&lt;<span class="hljs-built_in">string</span>&gt;.PrintfAll(list);<br>Console.WriteLine(list.IndexOf(<span class="hljs-string">&quot;666&quot;</span>));<br>list.RemoveAt(<span class="hljs-number">3</span>);<br>LinkList&lt;<span class="hljs-built_in">string</span>&gt;.PrintfAll(list);<br>list.Clear();<br>list.Add(<span class="hljs-string">&quot;000&quot;</span>);<br>LinkList&lt;<span class="hljs-built_in">string</span>&gt;.PrintfAll(list);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">123 456 789 0 </span><br><span class="hljs-comment">123 456 666 789 0 </span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">123 456 666 0 </span><br><span class="hljs-comment">000 </span><br><span class="hljs-comment">*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>双向链表:prev,data,next<br>循环列表:尾节点的next是头节点</p><h4 id="LinkedList-lt-T-gt"><a href="#LinkedList-lt-T-gt" class="headerlink" title="LinkedList&lt;T&gt;"></a><code>LinkedList&lt;T&gt;</code></h4><p>c#的实现是双向链表.</p><ul><li><code>First Last</code></li><li><code>AddAfter() AddFirst() AddLast()</code></li><li><code>Remove(),RemoveFirst(),RemoveLast()</code></li><li><code>Find(),FindLast()</code> </li><li>元素为:<code>LinkedList&lt;T&gt;</code><ul><li>属性:<code>List</code>，<code>Next</code>，<code>Previous</code>和<code>Value</code></li></ul></li></ul><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p> 线性结构<br>操作受到限制的线性表<br>    - 栈只能在一端进行<br>    - 队列的插入在一端，其他操作在另一端</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈的操作限定在表尾(栈顶)</p><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IStackDS</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br><span class="hljs-built_in">int</span> Count &#123;<span class="hljs-keyword">get</span>;&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span>;<br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsEmpty</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Push</span>(<span class="hljs-params">T item</span>)</span>;<br><span class="hljs-function">T <span class="hljs-title">Pop</span>()</span>;<br><span class="hljs-function">T <span class="hljs-title">Peek</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">StackDS</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IStackDS</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>T[] data;<br><span class="hljs-built_in">int</span> top;<span class="hljs-comment">//栈顶的索引</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StackDS</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> size</span>)</span><br>&#123;<br>data=<span class="hljs-keyword">new</span> T[size];<br>top=<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StackDS</span>() : <span class="hljs-title">this</span>(<span class="hljs-params"><span class="hljs-number">10</span></span>)</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Count <br>=&gt; top+<span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span><br>&#123;<br>top=<span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> Count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsEmpty</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> Count==<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Peek</span>()</span><br>&#123;<br>T temp = data[top];<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Pop</span>()</span><br>&#123;<br>T temp=data[top];<br>top--;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Push</span>(<span class="hljs-params">T item</span>)</span><br>&#123;<br>data[top+<span class="hljs-number">1</span>]=item;<span class="hljs-comment">//放在原栈顶的上面</span><br>top++;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br>IStackDS&lt;<span class="hljs-built_in">char</span>&gt; stacks = <span class="hljs-keyword">new</span> StackDS&lt;<span class="hljs-built_in">char</span>&gt;();<br>stacks.Push(<span class="hljs-string">&#x27;a&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;b&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;c&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;d&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;e&#x27;</span>);<br>Console.WriteLine(stacks.Count);<br><span class="hljs-keyword">var</span> v = stacks.Pop();<br>Console.WriteLine(v);<br>Console.WriteLine(stacks.Count);<br><span class="hljs-keyword">var</span> v2 = stacks.Peek();<br>Console.WriteLine(v2);<br>Console.WriteLine(stacks.Count);<br>stacks.Clear();<span class="hljs-comment">//空栈不能进行peek/pop，异常</span><br>Console.WriteLine(stacks.Count);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">e</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">d</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><p>2022年11月7日20:01:07<br>栈顶设在链表的头部，不需要头节点<br>本来遍历到末尾才能添加,现在新节点指向原来的头节点,头节点指向新节点，此时添加只需要头节点</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c#">LinkStack&lt;<span class="hljs-built_in">char</span>&gt; stacks = <span class="hljs-keyword">new</span>();<br>stacks.Push(<span class="hljs-string">&#x27;a&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;b&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;c&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;d&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;e&#x27;</span>);<br>Console.WriteLine(stacks.Count);<br><span class="hljs-keyword">var</span> v = stacks.Pop();<br>Console.WriteLine(v);<br>Console.WriteLine(stacks.Count);<br><span class="hljs-keyword">var</span> v2 = stacks.Peek();<br>Console.WriteLine(v2);<br>Console.WriteLine(stacks.Count);<br>stacks.Clear();<span class="hljs-comment">//空栈不能进行peek/pop，异常</span><br>Console.WriteLine(stacks.Count);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>T data;<br>Node&lt;T&gt; next;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params">T data</span>)</span><br>&#123;<br><span class="hljs-keyword">this</span>.data=data;<br>next=<span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params">T data,Node&lt;T&gt; next</span>)</span><br>&#123;<br><span class="hljs-keyword">this</span>.data=data;<br><span class="hljs-keyword">this</span>.next=next;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params">Node&lt;T&gt; next</span>)</span><br>&#123;<br><span class="hljs-keyword">this</span>.next=next;<br>data=<span class="hljs-literal">default</span>(T);<br>&#125;<br><br><span class="hljs-keyword">public</span> T Data<br>&#123;<br><span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> data; &#125;<br><span class="hljs-keyword">set</span> &#123; data = <span class="hljs-keyword">value</span>; &#125;<br>&#125;<br><span class="hljs-keyword">public</span> Node&lt;T&gt; Next <br>&#123;<br><span class="hljs-keyword">get</span>=&gt;next;<br><span class="hljs-keyword">set</span>=&gt;next=<span class="hljs-keyword">value</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">LinkStack</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>Node&lt;T&gt; top;<span class="hljs-comment">//栈顶元素节点</span><br><span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//栈元素个数</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Count &#123; <span class="hljs-keyword">get</span> =&gt; count; &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span> =&gt; count;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsEmpty =&gt; count == <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span><br>&#123;<br>count=<span class="hljs-number">0</span>;<br>top=<span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Push</span>(<span class="hljs-params">T item</span>)<span class="hljs-comment">//把新添加的元素作为栈顶元素节点</span></span><br>&#123;<br><span class="hljs-keyword">var</span> newNode=<span class="hljs-keyword">new</span> Node&lt;T&gt;(item);<br>newNode.Next=top;<br>top=newNode;<br>count++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Pop</span>()</span><br>&#123;<br>T data=top.Data;<br>top=top.Next;<span class="hljs-comment">//top指向栈顶的下面的元素</span><br>top.Next=<span class="hljs-literal">null</span>;<br>count--;<br><span class="hljs-keyword">return</span> data;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Peek</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> top.Data;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Statck-lt-gt"><a href="#Statck-lt-gt" class="headerlink" title="Statck&lt;&gt; "></a><code>Statck&lt;&gt; </code></h4><p>BCL的栈:<code>Statck&lt;&gt; </code><br>操作:<code>Push(),Pop(),Peek(),Clear(),Count</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//2022年11月7日19:32:47</span><br>Stack&lt;<span class="hljs-built_in">char</span>&gt; stacks=<span class="hljs-keyword">new</span>();<br>stacks.Push(<span class="hljs-string">&#x27;a&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;b&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;c&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;d&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;e&#x27;</span>);<br>Console.WriteLine(stacks.Count);<br><span class="hljs-keyword">var</span> v=stacks.Pop();<br>Console.WriteLine(v);<br>Console.WriteLine(stacks.Count);<br><span class="hljs-keyword">var</span> v2=stacks.Peek();<br>Console.WriteLine(v2);<br>Console.WriteLine(stacks.Count);<br>stacks.Clear();<span class="hljs-comment">//空栈不能进行peek/pop，异常</span><br>Console.WriteLine(stacks.Count);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">e</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">d</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>插入操作限定尾部队尾，其他操作限定在头部队头 空队列<br>前出后进的核酸排队</p><h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><p>类似顺序栈.<br>队首数组下标0 front<br>队尾 rear<br>队列空:front&#x3D;rear&#x3D;-1<br>循环顺序队列:假溢出<br>删除数据front后移，但是删除过的下标任然可以存储<br>队满后rear从删除过的0再次开始存储</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span>/2022年11月7日20:47:12</span><br>SeqQueue&lt;<span class="hljs-built_in">int</span>&gt; q=<span class="hljs-keyword">new</span>();<br>q.Enqueue(<span class="hljs-number">23</span>);<span class="hljs-comment">//队首</span><br>q.Enqueue(<span class="hljs-number">45</span>);<br>q.Enqueue(<span class="hljs-number">67</span>);<br>q.Enqueue(<span class="hljs-number">89</span>);<span class="hljs-comment">//队尾</span><br><br>Console.WriteLine(<span class="hljs-string">&quot;start:&quot;</span>+q.Count);<br><span class="hljs-keyword">var</span> v=q.Dequeue();<br>Console.WriteLine(<span class="hljs-string">&quot;删除的队首&quot;</span>+v);<br>Console.WriteLine(<span class="hljs-string">&quot;删除后个数&quot;</span>+q.Count);<br>Console.WriteLine(<span class="hljs-string">&quot;现在队首元素&quot;</span>+q.Peek());<br>q.Clear();<br>Console.WriteLine(<span class="hljs-string">&quot;清空&quot;</span>+q.Count);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">start:4</span><br><span class="hljs-comment">删除的队首23</span><br><span class="hljs-comment">删除后个数3</span><br><span class="hljs-comment">现在队首元素45</span><br><span class="hljs-comment">清空0</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">IQueue</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br><span class="hljs-built_in">int</span> Count &#123;<span class="hljs-keyword">get</span>;&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span>;<br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsEmpty</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Enqueue</span>(<span class="hljs-params">T item</span>)</span>;<br><span class="hljs-function">T <span class="hljs-title">Dequeue</span>()</span>;<br><span class="hljs-function">T <span class="hljs-title">Peek</span>()</span>;<br>&#125;<br><span class="hljs-comment">//顺序队列</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">SeqQueue</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IQueue</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>T[] data;<br><span class="hljs-built_in">int</span> count;<span class="hljs-comment">//当前元素个数</span><br><span class="hljs-built_in">int</span> front;<span class="hljs-comment">//队首元素索引-1</span><br><span class="hljs-built_in">int</span> rear;<span class="hljs-comment">//队尾元素索引</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SeqQueue</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> size</span>)</span><br>&#123;<br>data=<span class="hljs-keyword">new</span> T[size];<br>count=<span class="hljs-number">0</span>;<br>front=<span class="hljs-number">-1</span>;<br>rear=<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SeqQueue</span>():<span class="hljs-title">this</span>(<span class="hljs-params"><span class="hljs-number">10</span></span>)</span>&#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Count =&gt; count;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span><br>&#123;<br>count=<span class="hljs-number">0</span>;<br>front=rear=<span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Dequeue</span>()</span><br>&#123;<br><span class="hljs-keyword">if</span> (count&gt;<span class="hljs-number">0</span>)<br>&#123;<br>T temp=data[front+<span class="hljs-number">1</span>];<br>front++;<br>count--;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Console.WriteLine(<span class="hljs-string">&quot;队列为空&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">default</span>(T);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Enqueue</span>(<span class="hljs-params">T item</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (count==data.Length)<br>&#123;<br>Console.WriteLine(<span class="hljs-string">&quot;队列已满&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (rear==data.Length)<span class="hljs-comment">//1.rear在最后一个元素索引</span><br>&#123;<br>data[<span class="hljs-number">0</span>]=item;<br>rear=<span class="hljs-number">0</span>;<br>count++;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//正常放在rear后面</span><br>&#123;<br>data[rear+<span class="hljs-number">1</span>]=item;<br>rear++;<br>count++;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span><br>=&gt;count;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsEmpty</span>()</span><br>=&gt;count==<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Peek</span>()</span><br>&#123;<br>T temp = data[front + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h4><p>单链表的简化，仅对首尾操作，不对中间操作</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span>/2022年11月7日21:06:34</span><br><span class="hljs-comment">//</span><br>LinkQueue&lt;<span class="hljs-built_in">int</span>&gt; q=<span class="hljs-keyword">new</span>();<br>q.Enqueue(<span class="hljs-number">23</span>);<span class="hljs-comment">//队首</span><br>q.Enqueue(<span class="hljs-number">45</span>);<br>q.Enqueue(<span class="hljs-number">67</span>);<br>q.Enqueue(<span class="hljs-number">89</span>);<span class="hljs-comment">//队尾</span><br><br>Console.WriteLine(<span class="hljs-string">&quot;start:&quot;</span>+q.Count);<br><span class="hljs-keyword">var</span> v=q.Dequeue();<br>Console.WriteLine(<span class="hljs-string">&quot;删除的队首&quot;</span>+v);<br>Console.WriteLine(<span class="hljs-string">&quot;删除后个数&quot;</span>+q.Count);<br>Console.WriteLine(<span class="hljs-string">&quot;现在队首元素&quot;</span>+q.Peek());<br>q.Clear();<br>Console.WriteLine(<span class="hljs-string">&quot;清空&quot;</span>+q.Count);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">start:4</span><br><span class="hljs-comment">删除的队首23</span><br><span class="hljs-comment">删除后个数3</span><br><span class="hljs-comment">现在队首元素45</span><br><span class="hljs-comment">清空0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>T data;<br>Node&lt;T&gt; next;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params">T data</span>)</span>=&gt;<span class="hljs-keyword">this</span>.data=data;<br><br><span class="hljs-keyword">public</span> T Data<br>&#123;<br><span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> data; &#125;<br><span class="hljs-keyword">set</span> &#123; data = <span class="hljs-keyword">value</span>; &#125;<br>&#125;<br><span class="hljs-keyword">public</span> Node&lt;T&gt; Next<br>&#123;<br><span class="hljs-keyword">get</span> =&gt;next;<br><span class="hljs-keyword">set</span> =&gt;next=<span class="hljs-keyword">value</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">LinkQueue</span>&lt;<span class="hljs-title">T</span>&gt;:<span class="hljs-title">Queue</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>Node&lt;T&gt; front;<span class="hljs-comment">//头节点</span><br>Node&lt;T&gt; rear;<span class="hljs-comment">//尾节点</span><br><span class="hljs-built_in">int</span> count;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkQueue</span>()</span><br>&#123;<br>front=<span class="hljs-literal">null</span>;<br>rear=<span class="hljs-literal">null</span>;<br>count=<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Count=&gt;count;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span>=&gt;count;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsEmpty</span>()</span>=&gt;count==<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span><br>&#123;<br>front = <span class="hljs-literal">null</span>;<br>rear = <span class="hljs-literal">null</span>;<br>count = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Enqueue</span>(<span class="hljs-params">T item</span>)<span class="hljs-comment">//队尾入队</span></span><br>&#123;<br><span class="hljs-keyword">var</span> newNode = <span class="hljs-keyword">new</span> Node&lt;T&gt;(item);<br><span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)<span class="hljs-comment">//当前无元素</span><br>&#123;<br>front=newNode;<br>rear=newNode;<br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>rear.Next=newNode;<br>rear=newNode;<br>&#125;<br>count++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Dequeue</span>()</span><br>&#123;<br><span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)<br>&#123;<br>Console.WriteLine(<span class="hljs-string">&quot;队列为空&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">default</span>(T);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>)<span class="hljs-comment">//只有一个元素，队头就是队尾</span><br>&#123;<br>Node&lt;T&gt; node=rear;<br>front=<span class="hljs-literal">null</span>;<br>rear=<span class="hljs-literal">null</span>;<br>count--;<br><span class="hljs-keyword">return</span> node.Data;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Node&lt;T&gt; node=front;<br>front=front.Next;<br>count--;<br><span class="hljs-keyword">return</span> node.Data;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Peek</span>()</span><br>&#123;<br><span class="hljs-keyword">if</span> (front == <span class="hljs-literal">null</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">default</span>(T);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> front.Data;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Queue-lt-gt"><a href="#Queue-lt-gt" class="headerlink" title="Queue&lt;&gt;"></a><code>Queue&lt;&gt;</code></h4><p>BLC的<code>Queue</code>泛型类 <code>Enqueue()</code>插队尾 <code>Dequeue()</code>取删队首 <code>Peek()</code>队首的元素 <code>Clear()</code> <code>Count</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//2022年11月7日20:23:45</span><br>Queue&lt;<span class="hljs-built_in">int</span>&gt; q=<span class="hljs-keyword">new</span>();<br>q.Enqueue(<span class="hljs-number">23</span>);<span class="hljs-comment">//队首</span><br>q.Enqueue(<span class="hljs-number">45</span>);<br>q.Enqueue(<span class="hljs-number">67</span>);<br>q.Enqueue(<span class="hljs-number">89</span>);<span class="hljs-comment">//队尾</span><br><br>Console.WriteLine(<span class="hljs-string">&quot;start:&quot;</span>+q.Count);<br><span class="hljs-keyword">var</span> v=q.Dequeue();<br>Console.WriteLine(<span class="hljs-string">&quot;删除的元素&quot;</span>+v);<br>Console.WriteLine(<span class="hljs-string">&quot;删除后个数&quot;</span>+q.Count);<br>Console.WriteLine(<span class="hljs-string">&quot;队首元素&quot;</span>+q.Peek());<br>q.Clear();<br>Console.WriteLine(<span class="hljs-string">&quot;清空&quot;</span>+q.Count);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">start:4</span><br><span class="hljs-comment">删除的元素23</span><br><span class="hljs-comment">删除后个数3</span><br><span class="hljs-comment">队首元素45</span><br><span class="hljs-comment">清空0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="栈和队列的应用-回文"><a href="#栈和队列的应用-回文" class="headerlink" title="栈和队列的应用:回文"></a>栈和队列的应用:回文</h3><p>一个放栈中，一个放队列中,分别判断出来的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//2022年11月7日21:30:57</span><br><span class="hljs-built_in">string</span> str=Console.ReadLine();<br>Stack&lt;<span class="hljs-built_in">char</span>&gt; stack=<span class="hljs-keyword">new</span>();<br>Queue&lt;<span class="hljs-built_in">char</span>&gt; queue=<span class="hljs-keyword">new</span>();<br><span class="hljs-comment">//存储</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; str.Length; i++)<br>&#123;<br>stack.Push(str[i]);<br>queue.Enqueue(str[i]);<br>&#125;<br><span class="hljs-comment">//比较</span><br><span class="hljs-built_in">bool</span> isHui=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (stack.Count&gt;<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (stack.Pop()!=queue.Dequeue())<br>&#123;<br>isHui=<span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>Console.Write(<span class="hljs-string">&quot;是回文:&quot;</span>+isHui);<br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符组成的有序的序列</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//2022年11月8日06:54:27</span><br><span class="hljs-comment">//基本功能:实现</span><br>StringDS s=<span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;1,a b =&quot;</span>);<br>Console.WriteLine(s.IndexOf(<span class="hljs-keyword">new</span> StringDS(<span class="hljs-string">&quot;a&quot;</span>)));<br>Console.WriteLine(s[<span class="hljs-number">4</span>]);<br>Console.WriteLine(s.Compare(s.SubString(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">b</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">StringDS</span><br>&#123;<br><span class="hljs-built_in">char</span>[] data;<span class="hljs-comment">//存放字符</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>传入char[]构造<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringDS</span>(<span class="hljs-params"><span class="hljs-built_in">char</span>[] array</span>)</span><br>&#123;<br>data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[array.Length];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; data.Length; i++)<br>&#123;<br>data[i] = array[i];<br>&#125;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>传入string构造<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringDS</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span><br>&#123;<br>data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[str.Length];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; data.Length; i++)<br>&#123;<br>data[i] = str[i];<br>&#125;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>索引器<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">char</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]&#123;<span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> data[index]; &#125; &#125;<span class="hljs-comment">//只读</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>获取字符串长度<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span> =&gt; data.Length;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>字符串的比较<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Compare</span>(<span class="hljs-params">StringDS s</span>)<span class="hljs-comment">//相同返回0；小-1；大1</span></span><br>&#123;<br><span class="hljs-built_in">int</span> len = <span class="hljs-keyword">this</span>.GetLength() &lt; s.GetLength() ? <span class="hljs-keyword">this</span>.GetLength() : s.GetLength();<span class="hljs-comment">//取得小的字符串的长度</span><br><span class="hljs-built_in">int</span> index = <span class="hljs-number">-1</span>;<span class="hljs-comment">//是否相同,-1相同</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[i] != s[i])<br>&#123;<br>index = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (index != <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[index] &lt; s[index] ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.GetLength() == s.GetLength())<span class="hljs-comment">//前len一样&amp;&amp;长度一样</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//len:abc abcd</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.GetLength() &lt; s.GetLength() ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>连接字符串<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringDS <span class="hljs-title">Concat</span>(<span class="hljs-params">StringDS s1,StringDS s2</span>)</span><br>&#123;<br><span class="hljs-built_in">char</span>[] newData=<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[s1.GetLength()+s2.GetLength()];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; s1.GetLength(); i++)<br>&#123;<br>newData[i]=s1[i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = s1.GetLength(); i &lt; s1.GetLength()+s2.GetLength(); i++)<br>&#123;<br>newData[i] = s2[i];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StringDS(newData);<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>查询子字符串<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">IndexOf</span>(<span class="hljs-params">StringDS s</span>)</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-keyword">this</span>.GetLength()-s.GetLength(); i++)<br>&#123;<br><span class="hljs-built_in">bool</span> flag=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i; j &lt; i + s.GetLength(); j++)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>[j]!=s[j-i])<br>&#123;<br>flag=<span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(flag)<br>&#123;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>子字符串<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> StringDS <span class="hljs-title">SubString</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index,<span class="hljs-built_in">int</span> length</span>)</span><br>&#123;<br><span class="hljs-keyword">var</span> newData=<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[length];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = index; i &lt; index+length; i++)<br>&#123;<br>newData[i-index]=data[i];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StringDS(newData);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>2022年11月8日12:51:41<br>线性表的推广<br>n个相同数据类型的有限序列<br>BLC的<code>Array</code>抽象类<br>在堆上分配空间.数组变量是引用.<br>当数组元素是引用类型时，数组包含的只是引用<br><code>Length,Rank,static BinarySearch&lt;T&gt;()搜索值在数组的位置,static Clear(), Clone,static Copy(),CopyTo(),static CreateInstance()创建数组,GetEnumerator(),GetVaule(),static IndexOf&lt;&gt;(),LastIndexOf(),static Reverse(),SetValue,static Sort()</code></p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>n(n&gt;&#x3D;0)个节点的有限集.<br>n&#x3D;0为空节点<br>发散点为根节点.发散出来的为子节点<br>子树，子节点形成的树<br>不能形成树的节点为叶节点<br>度:拥有子节点节点的个数<br>深度:节点的层数</p><ul><li>子树不相连</li></ul><p>一般是链式存储.</p><ol><li>双亲表示法(data+parent)</li><li>孩子表示法(data+child1+child2+…+child7)</li><li>孩子兄弟表示法(data+firstChild+rightslib)</li></ol><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>最多两个子节点<br>子节点可称为左右子树<br>左斜树 无右节点，反之亦然</p><p>每层最多2^(k-1) k为深度<br>最多:2^0+2^1+2^2+…+2^(k-1)&#x3D;2^k-1</p><p>满二叉树<br>除了最后一层，其他层都有两个子节点的二叉树<br>编号按满二叉树来编号:对于二叉树即使节点不存在也要编号i<br>双亲是i&#x2F;2<br>左子节点2<em>i,右子节点2</em>i+1</p><p>完全二叉树<br>最后一层聚集到左边，右边可空的满二叉树<br>2<em>i&gt;n则无左孩子。2</em>1+1&gt;n则无右孩子 n为总个数</p><p>存储<br>使用顺序存储(数组)做满二叉树状态的数组.用编号换算成索引.<br>特殊的数,通过编号获得兄弟，父子.数据不存在也要有编号，值为空</p><blockquote><p>也可以使用链式存储.但是浪费内存，父节点不好访问</p></blockquote><p>遍历<br>从根节点出发，按某种次序访问所有节点一次<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668741237841.png" alt="数据"></p><blockquote><p>为了把树中的节点变成有意义的线性序列</p></blockquote><ul><li>前序遍历<br>  先输出当前节点的数据,再依次输出左节点和右节点<br>  ABDGHCEIF</li><li>中序遍历<br>  先遍历输出左节点,再输出当前节点的数据，再遍历输出右节点<br>  GDHBAEIGF</li><li>后序遍历<br>  先遍历输出左节点，再遍历输出右节点，最后输出当前节点<br>  GHDBIEFCA</li><li>层序遍历<br>  从第一层开始从上到下逐层遍历，在同一层中逐个输出<br>  ABCDEFGHI</li></ul><h4 id="顺序二叉树"><a href="#顺序二叉树" class="headerlink" title="顺序二叉树"></a>顺序二叉树</h4><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668779393832.png"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br><span class="hljs-built_in">char</span>[] data = &#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-string">&#x27;H&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;J&#x27;</span>&#125;;<br>BiTree&lt;<span class="hljs-built_in">char</span>&gt; tree=<span class="hljs-keyword">new</span> BiTree&lt;<span class="hljs-built_in">char</span>&gt;(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; data.Length; i++)<br>&#123;<br>tree.Add(data[i]);<br>&#125;<br>tree.FirstTraversal(<span class="hljs-number">0</span>);<br>Console.WriteLine();<br>tree.MiddleTraversal(<span class="hljs-number">0</span>);<br>Console.WriteLine();<br>tree.LastTraversal(<span class="hljs-number">0</span>);<br>Console.WriteLine();<br>tree.LayerTraversal(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">BiTree</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">无节点为-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> T[] data;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> count=<span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BiTree</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> capacity</span>)</span><br>&#123;<br>data=<span class="hljs-keyword">new</span> T[capacity];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (count&gt;=data.Length)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>data[count]=item;<br>count++;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>前序遍历<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FirstTraversal</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>&#123;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>遍历条件</span><br><span class="hljs-keyword">if</span> (index&gt;=count)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>处理节点无数据</span><br><span class="hljs-keyword">if</span>(data[index].Equals(<span class="hljs-number">-1</span>))<span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">int</span> number=index+<span class="hljs-number">1</span>;<span class="hljs-comment">//编号</span><br>Console.Write(data[index]+<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">//本节点</span><br><span class="hljs-built_in">int</span> leftNumber=number*<span class="hljs-number">2</span>;<span class="hljs-comment">//左子节点编号</span><br>FirstTraversal(leftNumber<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">int</span> rightNumber=number*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//右子节点编号</span><br>FirstTraversal(rightNumber<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>中序<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MiddleTraversal</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>&#123;<br><span class="hljs-comment">/*遍历左子节点，再访问当前节点，最后访问右子节点</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>遍历条件</span><br><span class="hljs-keyword">if</span> (index &gt;= count)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>处理节点无数据</span><br><span class="hljs-keyword">if</span> (data[index].Equals(<span class="hljs-number">-1</span>)) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">int</span> number = index + <span class="hljs-number">1</span>;<span class="hljs-comment">//编号</span><br><span class="hljs-built_in">int</span> leftNumber = number * <span class="hljs-number">2</span>;<span class="hljs-comment">//左子节点编号</span><br>MiddleTraversal(leftNumber - <span class="hljs-number">1</span>);<br>Console.Write(data[index] + <span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">//本节点</span><br><span class="hljs-built_in">int</span> rightNumber = number * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<span class="hljs-comment">//右子节点编号</span><br>MiddleTraversal(rightNumber - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>后序遍历<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LastTraversal</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>&#123;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>遍历条件</span><br><span class="hljs-keyword">if</span> (index&gt;=count)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>处理节点无数据</span><br><span class="hljs-keyword">if</span>(data[index].Equals(<span class="hljs-number">-1</span>))<span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">int</span> number = index + <span class="hljs-number">1</span>;<span class="hljs-comment">//编号</span><br><span class="hljs-built_in">int</span> leftNumber = number * <span class="hljs-number">2</span>;<span class="hljs-comment">//左子节点编号</span><br>LastTraversal(leftNumber<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">int</span> rightNumber = number * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<span class="hljs-comment">//右子节点编号</span><br>LastTraversal(rightNumber - <span class="hljs-number">1</span>);<br>Console.Write(data[index] + <span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">//本节点</span><br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>层序遍历<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LayerTraversal</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(data[i].Equals(<span class="hljs-number">-1</span>))<br><span class="hljs-keyword">continue</span>;<br>Console.Write(data[i]+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p>左子节点的值都小于自身，右子节点都大于自身</p><p>方便排序，查找，插入和删除.</p><p>删除比较麻烦.</p><p>使用链式存储比较方便.</p><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668783958961.png"></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>解决问题的思路.设计好的有限的确切的计算序列，可以解决一类问题.<br>评价标准:时间复杂度和空间复杂度</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>2022年11月8日13:18:07<br>排序项也称为关键码<br>稳定:相同数字,在后 排序要还在后面</p><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>时间复杂度O(n^2)<br>从索引1的位置开始排序,遍历到末尾<br>拿当前元素跟前面每个比较,前面大就往后移动,小则元素放在其后,注意元素可能是最小<br>相当于从前面开始比较，进行按个头排队伍,由老师控制</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">42</span>,<span class="hljs-number">20</span>,<span class="hljs-number">17</span>,<span class="hljs-number">27</span>,<span class="hljs-number">13</span>,<span class="hljs-number">8</span>,<span class="hljs-number">17</span>,<span class="hljs-number">48</span>&#125;;<br>InsertSort(data);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> data)<br>&#123;<br>Console.Write(element+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-comment">/*8 13 17 17 20 27 42 48 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] dataArray</span>)</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; dataArray.Length; i++)<br>&#123;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>拿到i位置的元素,跟前面比较，大者后退</span><br><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>=dataArray[i];<br><span class="hljs-built_in">bool</span> flag=<span class="hljs-literal">false</span>;<span class="hljs-comment">//有没有插入,用来判断是否插入最前面</span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)<br>&#123;<br><span class="hljs-keyword">if</span> (dataArray[j] &gt; <span class="hljs-keyword">value</span>)<br>&#123;<br>dataArray[j+<span class="hljs-number">1</span>]=dataArray[j];<span class="hljs-comment">//后退</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>前面比i小</span><br>dataArray[j+<span class="hljs-number">1</span>]=<span class="hljs-keyword">value</span>;<br>flag=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!flag)<br>&#123;<br>dataArray[<span class="hljs-number">0</span>]=<span class="hljs-keyword">value</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>将相邻的记录的关键码进行比较，前面大则交换面<br>时间复杂度O(n^2).</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//2022年11月8日15:27:21</span><br><span class="hljs-built_in">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">42</span>,<span class="hljs-number">20</span>,<span class="hljs-number">17</span>,<span class="hljs-number">27</span>,<span class="hljs-number">13</span>,<span class="hljs-number">8</span>,<span class="hljs-number">48</span>,<span class="hljs-number">17</span>&#125;;<br>BubbleSort(data);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> data)<br>&#123;<br>Console.Write(element+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>*8 13 17 17 20 27 42 48 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] datas</span>)</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; datas.Length; i++)<br>&#123;<br><span class="hljs-comment"><span class="hljs-doctag">///</span></span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;data.Length<span class="hljs-number">-1</span>;j++)<span class="hljs-comment">//-1防止下标越界,但是比较的时候是j+1所以还是会遍历完元素</span><br>&#123;<br><span class="hljs-keyword">if</span> (datas[j] &gt; datas[j + <span class="hljs-number">1</span>])<br>&#123;<br><span class="hljs-built_in">int</span> temp=datas[j+<span class="hljs-number">1</span>];<br>datas[j+<span class="hljs-number">1</span>]=datas[j];<br>datas[j]=temp;<br>&#125;<br>&#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><ol><li>查找最小的数字</li><li>放在0号位置</li><li>从索引1开始找最小数字，放在1号位置(第二层循环)</li><li>依次类推到length-1,因为最后一个肯定最大,共遍历n次</li></ol><ul><li>时间复杂度O(n^2)<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">/*</span><br><span class="hljs-comment">2022年11月8日15:41:54</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">42</span>,<span class="hljs-number">20</span>,<span class="hljs-number">17</span>,<span class="hljs-number">27</span>,<span class="hljs-number">13</span>,<span class="hljs-number">8</span>,<span class="hljs-number">48</span>,<span class="hljs-number">17</span>&#125;;<br>SelectSort(data);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> data)<br>&#123;<br>Console.Write(element+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>*8 13 17 17 20 27 42 48 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SelectSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] datas</span>)</span><br>&#123;<br><span class="hljs-built_in">int</span> length=datas.Length;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; length <span class="hljs-number">-1</span>; i++)<br>&#123;<br><span class="hljs-built_in">int</span> min=datas[i];<span class="hljs-comment">//保留最小数字</span><br><span class="hljs-built_in">int</span> minIndex=i;<span class="hljs-comment">//最小数字的索引，用于交换</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i+<span class="hljs-number">1</span>; j &lt;length; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (datas[j]&lt;min)<br>&#123;<br>min=datas[j];<br>minIndex=j;<br>&#125;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>找到了最小值，进行和i的交换</span><br><span class="hljs-built_in">int</span> temp=datas[i];<br>datas[i]=min;<br>datas[minIndex]=temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>综合来说效率较高<br>分治策略</p><ol><li>先从数列找出一个基准数</li><li>分区过程，将比这个数大的全放在右边，小的全放在左边</li><li>在对左右重复2，直到各区只有一个数</li></ol><p>详细:<br>利用函数的递归调用</p><ol><li>从数列中取出一个数作为基准数,一般是第一个，保存到变量x中,此处变成坑</li><li>从后向前，找小于等于x的数,挖到坑中,自己成坑,1成老坑(循环时3是老坑)   为什么后面:因为要过滤成大的数</li><li>从原坑位向后查找大于等于x的数,把数挖到坑中，自己成坑，2成老坑(前坑向前找小，后坑向后找大)</li><li>循环2和3，直到只剩下一个中间数,放入x</li><li>此时左边虽然无序，但是都小于中间数; 右边也无序，但都大于中间数</li><li>对左右进行1234</li></ol><p>演示:<br>假设一开始序列{xi}是：5，3，7，6，4，1，0，2，9，10，8。<br>此时，ref&#x3D;5，i&#x3D;1，j&#x3D;11，从后往前找，第一个比5小的数是x8&#x3D;2，因此序列为：2，3，7，6，4，1，0，5，9，10，8。<br>此时i&#x3D;1，j&#x3D;8，从前往后找，第一个比5大的数是x3&#x3D;7，因此序列为：2，3，5，6，4，1，0，7，9，10，8。<br>此时，i&#x3D;3，j&#x3D;8，从第8位往前找，第一个比5小的数是x7&#x3D;0，因此：2，3，0，6，4，1，5，7，9，10，8。<br>此时，i&#x3D;3，j&#x3D;7，从第3位往后找，第一个比5大的数是x4&#x3D;6，因此：2，3，0，5，4，1，6，7，9，10，8。<br>此时，i&#x3D;4，j&#x3D;7，从第7位往前找，第一个比5小的数是x6&#x3D;1，因此：2，3，0，1，4，5，6，7，9，10，8。<br>此时，i&#x3D;4，j&#x3D;6，从第4位往后找，直到第6位才有比5大的数，这时，i&#x3D;j&#x3D;6，ref成为一条分界线，它之前的数都比它小，之后的数都比它大，对于前后两部分数，可以采用同样的方法来排序。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">/*2022年11月8日15:55:11*/</span><br><span class="hljs-built_in">int</span>[] datas = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">42</span>,<span class="hljs-number">20</span>,<span class="hljs-number">17</span>,<span class="hljs-number">27</span>,<span class="hljs-number">13</span>,<span class="hljs-number">8</span>,<span class="hljs-number">48</span>,<span class="hljs-number">17</span>&#125;;<br>QuickSort(datas,<span class="hljs-number">0</span>,datas.Length<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> datas)<br>&#123;<br>Console.Write(element+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-comment">/*8 13 17 17 20 27 42 48 */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] datas,<span class="hljs-built_in">int</span> start,<span class="hljs-built_in">int</span> end</span>)<span class="hljs-comment">//因为要递归，从start到end做排序</span></span><br>&#123;<br><span class="hljs-keyword">if</span> (start&gt;=end)<span class="hljs-comment">//这种情况没必要排序了</span><br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]； [1] </span><br><span class="hljs-built_in">int</span> x = datas[start];<br><span class="hljs-comment"><span class="hljs-doctag">///</span>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； [1] </span><br><span class="hljs-built_in">int</span> i=start;<br><span class="hljs-built_in">int</span> j=end;<br>label:<span class="hljs-comment">//为找中间位的死循环</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>&amp;&amp;i&lt;j)<span class="hljs-comment">//防止超出边界</span><br>&#123;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]的值交换； [1] </span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 坑在i</span><br><span class="hljs-keyword">if</span>(datas[j] &lt;x)<span class="hljs-comment">//找到小于x的数,挖坑</span><br>&#123;<br>datas[i]=datas[j];<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>j--;<span class="hljs-comment">//向左移动，对下一个数作比较</span><br>&#125;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]的值交换； [1] </span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>坑在j</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>&amp;&amp;i&lt;j)<br>&#123;<br><span class="hljs-keyword">if</span> (datas[i] &gt;x)<span class="hljs-comment">//找到了大于x的数，挖坑</span><br>&#123;<br>datas[j]=datas[i];<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>i++;<span class="hljs-comment">//i没比x大，继续向后</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(i!=j) <span class="hljs-keyword">goto</span> label;<span class="hljs-comment">//没找到中间位置(基准数本应所在位置)，进行死循环</span><br><span class="hljs-keyword">else</span> datas[i]=x;<span class="hljs-comment">//基准数放在中间位i==j的位置</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>形成 start - i -end</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>5）重复第3、4步，直到i==j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 递归左边</span><br>QuickSort(datas,start,i<span class="hljs-number">-1</span>);<br><span class="hljs-comment"><span class="hljs-doctag">///</span>递归右边</span><br>QuickSort(datas,i+<span class="hljs-number">1</span>,end);<br><span class="hljs-comment"><span class="hljs-doctag">///</span>直到start==end返回</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><hr><p>将进酒<br>李白 〔唐代〕</p><p>君不见黄河之水天上来，奔流到海不复回。<br>君不见高堂明镜悲白发，朝如青丝暮成雪。<br>人得意须尽欢，莫使金樽空对月。<br>天生我材必有用，千金散尽还复来。<br>烹羊宰牛且为乐，会须一饮三百杯。<br>岑夫子，丹丘生，将进酒，杯莫停。<br>与君歌一曲，请君为我倾耳听。<br>钟鼓馔玉不足贵，但愿长醉不愿醒。<br>古来圣贤皆寂寞，惟有饮者留其名。<br>陈王昔时宴平乐，斗酒十千恣欢谑。<br>主人何为言少钱，径须沽取对君酌。<br>五花马、千金裘，呼儿将出换美酒，与尔同销万古愁。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法的学习</title>
      <link href="/2022/11/06/skill/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/11/06/skill/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/v2-4537af4143f242a63266873ccece7196_720w%20(1).webp"><br>程序员之内功</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>描述存储的结构<br>数据:计算机存储的任何东西,如图像，文字，视频…<br>数据元素:如一条学生记录<br>数据项:元素中的列，如学号，姓名.<br>数据对象:一组性质相同的数据元素的集合,如整数.<br>数据类型:如变量的类型.<br>数据结构的分类</p><ul><li>集合:数据间无关系</li><li>线性结构 先后顺序关系，只能一条</li><li>树形结构 根节点分支散页，像家谱</li><li>图 关系复杂的网状，像地图</li></ul><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>元素间有一对一的位置关系</p><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>顺序表优点:易查找；缺点:不易增删</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>判断index暂时不做</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//2022年11月7日05:53:42</span><br><span class="hljs-comment">//2.自己实现list</span><br><span class="hljs-comment">//接口IList</span><br><span class="hljs-comment">//实现方式:顺序表，单链表，双向链表，循环链表</span><br><span class="hljs-comment">//2022年11月7日05:57:26</span><br><span class="hljs-comment">//顺序表：表中的元素的内存位置是连续的，数据顺序存储.</span><br><span class="hljs-comment">//知道第一个元素的地址和大小就能算出其他元素的地址</span><br><span class="hljs-comment">//c#的数组.</span><br><span class="hljs-comment">//3.使用顺序表</span><br>SeqList&lt;<span class="hljs-built_in">string</span>&gt; seqList=<span class="hljs-keyword">new</span>();<br>seqList.Add(<span class="hljs-string">&quot;123&quot;</span>);<br>seqList.Add(<span class="hljs-string">&quot;456&quot;</span>);<br>seqList.Add(<span class="hljs-string">&quot;789&quot;</span>);<br>seqList.Add(<span class="hljs-string">&quot;0&quot;</span>);<br>SeqList&lt;<span class="hljs-built_in">string</span>&gt;.PrintfAll(seqList);<br>Console.WriteLine(seqList.GetElement(<span class="hljs-number">0</span>));<br>Console.WriteLine(seqList[<span class="hljs-number">0</span>]);<br>seqList.Insert(<span class="hljs-string">&quot;666&quot;</span>,<span class="hljs-number">1</span>);<br>SeqList&lt;<span class="hljs-built_in">string</span>&gt;.PrintfAll(seqList);<br>seqList.Delete(<span class="hljs-number">2</span>);<br>SeqList&lt;<span class="hljs-built_in">string</span>&gt;.PrintfAll(seqList);<br>seqList.Clear();<br>SeqList&lt;<span class="hljs-built_in">string</span>&gt;.PrintfAll(seqList);<br>Console.WriteLine(<span class="hljs-string">&quot;ok&quot;</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果:</span><br><span class="hljs-comment">------------------</span><br><span class="hljs-comment">123 456 789 0 </span><br><span class="hljs-comment">123</span><br><span class="hljs-comment">123</span><br><span class="hljs-comment">123 666 456 789 0 </span><br><span class="hljs-comment">123 456 789 0 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">ok</span><br><span class="hljs-comment">-------------------</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//1.IList</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">IListDS</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span>;<br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsEmpty</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params">T item,<span class="hljs-built_in">int</span> index</span>)</span>;<br><span class="hljs-function">T <span class="hljs-title">Delete</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span>;<br>T <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index] &#123;<span class="hljs-keyword">get</span>;&#125;<br><span class="hljs-function">T <span class="hljs-title">GetElement</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Locate</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">SeqList</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IListDS</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>T[] data;<span class="hljs-comment">//用来存储数据</span><br><span class="hljs-built_in">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-comment">//存储数据的个数</span><br><span class="hljs-comment">//数据扩容思想 当data满了的时候，自动创建更大的数组去承接数据</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SeqList</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> size</span>)<span class="hljs-comment">//size最大容量</span></span><br>&#123;<br>data=<span class="hljs-keyword">new</span> T[size];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SeqList</span>():<span class="hljs-title">this</span>(<span class="hljs-params"><span class="hljs-number">10</span></span>)<span class="hljs-comment">//默认构造函数，容量10</span></span><br>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> T <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index] =&gt; <br>GetElement(index);<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (count==data.Length)<span class="hljs-comment">//判断数组有没有满</span><br>&#123;<br>Console.Write(<span class="hljs-string">&quot;顺序表已满&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>data[count]=item;<span class="hljs-comment">//count此时作为计数器,最大的元素位置</span><br>count++;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span><br>&#123;<br>count=<span class="hljs-number">0</span>;<span class="hljs-comment">//因为索引是0，每次取数据就不存在</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Delete</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)<span class="hljs-comment">//和insert差不多</span></span><br>&#123;<br>T temp=data[index];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = index; i &lt; count; i++)<br>&#123;<br>data[i<span class="hljs-number">-1</span>]=data[i];<span class="hljs-comment">//数据向前移动</span><br>&#125;<br>count--;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">GetElement</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (index&gt;=<span class="hljs-number">0</span>&amp;&amp;index&lt;=count<span class="hljs-number">-1</span>)<span class="hljs-comment">//判断索引是否存在</span><br>&#123;<br><span class="hljs-keyword">return</span> data[index];<br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>Console.Write(<span class="hljs-string">&quot;索引不存在&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">default</span>(T);<span class="hljs-comment">//返回默认值</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params">T item, <span class="hljs-built_in">int</span> index</span>)</span><br>&#123;<br><span class="hljs-comment">//index的位置和后面的元素都应该向后移动一位</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = count; i &gt;=index; i--)<span class="hljs-comment">//从前向后遍历会覆盖值</span><br>&#123;<br>data[i+<span class="hljs-number">1</span>]=data[i];<br>&#125;<br>data[index]=item;<br>count++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsEmpty</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> count==<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Locate</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (data[i].Equals(<span class="hljs-keyword">value</span>))<br>&#123;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//表示经过遍历仍未找到数据.</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintfAll</span>(<span class="hljs-params">SeqList&lt;T&gt; seqList</span>)<span class="hljs-comment">//遍历打印</span></span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; seqList.GetLength(); i++)<br>&#123;<br>Console.Write(seqList[i] + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>Console.WriteLine();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="List-lt-gt"><a href="#List-lt-gt" class="headerlink" title="List&lt;&gt;"></a><code>List&lt;&gt;</code></h4><p>c#预定义List泛型<br>使用BCL的List线性表,f12查看更多方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//2022年11月7日05:29:48</span><br><br>List&lt;<span class="hljs-built_in">string</span>&gt; strList=<span class="hljs-keyword">new</span>();<br>strList.Add(<span class="hljs-string">&quot;123&quot;</span>);<span class="hljs-comment">//0</span><br>strList.Add(<span class="hljs-string">&quot;456&quot;</span>);<span class="hljs-comment">//1</span><br>strList.Add(<span class="hljs-string">&quot;789&quot;</span>);<span class="hljs-comment">//2</span><br>strList.Add(<span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-comment">//3</span><br>Console.WriteLine(strList[<span class="hljs-number">2</span>]);<span class="hljs-comment">//通过索引器访问元素</span><br>strList.Remove(<span class="hljs-string">&quot;789&quot;</span>);<span class="hljs-comment">//移除元素</span><br>Console.WriteLine(strList.Count);<span class="hljs-comment">//大小</span><br>strList.Clear();<span class="hljs-comment">//清空</span><br>Console.WriteLine(strList.Count);<br>/CopyTo(),IndexOf(),FindIndex(),Insert(),RemoveAll(),RemoveAt(),Sort(),<br></code></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链式表 逻辑上相邻的元素不要求物理上相邻<br>链表易增删慢查找存储<br>链表的元素:节点&#x3D;数据+指针(引用)<br>头节点无数据,尾节点空指针<br>实现:节点类 数据和引用</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//2022年11月7日10:33:58</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>T data;<span class="hljs-comment">//数据</span><br>Node&lt;T&gt; next;<span class="hljs-comment">//引用</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params">T data</span>)<span class="hljs-comment">//只传递数据</span></span><br>&#123;<br><span class="hljs-keyword">this</span>.data=data;<br>next=<span class="hljs-literal">null</span>;<span class="hljs-comment">//尾节点</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params">T data,Node&lt;T&gt; next</span>)<span class="hljs-comment">//传递数据和指针  </span></span><br>&#123;<br><span class="hljs-keyword">this</span>.data=data;<br><span class="hljs-keyword">this</span>.next=next;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params">Node&lt;T&gt; next</span>)<span class="hljs-comment">//只传入指针 </span></span><br>&#123;<br><span class="hljs-keyword">this</span>.next=next;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>() <span class="hljs-comment">//空方法</span></span><br>&#123;<br>data=<span class="hljs-literal">default</span>(T);<br>next=<span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> T Data<br>&#123;<br><span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> data; &#125;<br><span class="hljs-keyword">set</span> &#123; data = <span class="hljs-keyword">value</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> Node&lt;T&gt; Next<br>&#123;<br><span class="hljs-keyword">get</span>&#123;<span class="hljs-keyword">return</span> next;&#125;<br><span class="hljs-keyword">set</span>&#123;next=<span class="hljs-keyword">value</span>;&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//实现单链表，IList接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">LinkList</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IList</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br><span class="hljs-comment">//使用节点进行存储</span><br>Node&lt;T&gt; head;<span class="hljs-comment">//存储一个头结点</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkList</span>()<span class="hljs-comment">//构造</span></span><br>&#123;<br>head=<span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> T <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>&#123;<br><span class="hljs-keyword">get</span><br>&#123;<br>Node&lt;T&gt; temp = head;<span class="hljs-comment">//从头节点开始遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= index; i++)<br>&#123;<br>temp = temp.Next;<span class="hljs-comment">//temp向后移动</span><br>&#125;<br><span class="hljs-keyword">return</span> temp.Data;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Count</span>()</span><br>&#123;<br>Node&lt;T&gt; temp=head;<br><span class="hljs-built_in">int</span> count=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(temp.Next!=<span class="hljs-literal">null</span>)<br>&#123;<br>count++;<br>temp=temp.Next;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsReadOnly =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br><br><span class="hljs-built_in">int</span> ICollection&lt;T&gt;.Count =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br><br>T IList&lt;T&gt;.<span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index] &#123; <span class="hljs-keyword">get</span> =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); <span class="hljs-keyword">set</span> =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span><br>&#123;<br>Node&lt;T&gt; newNode=<span class="hljs-keyword">new</span> Node&lt;T&gt;(item);<span class="hljs-comment">//根据新的数据创建一个新的节点</span><br><span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)<br>&#123;<br>head=newNode;<span class="hljs-comment">//新节点成为头节点</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//把新节点放在链表的尾部</span><br><span class="hljs-comment">//访问尾结点</span><br>Node&lt;T&gt; temp=head;<span class="hljs-comment">//从头节点开始遍历</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (temp.Next != <span class="hljs-literal">null</span>)<br>&#123;<br>temp=temp.Next;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//next为空，找到了尾节点</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>temp.Next=newNode;<span class="hljs-comment">//让尾节点的next指向新节点。新节点成为了尾节点，添加成功</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span><br>&#123;<br>head=<span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Contains</span>(<span class="hljs-params">T item</span>)</span><br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CopyTo</span>(<span class="hljs-params">T[] array, <span class="hljs-built_in">int</span> arrayIndex</span>)</span><br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator&lt;T&gt; <span class="hljs-title">GetEnumerator</span>()</span><br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">IndexOf</span>(<span class="hljs-params">T item</span>)</span><br>&#123;<br>Node&lt;T&gt; temp = head;<br><span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">null</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (temp.Data.Equals(item))<br>&#123;<br><span class="hljs-keyword">return</span> index;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span>(temp.Next!=<span class="hljs-literal">null</span>)<br>&#123;<br>index++;<br>temp = temp.Next;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, T item</span>)</span><br>&#123;<br><span class="hljs-keyword">var</span> newNode=<span class="hljs-keyword">new</span> Node&lt;T&gt;(item);<span class="hljs-comment">//插入的新节点</span><br><span class="hljs-comment">//暂时不做数据判断</span><br><span class="hljs-keyword">if</span>(index==<span class="hljs-number">0</span>)<span class="hljs-comment">//插入头节点的情况</span><br>&#123;<br>newNode.Next=head;<span class="hljs-comment">//新节点指向原来的头节点</span><br>head=newNode;<span class="hljs-comment">//新节点成为了头节点</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//1.修改上一个节点的next为新节点;2.将自己的next设置为index原来的节点</span><br><span class="hljs-comment">//访问indexs所在的节点</span><br>Node&lt;T&gt; temp = head;<span class="hljs-comment">//从头节点开始遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= index<span class="hljs-number">-1</span>; i++)<span class="hljs-comment">//先访问到index-1</span><br>&#123;<br>temp=temp.Next;<span class="hljs-comment">//temp向后移动</span><br>&#125;<br>Node&lt;T&gt; preNode=temp;<span class="hljs-comment">//上一节点</span><br>Node&lt;T&gt; currentNode=temp.Next;<span class="hljs-comment">//index所在的节点</span><br><span class="hljs-comment">//插入:</span><br>preNode.Next=newNode;<br>newNode.Next=currentNode;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Remove</span>(<span class="hljs-params">T item</span>)</span><br>&#123;<br>Console.Write(<span class="hljs-string">&quot;暂时不要求&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RemoveAt</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)<span class="hljs-comment">//删除头节点</span><br>&#123;<br>head=head.Next;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//删除普通节点</span><br>&#123;<br><span class="hljs-comment">//1.修改上一个节点的next为下一个节点</span><br><span class="hljs-comment">//访问indexs所在的节点</span><br>Node&lt;T&gt; temp = head;<span class="hljs-comment">//从头节点开始遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= index - <span class="hljs-number">1</span>; i++)<span class="hljs-comment">//先访问到index-1</span><br>&#123;<br>temp = temp.Next;<span class="hljs-comment">//temp向后移动</span><br>&#125;<br>Node&lt;T&gt; preNode = temp;<span class="hljs-comment">//上一节点</span><br>Node&lt;T&gt; nextNode = temp.Next.Next;<span class="hljs-comment">//Next是要删除的节点，Next.Next下一个节点</span><br><br>preNode.Next = nextNode;<br>&#125;<br>&#125;<br><br>IEnumerator IEnumerable.GetEnumerator()<br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintfAll</span>(<span class="hljs-params">LinkList&lt;T&gt; seqList</span>)<span class="hljs-comment">//遍历打印</span></span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; seqList.Count(); i++)<br>&#123;<br>Console.Write(seqList[i] + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>Console.WriteLine();<br>&#125;<br>&#125;<br><span class="hljs-comment">//测试</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br>LinkList&lt;<span class="hljs-built_in">string</span>&gt; list=<span class="hljs-keyword">new</span>();<br><br>list.Add(<span class="hljs-string">&quot;123&quot;</span>);<br>list.Add(<span class="hljs-string">&quot;456&quot;</span>);<br>list.Add(<span class="hljs-string">&quot;789&quot;</span>);<br>list.Add(<span class="hljs-string">&quot;0&quot;</span>);<br><br>LinkList&lt;<span class="hljs-built_in">string</span>&gt;.PrintfAll(list);<br>list.Insert(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;666&quot;</span>);<br>LinkList&lt;<span class="hljs-built_in">string</span>&gt;.PrintfAll(list);<br>Console.WriteLine(list.IndexOf(<span class="hljs-string">&quot;666&quot;</span>));<br>list.RemoveAt(<span class="hljs-number">3</span>);<br>LinkList&lt;<span class="hljs-built_in">string</span>&gt;.PrintfAll(list);<br>list.Clear();<br>list.Add(<span class="hljs-string">&quot;000&quot;</span>);<br>LinkList&lt;<span class="hljs-built_in">string</span>&gt;.PrintfAll(list);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">123 456 789 0 </span><br><span class="hljs-comment">123 456 666 789 0 </span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">123 456 666 0 </span><br><span class="hljs-comment">000 </span><br><span class="hljs-comment">*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>双向链表:prev,data,next<br>循环列表:尾节点的next是头节点</p><h4 id="LinkedList-lt-T-gt"><a href="#LinkedList-lt-T-gt" class="headerlink" title="LinkedList&lt;T&gt;"></a><code>LinkedList&lt;T&gt;</code></h4><p>c#的实现是双向链表.</p><ul><li><code>First Last</code></li><li><code>AddAfter() AddFirst() AddLast()</code></li><li><code>Remove(),RemoveFirst(),RemoveLast()</code></li><li><code>Find(),FindLast()</code> </li><li>元素为:<code>LinkedList&lt;T&gt;</code><ul><li>属性:<code>List</code>，<code>Next</code>，<code>Previous</code>和<code>Value</code></li></ul></li></ul><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p> 线性结构<br>操作受到限制的线性表<br>    - 栈只能在一端进行<br>    - 队列的插入在一端，其他操作在另一端</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈的操作限定在表尾(栈顶)</p><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IStackDS</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br><span class="hljs-built_in">int</span> Count &#123;<span class="hljs-keyword">get</span>;&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span>;<br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsEmpty</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Push</span>(<span class="hljs-params">T item</span>)</span>;<br><span class="hljs-function">T <span class="hljs-title">Pop</span>()</span>;<br><span class="hljs-function">T <span class="hljs-title">Peek</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">StackDS</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IStackDS</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>T[] data;<br><span class="hljs-built_in">int</span> top;<span class="hljs-comment">//栈顶的索引</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StackDS</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> size</span>)</span><br>&#123;<br>data=<span class="hljs-keyword">new</span> T[size];<br>top=<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StackDS</span>() : <span class="hljs-title">this</span>(<span class="hljs-params"><span class="hljs-number">10</span></span>)</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Count <br>=&gt; top+<span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span><br>&#123;<br>top=<span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> Count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsEmpty</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> Count==<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Peek</span>()</span><br>&#123;<br>T temp = data[top];<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Pop</span>()</span><br>&#123;<br>T temp=data[top];<br>top--;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Push</span>(<span class="hljs-params">T item</span>)</span><br>&#123;<br>data[top+<span class="hljs-number">1</span>]=item;<span class="hljs-comment">//放在原栈顶的上面</span><br>top++;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br>IStackDS&lt;<span class="hljs-built_in">char</span>&gt; stacks = <span class="hljs-keyword">new</span> StackDS&lt;<span class="hljs-built_in">char</span>&gt;();<br>stacks.Push(<span class="hljs-string">&#x27;a&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;b&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;c&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;d&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;e&#x27;</span>);<br>Console.WriteLine(stacks.Count);<br><span class="hljs-keyword">var</span> v = stacks.Pop();<br>Console.WriteLine(v);<br>Console.WriteLine(stacks.Count);<br><span class="hljs-keyword">var</span> v2 = stacks.Peek();<br>Console.WriteLine(v2);<br>Console.WriteLine(stacks.Count);<br>stacks.Clear();<span class="hljs-comment">//空栈不能进行peek/pop，异常</span><br>Console.WriteLine(stacks.Count);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">e</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">d</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><p>2022年11月7日20:01:07<br>栈顶设在链表的头部，不需要头节点<br>本来遍历到末尾才能添加,现在新节点指向原来的头节点,头节点指向新节点，此时添加只需要头节点</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c#">LinkStack&lt;<span class="hljs-built_in">char</span>&gt; stacks = <span class="hljs-keyword">new</span>();<br>stacks.Push(<span class="hljs-string">&#x27;a&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;b&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;c&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;d&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;e&#x27;</span>);<br>Console.WriteLine(stacks.Count);<br><span class="hljs-keyword">var</span> v = stacks.Pop();<br>Console.WriteLine(v);<br>Console.WriteLine(stacks.Count);<br><span class="hljs-keyword">var</span> v2 = stacks.Peek();<br>Console.WriteLine(v2);<br>Console.WriteLine(stacks.Count);<br>stacks.Clear();<span class="hljs-comment">//空栈不能进行peek/pop，异常</span><br>Console.WriteLine(stacks.Count);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>T data;<br>Node&lt;T&gt; next;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params">T data</span>)</span><br>&#123;<br><span class="hljs-keyword">this</span>.data=data;<br>next=<span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params">T data,Node&lt;T&gt; next</span>)</span><br>&#123;<br><span class="hljs-keyword">this</span>.data=data;<br><span class="hljs-keyword">this</span>.next=next;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params">Node&lt;T&gt; next</span>)</span><br>&#123;<br><span class="hljs-keyword">this</span>.next=next;<br>data=<span class="hljs-literal">default</span>(T);<br>&#125;<br><br><span class="hljs-keyword">public</span> T Data<br>&#123;<br><span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> data; &#125;<br><span class="hljs-keyword">set</span> &#123; data = <span class="hljs-keyword">value</span>; &#125;<br>&#125;<br><span class="hljs-keyword">public</span> Node&lt;T&gt; Next <br>&#123;<br><span class="hljs-keyword">get</span>=&gt;next;<br><span class="hljs-keyword">set</span>=&gt;next=<span class="hljs-keyword">value</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">LinkStack</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>Node&lt;T&gt; top;<span class="hljs-comment">//栈顶元素节点</span><br><span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//栈元素个数</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Count &#123; <span class="hljs-keyword">get</span> =&gt; count; &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span> =&gt; count;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsEmpty =&gt; count == <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span><br>&#123;<br>count=<span class="hljs-number">0</span>;<br>top=<span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Push</span>(<span class="hljs-params">T item</span>)<span class="hljs-comment">//把新添加的元素作为栈顶元素节点</span></span><br>&#123;<br><span class="hljs-keyword">var</span> newNode=<span class="hljs-keyword">new</span> Node&lt;T&gt;(item);<br>newNode.Next=top;<br>top=newNode;<br>count++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Pop</span>()</span><br>&#123;<br>T data=top.Data;<br>top=top.Next;<span class="hljs-comment">//top指向栈顶的下面的元素</span><br>top.Next=<span class="hljs-literal">null</span>;<br>count--;<br><span class="hljs-keyword">return</span> data;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Peek</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> top.Data;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Statck-lt-gt"><a href="#Statck-lt-gt" class="headerlink" title="Statck&lt;&gt; "></a><code>Statck&lt;&gt; </code></h4><p>BCL的栈:<code>Statck&lt;&gt; </code><br>操作:<code>Push(),Pop(),Peek(),Clear(),Count</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//2022年11月7日19:32:47</span><br>Stack&lt;<span class="hljs-built_in">char</span>&gt; stacks=<span class="hljs-keyword">new</span>();<br>stacks.Push(<span class="hljs-string">&#x27;a&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;b&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;c&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;d&#x27;</span>);<br>stacks.Push(<span class="hljs-string">&#x27;e&#x27;</span>);<br>Console.WriteLine(stacks.Count);<br><span class="hljs-keyword">var</span> v=stacks.Pop();<br>Console.WriteLine(v);<br>Console.WriteLine(stacks.Count);<br><span class="hljs-keyword">var</span> v2=stacks.Peek();<br>Console.WriteLine(v2);<br>Console.WriteLine(stacks.Count);<br>stacks.Clear();<span class="hljs-comment">//空栈不能进行peek/pop，异常</span><br>Console.WriteLine(stacks.Count);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">e</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">d</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>插入操作限定尾部队尾，其他操作限定在头部队头 空队列<br>前出后进的核酸排队</p><h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><p>类似顺序栈.<br>队首数组下标0 front<br>队尾 rear<br>队列空:front&#x3D;rear&#x3D;-1<br>循环顺序队列:假溢出<br>删除数据front后移，但是删除过的下标任然可以存储<br>队满后rear从删除过的0再次开始存储</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span>/2022年11月7日20:47:12</span><br>SeqQueue&lt;<span class="hljs-built_in">int</span>&gt; q=<span class="hljs-keyword">new</span>();<br>q.Enqueue(<span class="hljs-number">23</span>);<span class="hljs-comment">//队首</span><br>q.Enqueue(<span class="hljs-number">45</span>);<br>q.Enqueue(<span class="hljs-number">67</span>);<br>q.Enqueue(<span class="hljs-number">89</span>);<span class="hljs-comment">//队尾</span><br><br>Console.WriteLine(<span class="hljs-string">&quot;start:&quot;</span>+q.Count);<br><span class="hljs-keyword">var</span> v=q.Dequeue();<br>Console.WriteLine(<span class="hljs-string">&quot;删除的队首&quot;</span>+v);<br>Console.WriteLine(<span class="hljs-string">&quot;删除后个数&quot;</span>+q.Count);<br>Console.WriteLine(<span class="hljs-string">&quot;现在队首元素&quot;</span>+q.Peek());<br>q.Clear();<br>Console.WriteLine(<span class="hljs-string">&quot;清空&quot;</span>+q.Count);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">start:4</span><br><span class="hljs-comment">删除的队首23</span><br><span class="hljs-comment">删除后个数3</span><br><span class="hljs-comment">现在队首元素45</span><br><span class="hljs-comment">清空0</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">IQueue</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br><span class="hljs-built_in">int</span> Count &#123;<span class="hljs-keyword">get</span>;&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span>;<br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">IsEmpty</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Enqueue</span>(<span class="hljs-params">T item</span>)</span>;<br><span class="hljs-function">T <span class="hljs-title">Dequeue</span>()</span>;<br><span class="hljs-function">T <span class="hljs-title">Peek</span>()</span>;<br>&#125;<br><span class="hljs-comment">//顺序队列</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">SeqQueue</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IQueue</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>T[] data;<br><span class="hljs-built_in">int</span> count;<span class="hljs-comment">//当前元素个数</span><br><span class="hljs-built_in">int</span> front;<span class="hljs-comment">//队首元素索引-1</span><br><span class="hljs-built_in">int</span> rear;<span class="hljs-comment">//队尾元素索引</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SeqQueue</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> size</span>)</span><br>&#123;<br>data=<span class="hljs-keyword">new</span> T[size];<br>count=<span class="hljs-number">0</span>;<br>front=<span class="hljs-number">-1</span>;<br>rear=<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SeqQueue</span>():<span class="hljs-title">this</span>(<span class="hljs-params"><span class="hljs-number">10</span></span>)</span>&#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Count =&gt; count;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span><br>&#123;<br>count=<span class="hljs-number">0</span>;<br>front=rear=<span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Dequeue</span>()</span><br>&#123;<br><span class="hljs-keyword">if</span> (count&gt;<span class="hljs-number">0</span>)<br>&#123;<br>T temp=data[front+<span class="hljs-number">1</span>];<br>front++;<br>count--;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Console.WriteLine(<span class="hljs-string">&quot;队列为空&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">default</span>(T);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Enqueue</span>(<span class="hljs-params">T item</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (count==data.Length)<br>&#123;<br>Console.WriteLine(<span class="hljs-string">&quot;队列已满&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (rear==data.Length)<span class="hljs-comment">//1.rear在最后一个元素索引</span><br>&#123;<br>data[<span class="hljs-number">0</span>]=item;<br>rear=<span class="hljs-number">0</span>;<br>count++;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//正常放在rear后面</span><br>&#123;<br>data[rear+<span class="hljs-number">1</span>]=item;<br>rear++;<br>count++;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span><br>=&gt;count;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsEmpty</span>()</span><br>=&gt;count==<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Peek</span>()</span><br>&#123;<br>T temp = data[front + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h4><p>单链表的简化，仅对首尾操作，不对中间操作</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span>/2022年11月7日21:06:34</span><br><span class="hljs-comment">//</span><br>LinkQueue&lt;<span class="hljs-built_in">int</span>&gt; q=<span class="hljs-keyword">new</span>();<br>q.Enqueue(<span class="hljs-number">23</span>);<span class="hljs-comment">//队首</span><br>q.Enqueue(<span class="hljs-number">45</span>);<br>q.Enqueue(<span class="hljs-number">67</span>);<br>q.Enqueue(<span class="hljs-number">89</span>);<span class="hljs-comment">//队尾</span><br><br>Console.WriteLine(<span class="hljs-string">&quot;start:&quot;</span>+q.Count);<br><span class="hljs-keyword">var</span> v=q.Dequeue();<br>Console.WriteLine(<span class="hljs-string">&quot;删除的队首&quot;</span>+v);<br>Console.WriteLine(<span class="hljs-string">&quot;删除后个数&quot;</span>+q.Count);<br>Console.WriteLine(<span class="hljs-string">&quot;现在队首元素&quot;</span>+q.Peek());<br>q.Clear();<br>Console.WriteLine(<span class="hljs-string">&quot;清空&quot;</span>+q.Count);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">start:4</span><br><span class="hljs-comment">删除的队首23</span><br><span class="hljs-comment">删除后个数3</span><br><span class="hljs-comment">现在队首元素45</span><br><span class="hljs-comment">清空0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>T data;<br>Node&lt;T&gt; next;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span>(<span class="hljs-params">T data</span>)</span>=&gt;<span class="hljs-keyword">this</span>.data=data;<br><br><span class="hljs-keyword">public</span> T Data<br>&#123;<br><span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> data; &#125;<br><span class="hljs-keyword">set</span> &#123; data = <span class="hljs-keyword">value</span>; &#125;<br>&#125;<br><span class="hljs-keyword">public</span> Node&lt;T&gt; Next<br>&#123;<br><span class="hljs-keyword">get</span> =&gt;next;<br><span class="hljs-keyword">set</span> =&gt;next=<span class="hljs-keyword">value</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">LinkQueue</span>&lt;<span class="hljs-title">T</span>&gt;:<span class="hljs-title">Queue</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>Node&lt;T&gt; front;<span class="hljs-comment">//头节点</span><br>Node&lt;T&gt; rear;<span class="hljs-comment">//尾节点</span><br><span class="hljs-built_in">int</span> count;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkQueue</span>()</span><br>&#123;<br>front=<span class="hljs-literal">null</span>;<br>rear=<span class="hljs-literal">null</span>;<br>count=<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Count=&gt;count;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span>=&gt;count;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsEmpty</span>()</span>=&gt;count==<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>()</span><br>&#123;<br>front = <span class="hljs-literal">null</span>;<br>rear = <span class="hljs-literal">null</span>;<br>count = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Enqueue</span>(<span class="hljs-params">T item</span>)<span class="hljs-comment">//队尾入队</span></span><br>&#123;<br><span class="hljs-keyword">var</span> newNode = <span class="hljs-keyword">new</span> Node&lt;T&gt;(item);<br><span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)<span class="hljs-comment">//当前无元素</span><br>&#123;<br>front=newNode;<br>rear=newNode;<br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>rear.Next=newNode;<br>rear=newNode;<br>&#125;<br>count++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Dequeue</span>()</span><br>&#123;<br><span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)<br>&#123;<br>Console.WriteLine(<span class="hljs-string">&quot;队列为空&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">default</span>(T);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>)<span class="hljs-comment">//只有一个元素，队头就是队尾</span><br>&#123;<br>Node&lt;T&gt; node=rear;<br>front=<span class="hljs-literal">null</span>;<br>rear=<span class="hljs-literal">null</span>;<br>count--;<br><span class="hljs-keyword">return</span> node.Data;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Node&lt;T&gt; node=front;<br>front=front.Next;<br>count--;<br><span class="hljs-keyword">return</span> node.Data;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Peek</span>()</span><br>&#123;<br><span class="hljs-keyword">if</span> (front == <span class="hljs-literal">null</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">default</span>(T);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> front.Data;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Queue-lt-gt"><a href="#Queue-lt-gt" class="headerlink" title="Queue&lt;&gt;"></a><code>Queue&lt;&gt;</code></h4><p>BLC的<code>Queue</code>泛型类 <code>Enqueue()</code>插队尾 <code>Dequeue()</code>取删队首 <code>Peek()</code>队首的元素 <code>Clear()</code> <code>Count</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//2022年11月7日20:23:45</span><br>Queue&lt;<span class="hljs-built_in">int</span>&gt; q=<span class="hljs-keyword">new</span>();<br>q.Enqueue(<span class="hljs-number">23</span>);<span class="hljs-comment">//队首</span><br>q.Enqueue(<span class="hljs-number">45</span>);<br>q.Enqueue(<span class="hljs-number">67</span>);<br>q.Enqueue(<span class="hljs-number">89</span>);<span class="hljs-comment">//队尾</span><br><br>Console.WriteLine(<span class="hljs-string">&quot;start:&quot;</span>+q.Count);<br><span class="hljs-keyword">var</span> v=q.Dequeue();<br>Console.WriteLine(<span class="hljs-string">&quot;删除的元素&quot;</span>+v);<br>Console.WriteLine(<span class="hljs-string">&quot;删除后个数&quot;</span>+q.Count);<br>Console.WriteLine(<span class="hljs-string">&quot;队首元素&quot;</span>+q.Peek());<br>q.Clear();<br>Console.WriteLine(<span class="hljs-string">&quot;清空&quot;</span>+q.Count);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">start:4</span><br><span class="hljs-comment">删除的元素23</span><br><span class="hljs-comment">删除后个数3</span><br><span class="hljs-comment">队首元素45</span><br><span class="hljs-comment">清空0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="栈和队列的应用-回文"><a href="#栈和队列的应用-回文" class="headerlink" title="栈和队列的应用:回文"></a>栈和队列的应用:回文</h3><p>一个放栈中，一个放队列中,分别判断出来的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//2022年11月7日21:30:57</span><br><span class="hljs-built_in">string</span> str=Console.ReadLine();<br>Stack&lt;<span class="hljs-built_in">char</span>&gt; stack=<span class="hljs-keyword">new</span>();<br>Queue&lt;<span class="hljs-built_in">char</span>&gt; queue=<span class="hljs-keyword">new</span>();<br><span class="hljs-comment">//存储</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; str.Length; i++)<br>&#123;<br>stack.Push(str[i]);<br>queue.Enqueue(str[i]);<br>&#125;<br><span class="hljs-comment">//比较</span><br><span class="hljs-built_in">bool</span> isHui=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (stack.Count&gt;<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (stack.Pop()!=queue.Dequeue())<br>&#123;<br>isHui=<span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>Console.Write(<span class="hljs-string">&quot;是回文:&quot;</span>+isHui);<br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符组成的有序的序列</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//2022年11月8日06:54:27</span><br><span class="hljs-comment">//基本功能:实现</span><br>StringDS s=<span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;1,a b =&quot;</span>);<br>Console.WriteLine(s.IndexOf(<span class="hljs-keyword">new</span> StringDS(<span class="hljs-string">&quot;a&quot;</span>)));<br>Console.WriteLine(s[<span class="hljs-number">4</span>]);<br>Console.WriteLine(s.Compare(s.SubString(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">b</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">StringDS</span><br>&#123;<br><span class="hljs-built_in">char</span>[] data;<span class="hljs-comment">//存放字符</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>传入char[]构造<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringDS</span>(<span class="hljs-params"><span class="hljs-built_in">char</span>[] array</span>)</span><br>&#123;<br>data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[array.Length];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; data.Length; i++)<br>&#123;<br>data[i] = array[i];<br>&#125;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>传入string构造<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringDS</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span><br>&#123;<br>data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[str.Length];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; data.Length; i++)<br>&#123;<br>data[i] = str[i];<br>&#125;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>索引器<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">char</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]&#123;<span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> data[index]; &#125; &#125;<span class="hljs-comment">//只读</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>获取字符串长度<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetLength</span>()</span> =&gt; data.Length;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>字符串的比较<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Compare</span>(<span class="hljs-params">StringDS s</span>)<span class="hljs-comment">//相同返回0；小-1；大1</span></span><br>&#123;<br><span class="hljs-built_in">int</span> len = <span class="hljs-keyword">this</span>.GetLength() &lt; s.GetLength() ? <span class="hljs-keyword">this</span>.GetLength() : s.GetLength();<span class="hljs-comment">//取得小的字符串的长度</span><br><span class="hljs-built_in">int</span> index = <span class="hljs-number">-1</span>;<span class="hljs-comment">//是否相同,-1相同</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[i] != s[i])<br>&#123;<br>index = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (index != <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[index] &lt; s[index] ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.GetLength() == s.GetLength())<span class="hljs-comment">//前len一样&amp;&amp;长度一样</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//len:abc abcd</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.GetLength() &lt; s.GetLength() ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>连接字符串<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringDS <span class="hljs-title">Concat</span>(<span class="hljs-params">StringDS s1,StringDS s2</span>)</span><br>&#123;<br><span class="hljs-built_in">char</span>[] newData=<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[s1.GetLength()+s2.GetLength()];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; s1.GetLength(); i++)<br>&#123;<br>newData[i]=s1[i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = s1.GetLength(); i &lt; s1.GetLength()+s2.GetLength(); i++)<br>&#123;<br>newData[i] = s2[i];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StringDS(newData);<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>查询子字符串<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">IndexOf</span>(<span class="hljs-params">StringDS s</span>)</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-keyword">this</span>.GetLength()-s.GetLength(); i++)<br>&#123;<br><span class="hljs-built_in">bool</span> flag=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i; j &lt; i + s.GetLength(); j++)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>[j]!=s[j-i])<br>&#123;<br>flag=<span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(flag)<br>&#123;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>子字符串<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> StringDS <span class="hljs-title">SubString</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index,<span class="hljs-built_in">int</span> length</span>)</span><br>&#123;<br><span class="hljs-keyword">var</span> newData=<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[length];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = index; i &lt; index+length; i++)<br>&#123;<br>newData[i-index]=data[i];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StringDS(newData);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>2022年11月8日12:51:41<br>线性表的推广<br>n个相同数据类型的有限序列<br>BLC的<code>Array</code>抽象类<br>在堆上分配空间.数组变量是引用.<br>当数组元素是引用类型时，数组包含的只是引用<br><code>Length,Rank,static BinarySearch&lt;T&gt;()搜索值在数组的位置,static Clear(), Clone,static Copy(),CopyTo(),static CreateInstance()创建数组,GetEnumerator(),GetVaule(),static IndexOf&lt;&gt;(),LastIndexOf(),static Reverse(),SetValue,static Sort()</code></p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>n(n&gt;&#x3D;0)个节点的有限集.<br>n&#x3D;0为空节点<br>发散点为根节点.发散出来的为子节点<br>子树，子节点形成的树<br>不能形成树的节点为叶节点<br>度:拥有子节点节点的个数<br>深度:节点的层数</p><ul><li>子树不相连</li></ul><p>一般是链式存储.</p><ol><li>双亲表示法(data+parent)</li><li>孩子表示法(data+child1+child2+…+child7)</li><li>孩子兄弟表示法(data+firstChild+rightslib)</li></ol><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>最多两个子节点<br>子节点可称为左右子树<br>左斜树 无右节点，反之亦然</p><p>每层最多2^(k-1) k为深度<br>最多:2^0+2^1+2^2+…+2^(k-1)&#x3D;2^k-1</p><p>满二叉树<br>除了最后一层，其他层都有两个子节点的二叉树<br>编号按满二叉树来编号:对于二叉树即使节点不存在也要编号i<br>双亲是i&#x2F;2<br>左子节点2<em>i,右子节点2</em>i+1</p><p>完全二叉树<br>最后一层聚集到左边，右边可空的满二叉树<br>2<em>i&gt;n则无左孩子。2</em>1+1&gt;n则无右孩子 n为总个数</p><p>存储<br>使用顺序存储(数组)做满二叉树状态的数组.用编号换算成索引.<br>特殊的数,通过编号获得兄弟，父子.数据不存在也要有编号，值为空</p><blockquote><p>也可以使用链式存储.但是浪费内存，父节点不好访问</p></blockquote><p>遍历<br>从根节点出发，按某种次序访问所有节点一次<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668741237841.png" alt="数据"></p><blockquote><p>为了把树中的节点变成有意义的线性序列</p></blockquote><ul><li>前序遍历<br>  先输出当前节点的数据,再依次输出左节点和右节点<br>  ABDGHCEIF</li><li>中序遍历<br>  先遍历输出左节点,再输出当前节点的数据，再遍历输出右节点<br>  GDHBAEIGF</li><li>后序遍历<br>  先遍历输出左节点，再遍历输出右节点，最后输出当前节点<br>  GHDBIEFCA</li><li>层序遍历<br>  从第一层开始从上到下逐层遍历，在同一层中逐个输出<br>  ABCDEFGHI</li></ul><h4 id="顺序二叉树"><a href="#顺序二叉树" class="headerlink" title="顺序二叉树"></a>顺序二叉树</h4><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668779393832.png"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br><span class="hljs-built_in">char</span>[] data = &#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-string">&#x27;H&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;J&#x27;</span>&#125;;<br>BiTree&lt;<span class="hljs-built_in">char</span>&gt; tree=<span class="hljs-keyword">new</span> BiTree&lt;<span class="hljs-built_in">char</span>&gt;(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; data.Length; i++)<br>&#123;<br>tree.Add(data[i]);<br>&#125;<br>tree.FirstTraversal(<span class="hljs-number">0</span>);<br>Console.WriteLine();<br>tree.MiddleTraversal(<span class="hljs-number">0</span>);<br>Console.WriteLine();<br>tree.LastTraversal(<span class="hljs-number">0</span>);<br>Console.WriteLine();<br>tree.LayerTraversal(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">BiTree</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">无节点为-1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> T[] data;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> count=<span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BiTree</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> capacity</span>)</span><br>&#123;<br>data=<span class="hljs-keyword">new</span> T[capacity];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (count&gt;=data.Length)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>data[count]=item;<br>count++;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>前序遍历<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FirstTraversal</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>&#123;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>遍历条件</span><br><span class="hljs-keyword">if</span> (index&gt;=count)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>处理节点无数据</span><br><span class="hljs-keyword">if</span>(data[index].Equals(<span class="hljs-number">-1</span>))<span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">int</span> number=index+<span class="hljs-number">1</span>;<span class="hljs-comment">//编号</span><br>Console.Write(data[index]+<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">//本节点</span><br><span class="hljs-built_in">int</span> leftNumber=number*<span class="hljs-number">2</span>;<span class="hljs-comment">//左子节点编号</span><br>FirstTraversal(leftNumber<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">int</span> rightNumber=number*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//右子节点编号</span><br>FirstTraversal(rightNumber<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>中序<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MiddleTraversal</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>&#123;<br><span class="hljs-comment">/*遍历左子节点，再访问当前节点，最后访问右子节点</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>遍历条件</span><br><span class="hljs-keyword">if</span> (index &gt;= count)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>处理节点无数据</span><br><span class="hljs-keyword">if</span> (data[index].Equals(<span class="hljs-number">-1</span>)) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">int</span> number = index + <span class="hljs-number">1</span>;<span class="hljs-comment">//编号</span><br><span class="hljs-built_in">int</span> leftNumber = number * <span class="hljs-number">2</span>;<span class="hljs-comment">//左子节点编号</span><br>MiddleTraversal(leftNumber - <span class="hljs-number">1</span>);<br>Console.Write(data[index] + <span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">//本节点</span><br><span class="hljs-built_in">int</span> rightNumber = number * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<span class="hljs-comment">//右子节点编号</span><br>MiddleTraversal(rightNumber - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>后序遍历<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LastTraversal</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>&#123;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>遍历条件</span><br><span class="hljs-keyword">if</span> (index&gt;=count)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>处理节点无数据</span><br><span class="hljs-keyword">if</span>(data[index].Equals(<span class="hljs-number">-1</span>))<span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">int</span> number = index + <span class="hljs-number">1</span>;<span class="hljs-comment">//编号</span><br><span class="hljs-built_in">int</span> leftNumber = number * <span class="hljs-number">2</span>;<span class="hljs-comment">//左子节点编号</span><br>LastTraversal(leftNumber<span class="hljs-number">-1</span>);<br><span class="hljs-built_in">int</span> rightNumber = number * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<span class="hljs-comment">//右子节点编号</span><br>LastTraversal(rightNumber - <span class="hljs-number">1</span>);<br>Console.Write(data[index] + <span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">//本节点</span><br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span>层序遍历<span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LayerTraversal</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(data[i].Equals(<span class="hljs-number">-1</span>))<br><span class="hljs-keyword">continue</span>;<br>Console.Write(data[i]+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p>左子节点的值都小于自身，右子节点都大于自身</p><p>方便排序，查找，插入和删除.</p><p>删除比较麻烦.</p><p>使用链式存储比较方便.</p><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/1668783958961.png"></p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>解决问题的思路.设计好的有限的确切的计算序列，可以解决一类问题.<br>评价标准:时间复杂度和空间复杂度</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>2022年11月8日13:18:07<br>排序项也称为关键码<br>稳定:相同数字,在后 排序要还在后面</p><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>时间复杂度O(n^2)<br>从索引1的位置开始排序,遍历到末尾<br>拿当前元素跟前面每个比较,前面大就往后移动,小则元素放在其后,注意元素可能是最小<br>相当于从前面开始比较，进行按个头排队伍,由老师控制</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">42</span>,<span class="hljs-number">20</span>,<span class="hljs-number">17</span>,<span class="hljs-number">27</span>,<span class="hljs-number">13</span>,<span class="hljs-number">8</span>,<span class="hljs-number">17</span>,<span class="hljs-number">48</span>&#125;;<br>InsertSort(data);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> data)<br>&#123;<br>Console.Write(element+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-comment">/*8 13 17 17 20 27 42 48 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] dataArray</span>)</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; dataArray.Length; i++)<br>&#123;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>拿到i位置的元素,跟前面比较，大者后退</span><br><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>=dataArray[i];<br><span class="hljs-built_in">bool</span> flag=<span class="hljs-literal">false</span>;<span class="hljs-comment">//有没有插入,用来判断是否插入最前面</span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)<br>&#123;<br><span class="hljs-keyword">if</span> (dataArray[j] &gt; <span class="hljs-keyword">value</span>)<br>&#123;<br>dataArray[j+<span class="hljs-number">1</span>]=dataArray[j];<span class="hljs-comment">//后退</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>前面比i小</span><br>dataArray[j+<span class="hljs-number">1</span>]=<span class="hljs-keyword">value</span>;<br>flag=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!flag)<br>&#123;<br>dataArray[<span class="hljs-number">0</span>]=<span class="hljs-keyword">value</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>将相邻的记录的关键码进行比较，前面大则交换面<br>时间复杂度O(n^2).</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//2022年11月8日15:27:21</span><br><span class="hljs-built_in">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">42</span>,<span class="hljs-number">20</span>,<span class="hljs-number">17</span>,<span class="hljs-number">27</span>,<span class="hljs-number">13</span>,<span class="hljs-number">8</span>,<span class="hljs-number">48</span>,<span class="hljs-number">17</span>&#125;;<br>BubbleSort(data);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> data)<br>&#123;<br>Console.Write(element+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>*8 13 17 17 20 27 42 48 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] datas</span>)</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; datas.Length; i++)<br>&#123;<br><span class="hljs-comment"><span class="hljs-doctag">///</span></span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;data.Length<span class="hljs-number">-1</span>;j++)<span class="hljs-comment">//-1防止下标越界,但是比较的时候是j+1所以还是会遍历完元素</span><br>&#123;<br><span class="hljs-keyword">if</span> (datas[j] &gt; datas[j + <span class="hljs-number">1</span>])<br>&#123;<br><span class="hljs-built_in">int</span> temp=datas[j+<span class="hljs-number">1</span>];<br>datas[j+<span class="hljs-number">1</span>]=datas[j];<br>datas[j]=temp;<br>&#125;<br>&#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><ol><li>查找最小的数字</li><li>放在0号位置</li><li>从索引1开始找最小数字，放在1号位置(第二层循环)</li><li>依次类推到length-1,因为最后一个肯定最大,共遍历n次</li></ol><ul><li>时间复杂度O(n^2)<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">/*</span><br><span class="hljs-comment">2022年11月8日15:41:54</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">42</span>,<span class="hljs-number">20</span>,<span class="hljs-number">17</span>,<span class="hljs-number">27</span>,<span class="hljs-number">13</span>,<span class="hljs-number">8</span>,<span class="hljs-number">48</span>,<span class="hljs-number">17</span>&#125;;<br>SelectSort(data);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> data)<br>&#123;<br>Console.Write(element+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>*8 13 17 17 20 27 42 48 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SelectSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] datas</span>)</span><br>&#123;<br><span class="hljs-built_in">int</span> length=datas.Length;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; length <span class="hljs-number">-1</span>; i++)<br>&#123;<br><span class="hljs-built_in">int</span> min=datas[i];<span class="hljs-comment">//保留最小数字</span><br><span class="hljs-built_in">int</span> minIndex=i;<span class="hljs-comment">//最小数字的索引，用于交换</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = i+<span class="hljs-number">1</span>; j &lt;length; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (datas[j]&lt;min)<br>&#123;<br>min=datas[j];<br>minIndex=j;<br>&#125;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>找到了最小值，进行和i的交换</span><br><span class="hljs-built_in">int</span> temp=datas[i];<br>datas[i]=min;<br>datas[minIndex]=temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>综合来说效率较高<br>分治策略</p><ol><li>先从数列找出一个基准数</li><li>分区过程，将比这个数大的全放在右边，小的全放在左边</li><li>在对左右重复2，直到各区只有一个数</li></ol><p>详细:<br>利用函数的递归调用</p><ol><li>从数列中取出一个数作为基准数,一般是第一个，保存到变量x中,此处变成坑</li><li>从后向前，找小于等于x的数,挖到坑中,自己成坑,1成老坑(循环时3是老坑)   为什么后面:因为要过滤成大的数</li><li>从原坑位向后查找大于等于x的数,把数挖到坑中，自己成坑，2成老坑(前坑向前找小，后坑向后找大)</li><li>循环2和3，直到只剩下一个中间数,放入x</li><li>此时左边虽然无序，但是都小于中间数; 右边也无序，但都大于中间数</li><li>对左右进行1234</li></ol><p>演示:<br>假设一开始序列{xi}是：5，3，7，6，4，1，0，2，9，10，8。<br>此时，ref&#x3D;5，i&#x3D;1，j&#x3D;11，从后往前找，第一个比5小的数是x8&#x3D;2，因此序列为：2，3，7，6，4，1，0，5，9，10，8。<br>此时i&#x3D;1，j&#x3D;8，从前往后找，第一个比5大的数是x3&#x3D;7，因此序列为：2，3，5，6，4，1，0，7，9，10，8。<br>此时，i&#x3D;3，j&#x3D;8，从第8位往前找，第一个比5小的数是x7&#x3D;0，因此：2，3，0，6，4，1，5，7，9，10，8。<br>此时，i&#x3D;3，j&#x3D;7，从第3位往后找，第一个比5大的数是x4&#x3D;6，因此：2，3，0，5，4，1，6，7，9，10，8。<br>此时，i&#x3D;4，j&#x3D;7，从第7位往前找，第一个比5小的数是x6&#x3D;1，因此：2，3，0，1，4，5，6，7，9，10，8。<br>此时，i&#x3D;4，j&#x3D;6，从第4位往后找，直到第6位才有比5大的数，这时，i&#x3D;j&#x3D;6，ref成为一条分界线，它之前的数都比它小，之后的数都比它大，对于前后两部分数，可以采用同样的方法来排序。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">/*2022年11月8日15:55:11*/</span><br><span class="hljs-built_in">int</span>[] datas = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;<span class="hljs-number">42</span>,<span class="hljs-number">20</span>,<span class="hljs-number">17</span>,<span class="hljs-number">27</span>,<span class="hljs-number">13</span>,<span class="hljs-number">8</span>,<span class="hljs-number">48</span>,<span class="hljs-number">17</span>&#125;;<br>QuickSort(datas,<span class="hljs-number">0</span>,datas.Length<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> datas)<br>&#123;<br>Console.Write(element+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-comment">/*8 13 17 17 20 27 42 48 */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] datas,<span class="hljs-built_in">int</span> start,<span class="hljs-built_in">int</span> end</span>)<span class="hljs-comment">//因为要递归，从start到end做排序</span></span><br>&#123;<br><span class="hljs-keyword">if</span> (start&gt;=end)<span class="hljs-comment">//这种情况没必要排序了</span><br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]； [1] </span><br><span class="hljs-built_in">int</span> x = datas[start];<br><span class="hljs-comment"><span class="hljs-doctag">///</span>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； [1] </span><br><span class="hljs-built_in">int</span> i=start;<br><span class="hljs-built_in">int</span> j=end;<br>label:<span class="hljs-comment">//为找中间位的死循环</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>&amp;&amp;i&lt;j)<span class="hljs-comment">//防止超出边界</span><br>&#123;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]的值交换； [1] </span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 坑在i</span><br><span class="hljs-keyword">if</span>(datas[j] &lt;x)<span class="hljs-comment">//找到小于x的数,挖坑</span><br>&#123;<br>datas[i]=datas[j];<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>j--;<span class="hljs-comment">//向左移动，对下一个数作比较</span><br>&#125;<br>&#125;<br><span class="hljs-comment"><span class="hljs-doctag">///</span>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]的值交换； [1] </span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>坑在j</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>&amp;&amp;i&lt;j)<br>&#123;<br><span class="hljs-keyword">if</span> (datas[i] &gt;x)<span class="hljs-comment">//找到了大于x的数，挖坑</span><br>&#123;<br>datas[j]=datas[i];<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>i++;<span class="hljs-comment">//i没比x大，继续向后</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(i!=j) <span class="hljs-keyword">goto</span> label;<span class="hljs-comment">//没找到中间位置(基准数本应所在位置)，进行死循环</span><br><span class="hljs-keyword">else</span> datas[i]=x;<span class="hljs-comment">//基准数放在中间位i==j的位置</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>形成 start - i -end</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span>5）重复第3、4步，直到i==j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 递归左边</span><br>QuickSort(datas,start,i<span class="hljs-number">-1</span>);<br><span class="hljs-comment"><span class="hljs-doctag">///</span>递归右边</span><br>QuickSort(datas,i+<span class="hljs-number">1</span>,end);<br><span class="hljs-comment"><span class="hljs-doctag">///</span>直到start==end返回</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><hr><p>将进酒<br>李白 〔唐代〕</p><p>君不见黄河之水天上来，奔流到海不复回。<br>君不见高堂明镜悲白发，朝如青丝暮成雪。<br>人得意须尽欢，莫使金樽空对月。<br>天生我材必有用，千金散尽还复来。<br>烹羊宰牛且为乐，会须一饮三百杯。<br>岑夫子，丹丘生，将进酒，杯莫停。<br>与君歌一曲，请君为我倾耳听。<br>钟鼓馔玉不足贵，但愿长醉不愿醒。<br>古来圣贤皆寂寞，惟有饮者留其名。<br>陈王昔时宴平乐，斗酒十千恣欢谑。<br>主人何为言少钱，径须沽取对君酌。<br>五花马、千金裘，呼儿将出换美酒，与尔同销万古愁。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的建站之旅</title>
      <link href="/2022/11/05/webabout/web/"/>
      <url>/2022/11/05/webabout/web/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221105201413.jpg"></p><h1 id="我的建站之旅"><a href="#我的建站之旅" class="headerlink" title="我的建站之旅"></a>我的建站之旅</h1><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h3><p>hexo<br>github作为网站地址<br>腾讯云作为图床<br>使用vscode编写网页的md<br>picgo上传图片</p><h3 id="工作进度"><a href="#工作进度" class="headerlink" title="工作进度"></a>工作进度</h3><p>2022&#x2F;11&#x2F;04<br>入园，打算好好打理博客.<br>2022&#x2F;11&#x2F;05<br>做了一天的hexo，终于可以在本地实现界面.<br>实现网络交互<br>更改主题和模板<br>2022年11月6日11:11:45<br>取消和博客园链接，有力picgo，自己做图床</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="实现网页访问"><a href="#实现网页访问" class="headerlink" title="实现网页访问"></a><font style="color:blue">实现网页访问</font></h4><p>2022年11月5日17:34:08 </p><p>访问<a href="https://tupi00.github.io/%E5%8F%AA%E6%9C%89%E4%B8%80%E7%89%87%E7%99%BD%E7%9A%84%EF%BC%8C%E6%88%91%E5%BB%BA%E7%AB%8B%E7%9A%84%E7%BD%91%E9%A1%B5%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%8D%E7%9F%A5%E9%81%93%E5%9C%A8%E5%93%AA%EF%BC%8C%E6%9B%B4%E5%88%AB%E6%8F%90%E5%92%8C%E5%8D%9A%E5%AE%A2%E5%9B%AD%E9%93%BE%E6%8E%A5%E4%BA%86">https://tupi00.github.io/只有一片白的，我建立的网页的地址不知道在哪，更别提和博客园链接了</a>.</p><p>git status<br>git add .<br>git commit -m “2022年11月5日17:37:31”<br>git push main HEAD</p><ul><li>本地和远程没问题</li></ul><p>配置url改为博客地址<br>hexo g</p><h4 id="我的脚本"><a href="#我的脚本" class="headerlink" title="我的脚本:"></a>我的脚本:</h4><p>quickstart:用来简单的开启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd D:\_blog\blogs\hexoblog<br>hexo s<br></code></pre></td></tr></table></figure><p>start:正常启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd blogs<br>cd hexoblog<br>start /min hexo clean<br>ping -n 20 127.0.0.1<br>start /min hexo g<br>ping -n 20 127.0.0.1<br>start /min hexo d<br>ping -n 20 127.0.0.1<br>start taskkill /f /im cmd.exe<br>start D:\_blog\Z_start.bat<br></code></pre></td></tr></table></figure><p>update:不开启服务，上传服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">start /min hexo clean<br>ping -n 20 127.0.0.1<br>start /min hexo g<br>ping -n 20 127.0.0.1<br>start /min hexo d<br>ping -n 20 127.0.0.1<br>cd .deploy_git<br>git add .<br>git commit -m &quot;describe&quot;<br>git remote add origin<br>git push<br>start taskkill /f /im cmd.exe<br></code></pre></td></tr></table></figure><h2 id="荆棘之路"><a href="#荆棘之路" class="headerlink" title="荆棘之路"></a>荆棘之路</h2><h3 id="本地推送到仓库出现问题"><a href="#本地推送到仓库出现问题" class="headerlink" title="本地推送到仓库出现问题"></a><font style="color:blue">本地推送到仓库出现问题</font></h3><p>2022年11月5日15:52:24<br>纯纯的小白 :)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">*fatal: The <span class="hljs-keyword">current</span> branch master has <span class="hljs-keyword">no</span> upstream branch.<span class="hljs-keyword">To</span> push the <span class="hljs-keyword">current</span> branch <span class="hljs-keyword">and</span> <span class="hljs-keyword">set</span> the remote <span class="hljs-keyword">as</span> upstream, use git push <span class="hljs-comment">--set-upstream main master To have this happen automatically for branches without a tracking upstream, see &#x27;push.autoSetupRemote&#x27; in &#x27;git help config&#x27;.*</span><br></code></pre></td></tr></table></figure><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>完全不懂</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add main https://github.com/tupi00/tupi00.github.io<br>git push<br></code></pre></td></tr></table></figure><h3 id="博客网站是空白一片"><a href="#博客网站是空白一片" class="headerlink" title="博客网站是空白一片"></a><font style="color:blue">博客网站是空白一片</font></h3><h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><p>替换默认的DNS加速服务:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"># FancyBox<br># jquery: //cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js<br># fancybox: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js<br># fancybox_css: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css<br>jquery: https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js<br>fancybox: https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.1/jquery.fancybox.min.js<br>fancybox_css: https://cdn.bootcdn.net/ajax/libs/fancybox/3.5.1/jquery.fancybox.min.css<br></code></pre></td></tr></table></figure><h2 id="建站心得"><a href="#建站心得" class="headerlink" title="建站心得"></a>建站心得</h2><hr><p>短歌行<br>王建 〔唐代〕</p><p>人初生，日初出。<br>上山迟，下山疾。<br>百年三万六千朝，夜里分将强半日。<br>有歌有舞须早为，昨日健于今日时。<br>人家见生男女好，不知男女催人老。<br>短歌行，无乐声</p><hr>]]></content>
      
      
      <categories>
          
          <category> 本站 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WPF学习之旅</title>
      <link href="/2022/11/05/skill/wpf/"/>
      <url>/2022/11/05/skill/wpf/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221105200311.jpg"></p><h1 id="WPF学习之旅"><a href="#WPF学习之旅" class="headerlink" title="WPF学习之旅"></a>WPF学习之旅</h1><h2 id="学习之因"><a href="#学习之因" class="headerlink" title="学习之因"></a>学习之因</h2><p>对市面上的记录工具不满意，打算自己编译一个日志流水账软件[Briefy](<a href="https://tupi00.github.io/2022/11/06/csharp/briefy/">Briefy日志 - tupi的博客 (tupi00.github.io)</a>)</p><p>2022年11月8日22:21:08<br>暂停学习，转攻unity和c#语法</p><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p><a href="https://www.bilibili.com/video/BV1ht411e7Fe/?vd_source=5197af4ff987c96800ce69fe5913f522">《深入浅出WPF》系列高清视频教程 | 讲师：刘铁猛</a><br>个人笔记:<a href="https://www.jianguoyun.com/p/DS06iqAQzcrfChjo9uQEIAA">https://www.jianguoyun.com/p/DS06iqAQzcrfChjo9uQEIAA</a></p><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h3><h3 id="工作进度"><a href="#工作进度" class="headerlink" title="工作进度"></a>工作进度</h3><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h2 id="荆棘之路"><a href="#荆棘之路" class="headerlink" title="荆棘之路"></a>荆棘之路</h2><h3 id="error-CS0012-类型“Enum”在未引用的程序集中定义。必须添加对程序集“System-Runtime-Version-x3D-6-0-0-0-Culture-x3D-neutral-PublicKeyToken-x3D-b03f5f7f11d50a3a”的引用。"><a href="#error-CS0012-类型“Enum”在未引用的程序集中定义。必须添加对程序集“System-Runtime-Version-x3D-6-0-0-0-Culture-x3D-neutral-PublicKeyToken-x3D-b03f5f7f11d50a3a”的引用。" class="headerlink" title="error CS0012: 类型“Enum”在未引用的程序集中定义。必须添加对程序集“System.Runtime, Version&#x3D;6.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;b03f5f7f11d50a3a”的引用。"></a><font style="color:blue">error CS0012: 类型“Enum”在未引用的程序集中定义。必须添加对程序集“System.Runtime, Version&#x3D;6.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;b03f5f7f11d50a3a”的引用。</font></h3><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>没有引入System.Runtime.dll</p><h3 id="error-CS0518-预定义类型“System-Void”未定义或导入error-CS0518-预定义类型“System-Boolean”未定义或导入MyApp-txt-3-8-error-CS0518-预定义类型“System-Object”未定义或导入MyApp-txt-5-20-error-CS0518-预定义类型“System-String”未定义或导入MyApp-txt-5-10-error-CS0518-预定义类型“System-Void”未定义或导入"><a href="#error-CS0518-预定义类型“System-Void”未定义或导入error-CS0518-预定义类型“System-Boolean”未定义或导入MyApp-txt-3-8-error-CS0518-预定义类型“System-Object”未定义或导入MyApp-txt-5-20-error-CS0518-预定义类型“System-String”未定义或导入MyApp-txt-5-10-error-CS0518-预定义类型“System-Void”未定义或导入" class="headerlink" title="error CS0518: 预定义类型“System.Void”未定义或导入error CS0518: 预定义类型“System.Boolean”未定义或导入MyApp.txt(3,8): error CS0518: 预定义类型“System.Object”未定义或导入MyApp.txt(5,20): error CS0518: 预定义类型“System.String”未定义或导入MyApp.txt(5,10): error CS0518: 预定义类型“System.Void”未定义或导入"></a><font style="color:blue">error CS0518: 预定义类型“System.Void”未定义或导入error CS0518: 预定义类型“System.Boolean”未定义或导入MyApp.txt(3,8): error CS0518: 预定义类型“System.Object”未定义或导入MyApp.txt(5,20): error CS0518: 预定义类型“System.String”未定义或导入MyApp.txt(5,10): error CS0518: 预定义类型“System.Void”未定义或导入</font></h3><h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><p>没有引入mscorlib.dll</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">csc /r:&quot;C:\Program Files (x86)\dotnet\packs\Microsoft.WindowsDesktop.App.Ref\6.0.10\ref\net6.0\PresentationFramework.dll&quot;,&quot;C:\Program Files (x86)\dotnet\packs\Microsoft.NETCore.App.Ref\6.0.10\ref\net6.0\System.Runtime.dll&quot;,&quot;C:\Program Files (x86)\dotnet\packs\Microsoft.NETCore.App.Ref\6.0.10\ref\net6.0\mscorlib.dll&quot; /t:winexe MyApp.txt<br></code></pre></td></tr></table></figure><p>2022年11月5日07:08:33</p><h3 id="Rider编译器syncing-project-templates"><a href="#Rider编译器syncing-project-templates" class="headerlink" title="Rider编译器syncing project templates "></a><font style="color:blue">Rider编译器syncing project templates </font></h3><p>rider创建新项目一直显示syncing project templates </p><h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><p><a href="https://youtrack.jetbrains.com/issue/RIDER-79427">官方也未曾解决</a> 2022年11月5日08:08:40<br>A:为了工程进度，我只能先放弃2021.3版本Rider，下载2022.2.3试试，结果因为一些原因重装了2021.3倒是解决了 2<br>022年11月5日09:58:12</p><hr><p>江城子·乙卯正月二十日夜记梦<br>苏轼 〔宋代〕</p><p>十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。<br>夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> c# </category>
          
          <category> WPF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内部测试页面</title>
      <link href="/2022/11/05/webabout/test/"/>
      <url>/2022/11/05/webabout/test/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/v2-25b8bd3ce8a1db36584f9179e41f1d30_720w%20(1).webp"></p><h1 id="网页测试页"><a href="#网页测试页" class="headerlink" title="网页测试页"></a>网页测试页</h1><p><a href="#time">跳转到时间测试</a></p><hr><p>uml测试</p><pre><code class=" mermaid">classDiagramclass A A : +String name A : -int age A : List~Object~ child //带泛型的变量 A : +eat() A : +sleep(time) //有参数的方法 A : +getAge() int //有返回值的方法</code></pre><pre><code class=" mermaid">classDiagramclass  B &#123; +String name -int age List~Object~ child +eat() +sleep(time) +getAge() int &#125;</code></pre><hr><p>流程图测试</p><pre><code class=" mermaid">graph TD; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D;</code></pre><pre><code class=" mermaid">graph TB c1--&gt;a2 subgraph one a1--&gt;a2 end subgraph two b1--&gt;b2 end subgraph three c1--&gt;c2 end</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs flow">st=&gt;start:开始<br>op=&gt;operation:操作<br>cond=&gt;condition:Y/N?<br>st-&gt;op-&gt;cond<br>io=&gt;inputoutput:输出<br>sub=&gt;subroutine:子流程<br>end=&gt;end:结束<br>cond(Y)-&gt;io<br>cond(N)-&gt;end<br></code></pre></td></tr></table></figure><hr><p>2022年11月5日19:46:21<br>markdown<br><img src="https://img2022.cnblogs.com/blog/3026848/202211/3026848-20221105154045920-856617644.png" alt="img"></p><hr><p>腾讯云测试<br><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/%E6%97%A0%E6%A0%87%E9%A2%98.png"></p><hr><p>锚点测试:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;Mark&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;这句话定义了锚点所指定的位置标记，名字为“Mark”.<br>[这句话是想要跳转到Mark处的锚点链接，点击即会跳转](<span class="hljs-comment">#Mark).</span><br></code></pre></td></tr></table></figure><p><a href="#Mark">跳转到诗歌</a></p><hr><p>使用html 测试<br><img src="https://img2022.cnblogs.com/blog/3026848/202211/3026848-20221105153612985-708421018.png"/></p><hr><p>使用url 测试<br><a href="https://img2022.cnblogs.com/blog/3026848/202211/3026848-20221105153612985-708421018.png">https://img2022.cnblogs.com/blog/3026848/202211/3026848-20221105153612985-708421018.png</a></p><hr><p>使用url引用测试<br><a href="https://img2022.cnblogs.com/blog/3026848/202211/3026848-20221105153612985-708421018.png">测试</a></p><hr><div id="time">时间测试</div>2022年11月6日17:39:232022年11月6日17:47:452022年11月6日17:58:232022年11月6日18:00:122022年11月6日18:23:252022年11月6日18:23:282022年11月6日18:23:412022年11月6日18:23:472022年11月6日18:23:492022年11月6日18:23:502022年11月6日19:05:56<hr><p>坚果云测试<br><img src="/test_md_files/688290c0-5f6b-11ed-ae30-839e6d328836.jpeg?v=1&type=image"></p><p><img src="https://www.jianguoyun.com/p/DRYU1rcQzcrfChjW6eUEIAA" alt="xxx"></p><hr><div id="Mark">诗歌测试</div><p>短歌行<br>王建 〔唐代〕</p><p>人初生，日初出。<br>上山迟，下山疾。<br>百年三万六千朝，夜里分将强半日。<br>有歌有舞须早为，昨日健于今日时。<br>人家见生男女好，不知男女催人老。<br>短歌行，无乐声</p><hr>]]></content>
      
      
      <categories>
          
          <category> 本站 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>windows shell</title>
      <link href="/2022/11/04/skill/win/"/>
      <url>/2022/11/04/skill/win/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/sesskik___year_of_the_snake_by_cati_art_d5ujgmi-350t-2x.jpg"></p><h1 id="win"><a href="#win" class="headerlink" title="win"></a>win</h1><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">cls清除<br>doskey/HISTORY历史<br>date  /t当前日期<br>time /t当前时间<br>color 02 绿色<br>color 07 黑色<br>start运行程序<br>exit退出cmd<br>shutdown关机等 /s关机/sg彻底关机<br></code></pre></td></tr></table></figure><h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd  <br>cd ..<br></code></pre></td></tr></table></figure><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">dir显示当前目录的子文件和文件<br>dir /b只显示名称<br>tree<br>dir /S本电脑全部文件<br></code></pre></td></tr></table></figure><h3 id="改名"><a href="#改名" class="headerlink" title="改名"></a>改名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ren<br></code></pre></td></tr></table></figure><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">md <br>md movie music 在当前目录中创建名为movie和music的文件夹<br>md d:\test\movie创建d:\test\movie目录<br>rd删除<br></code></pre></td></tr></table></figure><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">copy<br>copy key.txt c:\doc 将当前目录下的key.txt拷贝到c:\doc下（若doc中也存在一个key.txt文件，会询问是否覆盖）<br>copy jobs c:\doc 将当前目录下jobs文件夹中文件（不递归子目录）拷贝到c:\doc下（若doc中也存在相应的文件，会询问是否覆盖）<br>copy key.txt c:\doc\key_bak.txt将当前目录下的key.txt拷贝到c:\doc下，并重命名为key_bak.txt（若doc中也存在一个key_bak.txt文件，会询问是否覆盖)<br>/Y 不询问<br>copy key.txt +复制到自己(相当于重置日期)<br>copy /Y key1.txt + key2.txt key.txt将当前目录下的key1.txt与key2.txt的内容合并写入key.txt中（不询问，直接覆盖写)<br></code></pre></td></tr></table></figure><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">move *.png test 将当前目录下的png图片移动到当前目录下test文件夹中 （若test中也存在同名的png图片，会询问是否覆盖）<br>move /Y *.png test 将当前目录下的png图片移动到当前目录下test文件夹中 （不询问，直接覆盖写)<br>move 1.png d:\test\2.png将当前目录下的1.png移动到d盘test文件夹中，并重命名为2.png （若test中也存在同名的png图片，会询问是否覆盖）<br>move test d:\new 若d盘中存在new文件夹，将当前目录下的test文件夹移动到d盘new文件夹中；若不存在，将当前目录下的test文件夹移动到d盘，并重命名为new (无后缀的未知格式)<br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">del test删除当前目录下的test文件夹中的所有非只读文件（子目录下的文件不删除；删除前会进行确认；等价于del test\*）<br>del /f test <br>删除当前目录下的test文件夹中的所有文件（含只读文件；子目录下的文件不删除；删除前会进行确认；等价于del /f test\*）<br><br>del /f /s /q test d:\test2\*.doc 删除当前目录下的test文件夹中所有文件及d:\test2中所有doc文件（含只读文件；递归子目录下的文件；删除前不确认del<br></code></pre></td></tr></table></figure><h3 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">type<br>type c:\11.txt  显示c盘中11.txt的文本内容<br>type conf.ini 显示当前目录下conf.ini的文本内容<br>type c:\11.txt | more <br>分页显示c盘中11.txt的文本内容  <br><br>more<br>more conf.ini逐屏的显示当前目录下conf.ini的文本内容   【空格：下一屏 q：退出 】<br></code></pre></td></tr></table></figure><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">&amp;顺序执行多条命令，而不管命令是否执行成功<br>cd /d d:\src&amp;work.exe /o c:\result.txt先将当前工作目录切换到d:\src下，然后执行work.exe /o c:\result.txt命令<br>&amp;&amp;顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令<br>find &quot;ok&quot; c:\test.txt &amp;&amp; echo如果找到了&quot;ok&quot;字样，就显示&quot;成功&quot;，找不到就不显示<br>||顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令<br>find &quot;ok&quot; c:\test.txt || echo如果找不到&quot;ok&quot;字样，就显示&quot;不成功&quot;，找到了就不显示<br>,<br>在某些特殊的情况下可以用来代替空格使用<br><br>dir,c:\  <br>相当于：dir c:\<br><br>;当命令相同的时候,可以将不同的目标用;隔离开来但执行效果不变。如执行过程中发生错误则只返回错误报告但程序还是会继续执行<br>dir c:\;d:\;e:\  dir c:\    dir d:\     dir e:\<br></code></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo输出一个&quot;回车换行&quot;，空白行<br>echo off  后续所有命令在执行前，不打印出命令的内容<br>echo on  后续所有命令在执行前，打印出命令的内容<br>echo 123  输出123到终端屏幕<br>echo &quot;Hello World!!!&quot;  输出Hello World!!!到终端屏幕<br>echo test &gt; p1.txt 输出test的字符串到当前目录中的p1.txt文件中（以覆盖的方式）<br></code></pre></td></tr></table></figure><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">find<br>find /N /I &quot;pid&quot; 1.txt 在1.txt文件中忽略大小写查找pid字符串，并带行号显示查找后的结果<br>find /C &quot;exe&quot; 1.txt只显示在1.txt文件中查找到exe字符串的次数<br>find /V &quot;exe&quot; 1.txt显示未包含1.txt文件中未包含exe字符串的行s<br><br>findstr<br>findstr &quot;hello world&quot; 1.txt 在1.txt文件中搜索hello或world<br>findstr /c:&quot;hello world&quot; 1.txt在1.txt文件中搜索hello world<br>findstr /c:&quot;hello world&quot; 1.txt nul<br>在1.txt文件中搜索hello world，并在每行结果前打印出1.txt:   注：findstr只有在2个及以上文件中搜索字符串时才会打印出每个文件的文件名，nul表示一个空文件<br><br>findstr /s /i &quot;Hello&quot; *.*不区分大小写，在当前目录和所有子目录中的所有文件中的hello<br></code></pre></td></tr></table></figure><h3 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping<br>ing baidu.com测试与baidu服务器的连接情况<br>ping chen-pc0  <br>测试机器名为chen-pc0的连接情况<br><br>ping 220.181.111.86  测试与ip为220.181.111.86的连接情况<br>ping -l 65500 -n 10 qq.com  向qq.com发送10次65500字节的ping<br>ping -n 6 127.0.0.1<br>对当前主机执行6次ping操作（花费时间为5s）<br><br>ipconfig /all 查看本地ip地址等详细信息<br>nslookup www.cnblogs.com 获取www.cnblogs.com的域名解析<br><br>netstat<br>netstat -a查看开启了哪些端口<br>netstat -n <br>查看端口的网络连接情况<br>netstat -n <br>查看端口的网络连接情况<br>netstat -p tcp 查看tcp协议的使用情况<br><br>route print  显示出IP路由<br><br>telnet 182.140.167.44 8000  探测182.140.167.44是否使用TCP协议监听8000端口（注意：telnet命令不支持UDP端口检测）<br></code></pre></td></tr></table></figure><h3 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">tasklist全部进程<br><br>taskkill <br>taskkill /im notepad.exe结束名为notepad.exe的进程<br>taskkill /pid 1230 /pid 1241 /pid 1253 /t结束pid为1230、1241和1253的进程以及由它们启动起来的子进程<br>taskkill /f /im cmd.exe /t强制结束有名为cmd.exe的进程以及由它启动起来的子进程<br><br>user<br>net user 查看当前机器上的所有用户<br>net user Administrator  <br>查看当前机器上的Administrator用户的信息<br></code></pre></td></tr></table></figure><p>————————————————<br>版权声明：本文为CSDN博主「IT—INTEREST_挪吒」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/cldimd/article/details/103302720">https://blog.csdn.net/cldimd/article/details/103302720</a></p><h2 id="我的脚本"><a href="#我的脚本" class="headerlink" title="我的脚本"></a>我的脚本</h2><h3 id="上传hexo到github"><a href="#上传hexo到github" class="headerlink" title="上传hexo到github"></a>上传hexo到github</h3><p>bat格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">start /min hexo clean<br>ping -n 20 127.0.0.1<br>start /min hexo g<br>ping -n 20 127.0.0.1<br>start /min hexo d<br>ping -n 20 127.0.0.1<br>cd .deploy_git<br>git add .<br>git commit -m &quot;describe&quot;<br>git remote add origin<br>git push<br>start taskkill /f /im cmd.exe<br></code></pre></td></tr></table></figure><hr><p>沁园春·长沙</p><p><a href="https://so.gushiwen.cn/authorv_22550138288c.aspx">毛泽东</a>  <a href="https://so.gushiwen.cn/shiwens/default.aspx?cstr=%E8%BF%91%E7%8E%B0%E4%BB%A3">〔近现代〕</a></p><p>独立寒秋，湘江北去，橘子洲头。<br>看万山红遍，层林尽染；漫江碧透，百舸争流。<br>鹰击长空，鱼翔浅底，万类霜天竞自由。<br>怅寥廓，问苍茫大地，谁主沉浮？</p><p>携来百侣曾游。忆往昔峥嵘岁月稠。<br>恰同学少年，风华正茂；书生意气，挥斥方遒。<br>指点江山，激扬文字，粪土当年万户侯。<br>曾记否，到中流击水，浪遏飞舟？</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2022/11/04/skill/git/"/>
      <url>/2022/11/04/skill/git/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://blog-1314860893.cos.ap-nanjing.myqcloud.com/sesskik___tenseiga_by_cati_art_d61xzbx-fullview.jpg"></p><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><code>git confi -l</code></p><p>系统配置<code>git config --system --list</code></p><p>在Git\etc\gitconfig配置文件中.</p><p>全局配置<code>git config --global --list</code></p><p>在C:\Users\Administrator\ .gitconfig</p><p>取消代理:<code>git config --global http.sslVerify &quot;false&quot;</code></p><ul><li>配置用户名和邮箱:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;kuangshen&quot;  #名称<br>git config --global user.email 24736743@qq.com   #邮箱<br></code></pre></td></tr></table></figure><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><ul><li>本地 <code>git init</code></li><li>远程克隆<code>git clone [url]</code></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>查看状态:<code>status</code></p><p>追踪到暂存区<code>add</code> 可<code>.</code>表示全部未被跟踪的</p><p>提交暂存区的内容到本地仓库:<code>git commit</code> <code>-m &quot;xxxxxxxxxx&quot;</code>附加消息</p><p>推送到远程仓库<code>git push</code></p><h3 id="忽略"><a href="#忽略" class="headerlink" title="忽略"></a>忽略</h3><p>建立<code>.gitignore</code></p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！<br>!lib.txt     #但lib.txt除外<br>/temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp<br>build/       #忽略build/目录下的所有文件<br>doc/*.txt    #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt<br></code></pre></td></tr></table></figure><h3 id="码云"><a href="#码云" class="headerlink" title="码云"></a>码云</h3><p>设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入 C:\Users\Administrator\.ssh 目录</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">生成公钥</span><br>ssh-keygen<br>ssh-keygen -t rsa #rsa加密<br></code></pre></td></tr></table></figure><p>黏贴公钥文件的内容，到网页生成秘钥</p><p>建立仓库，克隆到本地.</p><ul><li>文件复制到项目.集成操作即可(命令行也行)</li></ul><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有本地分支</span><br>git branch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有远程分支</span><br>git branch -r<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，但依然停留在当前分支</span><br>git branch [branch-name]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，并切换到该分支</span><br>git checkout -b [branch]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">合并指定分支到当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge [branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -d [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin --delete [branch-name]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -dr [remote/branch]</span><br></code></pre></td></tr></table></figure><h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><hr><p>卜算子·咏梅</p><p><a href="https://so.gushiwen.cn/authorv_22550138288c.aspx">毛泽东</a>  <a href="https://so.gushiwen.cn/shiwens/default.aspx?cstr=%E8%BF%91%E7%8E%B0%E4%BB%A3">〔近现代〕</a></p><p>读陆游咏梅词，反其意而用之。</p><p>风雨送春归，飞雪迎春到。已是悬崖百丈冰，犹有花枝俏。<br>俏也不争春，只把春来报。待到山花烂漫时，她在丛中笑。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
